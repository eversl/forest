
Testing forest
Working directory is /Users/leonevers/Dropbox/Coding/forest
compile = /Users/leonevers/Dropbox/Coding/forest/javac  ...
run     = /Users/leonevers/Dropbox/Coding/forest/java  ...
leonevers/Dropbox/Coding/forest/test/jacks/tests/gcj
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/blocks-and-statements/labeled-statements
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/blocks-and-statements/try-statement
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/blocks-and-statements/unreachable-statements
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/classes/constructor-declarations/constructor-body/explicit-constructor-invocations
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/classes/field-declarations/initialization-of-fields
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/classes/method-declarations/method-body
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/interfaces/interface-members
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/lexical-structure/literals/character-literals
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/lexical-structure/unicode
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/jls/packages/import-declarations/type-import-on-demand-declaration
leonevers/Dropbox/Coding/forest/test/jacks/tests/jikes/non-jls/effective-java
leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/arrays/array-initializers

==== 10.6-type-2  expressions in array initializer must be
        assignment compatible with array type  FAILED
==== Contents of test case:

    empty_main T106t2 {
        int[] ia = { 1L };
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 10.6-type-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/binary-compatibility/form-of-binary

==== 13.1-constructor-1  Constructors in a non-private non-static
        nested class have an additional first parameter in the binary, for
        the enclosing class  FAILED
==== Contents of test case:

    empty_class T131c1a {
	class Inner {}
    }
    delete T131c1a.java
    compile -classpath . [saveas T131c1b.java {
class T131c1b {
    Object o = new T131c1a().new Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 13.1-constructor-1 FAILED


==== 13.1-covariance-1  Class files may have more than one method
        with the same parameter types but different return types. In
        particular, legal .class files compiled with gj (generic java) or the
        JSR14 beta compiler (the prequel to the expected JDK 1.5) allow
        covariance in return types, and do so by compiling synthetic bridge
        methods. Here, we check that the compiler is able to gracefully handle
        covariance when loading a .class file, even though this is normally
        a binary incompatible change.  FAILED
==== Contents of test case:

    compile [saveas T131co1a.java {
class T131co1a {
    T131co1b m() { return null; }
}
class T131co1b extends T131co1a {
    T131co1b m() { return null; }
}
class T131co1c extends T131co1b {
    { m(); }
}
    }]
    delete T131co1a.java
    compile -classpath . [saveas T131co1a.java {
class T131co1a {
    T131co1a m() { return null; } // change return type to a instead of b
}
// class T131co1b extends T131co1a {
//     T131co1b m() { return null; } // now covariant!
    // if this class were uncommented and compiled by gj, it would also have
    // /*synthetic*/ T131co1a m() { return /*T131co1b*/m(); }
// }
class T131co1c extends T131co1b {
    { m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 13.1-covariance-1 FAILED


==== 13.1-covariance-2  Class files may have more than one method
        with the same parameter types but different return types. In
        particular, legal .class files compiled with gj (generic java) or the
        JSR14 beta compiler (the prequel to the expected JDK 1.5) allow
        covariance in return types, and do so by compiling synthetic bridge
        methods. Here, we check that the compiler is able to gracefully handle
        covariance when loading a .class file, even though this is normally
        a binary incompatible change.  FAILED
==== Contents of test case:

    compile [saveas T131co2a.java {
class T131co2a {
    T131co2b[] m() { return null; }
}
class T131co2b extends T131co2a {
    T131co2b[] m() { return null; }
}
class T131co2c extends T131co2b {
    { m(); }
}
    }]
    delete T131co2a.java
    compile -classpath . [saveas T131co2a.java {
class T131co2a {
    T131co2a[] m() { return null; } // change return type to a[] instead of b[]
}
// class T131co2b extends T131co2a {
//     T131co2b[] m() { return null; } // now covariant!
    // if this class were uncommented and compiled by gj, it would also have
    // /*synthetic*/ T131co2a[] m() { return /*T131co2b*/m(); }
// }
class T131co2c extends T131co2b {
    { m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 13.1-covariance-2 FAILED


==== 13.1-covariance-3  Class files may have more than one method
        with the same parameter types but different return types. In
        particular, legal .class files compiled with gj (generic java) or the
        JSR14 beta compiler (the prequel to the expected JDK 1.5) allow
        covariance in return types, and do so by compiling synthetic bridge
        methods. Here, we check that the compiler is able to gracefully handle
        covariance when loading a .class file, even though this is normally
        a binary incompatible change.  FAILED
==== Contents of test case:

    compile [saveas T131co3a.java {
interface T131co3a {
    T131co3b m();
}
interface T131co3b extends T131co3a {
    T131co3b m();
}
abstract class T131co3c implements T131co3b {
    { m(); }
}
    }]
    delete T131co3a.java
    compile -classpath . [saveas T131co3a.java {
interface T131co3a {
    T131co3a m(); // change return type to a instead of b
}
// interface T131co3b extends T131co3a {
//     T131co3b m(); // now covariant!
// }
abstract class T131co3c implements T131co3b {
    // if b were uncommented and compiled by gj, this class would also have
    // /*synthetic*/ T131co3a m() { return /*T131co3b*/m(); }
    // Note that calling a.m() may fail when this class is not compiled by
    // gj, as the bridge method is missing; but that is a different problem.
    { m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 13.1-covariance-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/break-statement

==== 14.14-plain-1  plain break must occur in a loop
        statement or switch  FAILED
==== Contents of test case:

    empty_main T1414p1 {
        break;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.14-plain-1 FAILED


==== 14.14-plain-9  plain break must occur in a loop
        statement or switch  FAILED
==== Contents of test case:

    empty_main T1414p9 {
        a: break;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.14-plain-9 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/continue-statement

==== 14.15-plain-1  continue must occur in a loop statement  FAILED
==== Contents of test case:

    empty_main T1415p1 {
        continue;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.15-plain-1 FAILED


==== 14.15-plain-8  continue must occur in a loop statement  FAILED
==== Contents of test case:

    empty_main T1415p8 {
        switch (args.length) {
            case 0: continue;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.15-plain-8 FAILED


==== 14.15-label-1  A label targeted by continue
        must have a loop as its statment  FAILED
==== Contents of test case:

    empty_main T1415l1 {
        a: {
            for (int i=0; i<10; ++i)
                continue a;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.15-label-1 FAILED


==== 14.15-label-2  A label targeted by continue
        must have a loop as its statment  FAILED
==== Contents of test case:

    empty_main T1415l2 {
        a: b: for (int i=0; i<10; ++i)
            continue a;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.15-label-2 FAILED


==== 14.15-label-4  continue must occur in a loop statement  FAILED
==== Contents of test case:

    empty_main T1415l4 {
        a: continue a;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.15-label-4 FAILED


==== 14.15-label-11  continue must occur in a loop statement  FAILED
==== Contents of test case:

    empty_main T1415l11 {
        a: switch (args.length) {
            case 0: continue a;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.15-label-11 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/if-statement

==== 14.9-invalid-syntax-2  Expression must be of type boolean  FAILED
==== Contents of test case:

    empty_main T149is2 {
        if (0)
            ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.9-invalid-syntax-2 FAILED


==== 14.9-expression-evaluation-3 non-constant expression FAILED
==== Contents of test case:

    empty_main T149ee3 {
        final boolean aconst = false;
        boolean anonconst = true;

        if (aconst == anonconst)
            ;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.9-expression-evaluation-3 FAILED


==== 14.9-expression-evaluation-5 non-constant expression FAILED
==== Contents of test case:

    empty_main T149ee5 {
        final byte aconst = 0;
        byte anonconst = 1;

        if (anonconst == aconst)
            ;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.9-expression-evaluation-5 FAILED


==== 14.9-expression-evaluation-7 non-constant expression FAILED
==== Contents of test case:

    empty_main T149ee7 {
        final short aconst = 0;
        short anonconst = 1;

        if (anonconst == aconst)
            ;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.9-expression-evaluation-7 FAILED


==== 14.9-expression-evaluation-9 non-constant expression FAILED
==== Contents of test case:

    empty_main T149ee9 {
        final char aconst = 0;
        char anonconst = 1;

        if (anonconst == aconst)
            ;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.9-expression-evaluation-9 FAILED


==== 14.9-expression-evaluation-11 non-constant expression FAILED
==== Contents of test case:

    empty_main T149ee11 {
        final int aconst = 0;
        int anonconst = 1;

        if (anonconst == aconst)
            ;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.9-expression-evaluation-11 FAILED


==== 14.9-expression-evaluation-13 non-constant expression FAILED
==== Contents of test case:

    empty_main T149ee13 {
        final long aconst = 0L;
        long anonconst = 1L;

        if (anonconst == aconst)
            ;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.9-expression-evaluation-13 FAILED


==== 14.9-expression-evaluation-15 non-constant expression FAILED
==== Contents of test case:

    empty_main T149ee15 {
        final float aconst = 0F;
        float anonconst = 1F;

        if (anonconst == aconst)
            ;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.9-expression-evaluation-15 FAILED


==== 14.9-expression-evaluation-17 non-constant expression FAILED
==== Contents of test case:

    empty_main T149ee17 {
        final double aconst = 0D;
        double anonconst = 1D;

        if (anonconst == aconst)
            ;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.9-expression-evaluation-17 FAILED


==== 14.9-expression-evaluation-19 non-constant expression FAILED
==== Contents of test case:

    empty_main T149ee19 {
        final String aconst = "hi";
        String anonconst = "there";

        if (anonconst == aconst)
            ;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.9-expression-evaluation-19 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/labeled-statements

==== 14.7-shadow-1  Labels cannot shadow another label in the
        same enclosing method, constructor, or initializer  FAILED
==== Contents of test case:

    empty_main T147shadow1 {
        int i;
        test: {
            test: i = 1;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.7-shadow-1 FAILED


==== 14.7-shadow-2  Labels cannot shadow another label in the
        same enclosing method, constructor, or initializer  FAILED
==== Contents of test case:

    empty_main T147shadow2 {
        int i;
        test: test: i = 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.7-shadow-2 FAILED


==== 14.7-shadow-3  Labels cannot shadow another label in the same
        immediately enclosing method, constructor, or initializer. Here, the
        two labels are in different immediately enclosing methods. FAILED
==== Contents of test case:

    empty_main T147shadow3 {
        test: new Object() {
            void foo() {
                int i;
                test: i = 1;
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.7-shadow-3 FAILED


==== 14.7-same-2  Labels can share same identifier as class  FAILED
==== Contents of test case:

    empty_main T147same2 {
        int i;
        T147same2: i = 1;
        new T147same2();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.7-same-2 FAILED


==== 14.7-same-3  Labels can share same identifier as interface  FAILED
==== Contents of test case:

    empty_main T147same3 {
        int i;
        Cloneable: i = 1;
        new Cloneable() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.7-same-3 FAILED


==== 14.7-ident-6  Labels must be identifiers, including unicode  FAILED
==== Contents of test case:

    empty_main T147ident6 {
        int i;
        \u0061\u003a break a;
        b: break \u0062;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.7-ident-6 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/local-class-declarations

==== 14.3-1  tests local class declarations in both static and
        instance methods  FAILED
==== Contents of test case:

    empty_class TestLCD {
        static Object static_method() {
            abstract class Foo { }
            return new Foo() { };
        }
        Object instance_method() {
            abstract class Foo { }
            return new Foo() { };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.3-1 FAILED


==== 14.3-scope-3  The scope of a local class continues to the end
        of the current block  FAILED
==== Contents of test case:

    empty_main T143s3 {
	class Local {
	    { new Local() {}; }
	}
	new Local();
	{
	    new Local();
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.3-scope-3 FAILED


==== 14.3-scope-6  The scope of a local class continues to the end
        of the current block, but may be shadowed in other classes  FAILED
==== Contents of test case:

    empty_main T143s6 {
	class Local {}
	{
	    new Object() {
		class Local {}
	    };
	}
	new Object() {
	    class Local {}
	};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.3-scope-6 FAILED


==== 14.3-scope-7  The scope of a local class continues to the end
        of the current block  FAILED
==== Contents of test case:

    empty_main T143s7 {
	{
	    class Local {}
	}
	class Local {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.3-scope-7 FAILED


==== 14.3-scope-8  Example of scoping, minus failures  FAILED
==== Contents of test case:

    empty_class T143s8 {
	class Cyclic {}
	void foo() {
	    new Cyclic(); // create a T143s8.Cyclic
	    {
		class Local{};
		{
		    class AnotherLocal {
			void bar() {
			    class Local {}; // ok
			}
		    }
		}
	    }
	    class Local{}; // ok, not in scope of prior Local
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.3-scope-8 FAILED


==== 14.3-scope-9  The scope of a local class starts at its
        declaration, not before  FAILED
==== Contents of test case:

    empty_class T143s9 {
	class Local {
	    static final int i = 1;
	}
	void m(int j) {
	    switch (j) {
		case 0:
		case (1 == Local.i ? 1 : 0):
	    }
	    class Local {
		static final int i = 2;
	    }
	    switch (j) {
		case 0:
		case (2 == Local.i ? 1 : 0):
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.3-scope-9 FAILED


==== 14.3-scope-11  While not well-specified, the scope of a local
        class in a switch statement is the immediately enclosing switch
        block statement (and not the entire switch)  FAILED
==== Contents of test case:

    empty_class T143s11 {
	void m(int i) {
	    switch (i) {
		case 0:
		class Local {}
		break;
		case 1:
		class Local {}
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.3-scope-11 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/local-variable-declaration-statements/scope

==== 14.4.2-invalid-scope-1  A local variable cannot be redeclared  FAILED
==== Contents of test case:

    empty_main T1442is1 {
        int i;
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.4.2-invalid-scope-1 FAILED


==== 14.4.2-invalid-scope-2  A local variable cannot be redeclared  FAILED
==== Contents of test case:

    empty_main T1442is2 {
        int i;
        for (int i; ; );
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.4.2-invalid-scope-2 FAILED


==== 14.4.2-invalid-scope-3  A local variable cannot be redeclared  FAILED
==== Contents of test case:

    empty_main T1442is3 {
        int i;
        try {
            throw new Exception();
        } catch (Exception i) {
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.4.2-invalid-scope-3 FAILED


==== 14.4.2-invalid-scope-4  A local variable cannot be redeclared  FAILED
==== Contents of test case:

    empty_class T1442is4 {
        void foo(int i) {
            int i;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.4.2-invalid-scope-4 FAILED


==== 14.4.2-invalid-scope-5  A local variable cannot be redeclared  FAILED
==== Contents of test case:

    empty_main T1442is5 {
        for (int i; ; ) {
            int i;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.4.2-invalid-scope-5 FAILED


==== 14.4.2-invalid-scope-6  A local variable cannot be redeclared  FAILED
==== Contents of test case:

    empty_main T1442is6 {
        try {
            throw new Exception();
        } catch (Exception i) {
            int i;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.4.2-invalid-scope-6 FAILED


==== 14.4.2-shadow-4  A local variable may be shadowed by a member  FAILED
==== Contents of test case:

    empty_main T1442s4 {
        Object i;
        new Object() {
            int i;
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.4.2-shadow-4 FAILED


==== 14.4.2-shadow-5  A local variable may be shadowed by a local  FAILED
==== Contents of test case:

    empty_main T1442s5 {
        final Object i = null;
        new Object() {
            {
                Object o = i;
                int i;
                i = 1;
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.4.2-shadow-5 FAILED


==== 14.4.2-shadow-6  A local variable may be shadowed by a local  FAILED
==== Contents of test case:

    empty_main T1442s6 {
        final Object i = null;
        new Object() {
            {
                Object o = i;
                for (int i = 1; i < 1; );
                o = i;
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.4.2-shadow-6 FAILED


==== 14.4.2-shadow-7  A local variable may be shadowed by a local  FAILED
==== Contents of test case:

    empty_main T1442s7 {
        final int i = 1;
        new Object() {
            {
                try {
                    int j = i;
                    throw new Exception();
                } catch (Exception i) {
                }
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.4.2-shadow-7 FAILED


==== 14.4.2-shadow-8  A local variable may be shadowed by a
        parameter  FAILED
==== Contents of test case:

    empty_main T1442s8 {
        final Object i = null;
        new Object() {
            Object o = i;
            void foo(int i) {
                i = 1;
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.4.2-shadow-8 FAILED


==== 14.4.2-shadow-9  A local variable may be shadowed by an inherited
        member  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T1442s9 {
        void foo(final byte b) {
            class One {
                final int i = 1;
            }
            Object i;
            class Two extends One {
                {
                    switch (b) {
                        case 0:
                        case (i == 1) ? 1 : 0:
                    }
                }
            }
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 14.4.2-shadow-9 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/switch-statement

==== 14.10-invalid-type-1  Expression type must be char, byte, short, or int  FAILED
==== Contents of test case:

    switch_labels T1410it1 boolean

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-invalid-type-1 FAILED


==== 14.10-invalid-type-2  Expression type must be char, byte, short, or int  FAILED
==== Contents of test case:

    switch_labels T1410it2 float

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-invalid-type-2 FAILED


==== 14.10-invalid-type-3  Expression type must be char, byte, short, or int  FAILED
==== Contents of test case:

    switch_labels T1410it3 double

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-invalid-type-3 FAILED


==== 14.10-invalid-type-5  Expression type must be char, byte, short, or int  FAILED
==== Contents of test case:

    switch_labels T1410it5 Object

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-invalid-type-5 FAILED


==== 14.10-invalid-type-6  Expression type must be char, byte, short, or int  FAILED
==== Contents of test case:

    switch_labels T1410it6 String

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-invalid-type-6 FAILED


==== 14.10-switchlabel-2  case label must have a ConstantExpression,
        i++ is not a constant expression as defined by 15.28 FAILED
==== Contents of test case:

    switch_labels T1410sl2 int {case (i++):}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-switchlabel-2 FAILED


==== 14.10-assignable-2  ConstantExpression must be assignable to Expression  FAILED
==== Contents of test case:

    switch_labels T1410a2 int {case 0L:}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-assignable-2 FAILED


==== 14.10-assignable-3  ConstantExpression must be assignable to Expression  FAILED
==== Contents of test case:

    switch_labels T1410a3 int {case 0.0D:}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-assignable-3 FAILED


==== 14.10-assignable-4  ConstantExpression must be assignable to Expression  FAILED
==== Contents of test case:

    switch_labels T1410a4 int {case true:}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-assignable-4 FAILED


==== 14.10-assignable-5  ConstantExpression must be assignable to Expression  FAILED
==== Contents of test case:

    switch_labels T1410a5 byte {case 128:}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-assignable-5 FAILED


==== 14.10-duplicate-1  No two case statements may have the same
        ConstantExpression value  FAILED
==== Contents of test case:

    switch_labels T1410d1 int {case 0: case 1: case 0:}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-duplicate-1 FAILED


==== 14.10-duplicate-2  No two case statements may have the same
        ConstantExpression value  FAILED
==== Contents of test case:

    switch_labels T1410d2 int {case 0: case 1: case (2-2):}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-duplicate-2 FAILED


==== 14.10-duplicate-4  At most 1 default statement can be associated
        with the same switch statement  FAILED
==== Contents of test case:

    switch_labels T1410d4 int {default: case 0: default:}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-duplicate-4 FAILED


==== 14.10-abrupt-completion-2  continue is not a valid abrupt completion  FAILED
==== Contents of test case:

    switch_labels T1410ac2 int {case 0:
                                  break;
                                case 1:
                                  continue;}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.10-abrupt-completion-2 FAILED


==== 14.10-example-1  This example causes an assertion in Jikes  FAILED
==== Contents of test case:

    compile -g [saveas T1410e1.java {
class T1410e1 {
    void foo() {
        int i;
        switch (i = 1) {
            case 1:
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.10-example-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/synchronized-statement

==== 14.18-expression-3  The type of the expression must be a
        reference  FAILED
==== Contents of test case:

    empty_main T1418e3 {
        synchronized (1) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.18-expression-3 FAILED


==== 14.18-expression-4  The type of the expression must be a
        reference  FAILED
==== Contents of test case:

    empty_main T1418e4 {
        synchronized (null) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.18-expression-4 FAILED


==== 14.18-expression-5  The type of the expression must be a
        reference  FAILED
==== Contents of test case:

    empty_main T1418e5 {
        synchronized ('a') {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.18-expression-5 FAILED


==== 14.18-expression-6  The type of the expression must be a
        reference  FAILED
==== Contents of test case:

    empty_main T1418e6 {
        synchronized (System.out.println()) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.18-expression-6 FAILED


==== 14.18-lock-3  A single thread may lock the same object
        multiple times (in a synchronized static method, <name>.class is
        locked) FAILED
==== Contents of test case:

    empty_class T1418l3 {
        static synchronized void foo() {
            synchronized (T1418l3.class) {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.18-lock-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/throw-statement

==== 14.17-null-3  JavaSpecReport 879: null is unchecked (since
        throwing null equates to throwing NullPointerException)  FAILED
==== Contents of test case:

    empty_class T1417n3 {
        void m() {
            new Object() {{ if (true) throw null; }};
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.17-null-3 FAILED


==== 14.17-null-4  JavaSpecReport 879: null is unchecked (since
        throwing null equates to throwing NullPointerException)  FAILED
==== Contents of test case:

    empty_class T1417n4 {
        void m() throws Throwable {
            new Object() {{ if (true) throw null; }};
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.17-null-4 FAILED


==== 14.17-checked-2  Throw statements must be unchecked, caught,
        or declared  FAILED
==== Contents of test case:

    empty_class t1417c2 {
        void m() {
            throw new Exception(); // checked, uncaught and undeclared
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.17-checked-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/try-statement

==== 14.19-shadow-4  A catch clause parameter may shadow a local  FAILED
==== Contents of test case:

    empty_class T1419s4 {
        void foo(final int i) {
            new Object() {
                {
                    try {
                        int j = i;
                        throw new Exception();
                    } catch (Exception i) {
                    }
                }
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.19-shadow-4 FAILED


==== 14.19-shadow-5  A catch clause parameter may shadow a local  FAILED
==== Contents of test case:

    empty_main T1419s5 {
        final int i = 1;
        new Object() {
            {
                try {
                    int j = i;
                    throw new Exception();
                } catch (Exception i) {
                }
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.19-shadow-5 FAILED


==== 14.19-shadow-6  A catch clause parameter may shadow a local  FAILED
==== Contents of test case:

    empty_main T1419s6 {
        int j = 1;
        for (final int i = 1; j < 1; )
            new Object() {
                {
                    try {
                        int j = i;
                        throw new Exception();
                    } catch (Exception i) {
                    }
                }
            };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.19-shadow-6 FAILED


==== 14.19-shadow-7  A catch clause parameter may shadow a local  FAILED
==== Contents of test case:

    empty_main T1419s7 {
        try {
            throw new ArithmeticException();
        } catch (final ArithmeticException i) {
            new Object() {
                {
                    try {
                        ArithmeticException ae = i;
                        throw new NullPointerException();
                    } catch (NullPointerException i) {
                    }
                }
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.19-shadow-7 FAILED


==== 14.19-shadow-9  Local variables may not shadow a catch clause
        parameter  FAILED
==== Contents of test case:

    empty_main T1419s9 {
        try {
            throw new Exception();
        } catch (Exception e) {
            int e;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19-shadow-9 FAILED


==== 14.19-shadow-10  Local variables may not shadow a catch clause
        parameter  FAILED
==== Contents of test case:

    empty_main T1419s10 {
        try {
            throw new Exception();
        } catch (Exception e) {
            try {
                throw new Exception();
            } catch (Exception e) {
            }
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19-shadow-10 FAILED


==== 14.19-shadow-11  A catch clause parameter may be shadowed  FAILED
==== Contents of test case:

    empty_main T1419s11 {
        try {
            throw new Exception();
        } catch (Exception e) {
            new Object() {
                int e;
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.19-shadow-11 FAILED


==== 14.19-shadow-12  A catch clause parameter may be shadowed  FAILED
==== Contents of test case:

    empty_main T1419s12 {
        try {
            throw new Exception();
        } catch (final Exception e) {
            new Object() {
                Object o = e;
                void foo(int e) {}
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.19-shadow-12 FAILED


==== 14.19-shadow-13  A catch clause parameter may be shadowed  FAILED
==== Contents of test case:

    empty_main T1419s13 {
        try {
            throw new Exception();
        } catch (final Exception e) {
            new Object() {
                {
                    Object o = e;
                    int e;
                    e = 1;
                }
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.19-shadow-13 FAILED


==== 14.19-shadow-14  A catch clause parameter may be shadowed  FAILED
==== Contents of test case:

    empty_main T1419s14 {
        try {
            throw new Exception();
        } catch (final Exception e) {
            new Object() {
                {
                    Object o = e;
                    for (int e = 1; e < 1; );
                    o = e;
                }
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.19-shadow-14 FAILED


==== 14.19-shadow-15  A catch clause parameter may be shadowed  FAILED
==== Contents of test case:

    empty_main T1419s15 {
        try {
            throw new ArithmeticException();
        } catch (final ArithmeticException e) {
            new Object() {
                {
                    try {
                        ArithmeticException a = e;
                        throw new NullPointerException();
                    } catch (NullPointerException e) {
                    }
                }
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.19-shadow-15 FAILED


==== 14.19.exception-1  checked exceptions must be caught or
        declared  FAILED
==== Contents of test case:

    empty_class T1419e1 {
	void m() {
	    try {
		throw new Exception();
	    } catch (RuntimeException e) {
	    }
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19.exception-1 FAILED


==== 14.19.exception-3  checked exceptions must be caught or
        declared  FAILED
==== Contents of test case:

    empty_class T1419e3 {
	void m() {
	    try {
		throw new Exception();
	    } finally {
	    }
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19.exception-3 FAILED


==== 14.19.exception-7  checked exceptions must be caught or
        declared  FAILED
==== Contents of test case:

    empty_class T1419e7 {
	void m() {
	    try {
		throw new Exception();
	    } catch (Exception e) {
		throw e;
	    }
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19.exception-7 FAILED


==== 14.19.exception-9  checked exceptions must be caught or
        declared  FAILED
==== Contents of test case:

    empty_class T1419e9 {
	void m() {
	    try {
		throw new Exception();
	    } catch (Exception e) {
		throw e;
	    } finally {
	    }
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19.exception-9 FAILED


==== 14.19.exception-11  checked exceptions must be caught or
        declared  FAILED
==== Contents of test case:

    empty_class T1419e11 {
	void m() {
	    try {
	    } finally {
		throw new Exception();
	    }
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19.exception-11 FAILED


==== 14.19-type-2  The catch variable must extend Throwable  FAILED
==== Contents of test case:

    empty_main T1419t2 {
	try {
	    throw new Error();
	} catch (Error[] e) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19-type-2 FAILED


==== 14.19-type-3  The catch variable must extend Throwable  FAILED
==== Contents of test case:

    empty_main T1419t3 {
	try {
	    throw new Error();
	} catch (int e) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19-type-3 FAILED


==== 14.19-type-4  The catch variable must extend Throwable  FAILED
==== Contents of test case:

    empty_main T1419t4 {
	try {
	    throw new Error();
	} catch (Object e) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19-type-4 FAILED


==== 14.19-type-5  The catch variable must extend Throwable  FAILED
==== Contents of test case:

    empty_main T1419t5 {
	try {
	    throw new Error();
	} catch (java.io.Serializable e) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.19-type-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/blocks-and-statements/unreachable-statements

==== 14.20-block-3  Non-empty blocks complete normally iff last statement does  FAILED
==== Contents of test case:

    empty_main T1420block3 {
        { return; }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-block-3 FAILED


==== 14.20-block-4  Non-empty blocks complete normally iff last statement does  FAILED
==== Contents of test case:

    empty_main T1420block4 {
        { return; }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-block-4 FAILED


==== 14.20-block-5  Non-empty blocks complete normally iff last statement does  FAILED
==== Contents of test case:

    empty_main T1420block5 {
        { return; }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-block-5 FAILED


==== 14.20-block-6  Non-empty blocks complete normally iff last statement does  FAILED
==== Contents of test case:

    empty_main T1420block6 {
        { return; }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-block-6 FAILED


==== 14.20-block-8  First block statement is reachable iff block is;
        all others iff the preceding statement completes normally  FAILED
==== Contents of test case:

    empty_main T1420block8 {
        return;
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-block-8 FAILED


==== 14.20-block-9  First block statement is reachable iff block is;
        all others iff the preceding statement completes normally  FAILED
==== Contents of test case:

    empty_main T1420block9 {
        return;
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-block-9 FAILED


==== 14.20-block-10  First block statement is reachable iff block is;
        all others iff the preceding statement completes normally  FAILED
==== Contents of test case:

    empty_main T1420block10 {
        return;
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-block-10 FAILED


==== 14.20-block-11  First block statement is reachable iff block is;
        all others iff the preceding statement completes normally  FAILED
==== Contents of test case:

    empty_main T1420block11 {
        return;
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-block-11 FAILED


==== 14.20-local-1  Local class declarations can complete normally
        iff reachable  FAILED
==== Contents of test case:

    empty_main T1420local1 {
        class bar {}
        int i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.20-local-1 FAILED


==== 14.20-local-4  Local variable declarations can complete normally
        iff reachable  FAILED
==== Contents of test case:

    empty_main T1420local4 {
        return;
        int j;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-local-4 FAILED


==== 14.20-label-4  Labeled statements without exiting break or
        normal completion of contained statement do not complete normally  FAILED
==== Contents of test case:

    empty_main T1420label4 {
        a: return;
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-4 FAILED


==== 14.20-label-5  Labeled statements without exiting break or
        normal completion of contained statement do not complete normally  FAILED
==== Contents of test case:

    empty_main T1420label5 {
        a: return;
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-5 FAILED


==== 14.20-label-6  Labeled statements without exiting break or
        normal completion of contained statement do not complete normally  FAILED
==== Contents of test case:

    empty_main T1420label6 {
        a: return;
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-6 FAILED


==== 14.20-label-7  Labeled statements without exiting break or
        normal completion of contained statement do not complete normally  FAILED
==== Contents of test case:

    empty_main T1420label7 {
        a: return;
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-7 FAILED


==== 14.20-label-8  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420label8 {
        a: try {
            break a;
        } finally {
            return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-8 FAILED


==== 14.20-label-9  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420label9 {
        a: try {
            break a;
        } finally {
            return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-9 FAILED


==== 14.20-label-10  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420label10 {
        a: try {
            break a;
        } finally {
            return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-10 FAILED


==== 14.20-label-11  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420label11 {
        a: try {
            break a;
        } finally {
            return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-11 FAILED


==== 14.20-label-12  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420label12 {
        a: try {
            throw new Exception();
        } catch (Exception e) {
            break a;
        } finally {
            return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-12 FAILED


==== 14.20-label-13  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420label13 {
        a: try {
            throw new Exception();
        } catch (Exception e) {
            break a;
        } finally {
            return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-13 FAILED


==== 14.20-label-14  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420label14 {
        a: try {
            throw new Exception();
        } catch (Exception e) {
            break a;
        } finally {
            return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-14 FAILED


==== 14.20-label-15  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420label15 {
        a: try {
            throw new Exception();
        } catch (Exception e) {
            break a;
        } finally {
            return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-label-15 FAILED


==== 14.20-expression-1  Expression statements can complete normally
        iff reachable  FAILED
==== Contents of test case:

    empty_main T1420expression1 {
        System.out.println();
        int i;
        i = 1;
        i++;
        --i;
        new Object();
        new Object() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.20-expression-1 FAILED


==== 14.20-expression-2  Expression statements can complete normally
        iff reachable (even if stricter analysis shows otherwise)  FAILED
==== Contents of test case:

    empty_class T1420expression2 {
        void die() { throw new RuntimeException(); }
        void foo() {
            System.exit(1); // never returns
            die(); // always abrupt exit with exception
            Object o = new Object[Integer.MAX_VALUE][Integer.MAX_VALUE][Integer.MAX_VALUE]; // almost a guaranteed OutOfMemoryError
            foo(); // recursion short-circuits rest of method
            int i; // will never get here, but it is reachable
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.20-expression-2 FAILED


==== 14.20-switch-7  A switch statement cannot complete normally if
        all five preceding conditions are not met  FAILED
==== Contents of test case:

    empty_main T1420switch7 {
        switch (args.length) {
            default: return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-7 FAILED


==== 14.20-switch-8  A switch statement cannot complete normally if
        all five preceding conditions are not met  FAILED
==== Contents of test case:

    empty_main T1420switch8 {
        switch (args.length) {
            default: return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-8 FAILED


==== 14.20-switch-9  A switch statement cannot complete normally if
        all five preceding conditions are not met  FAILED
==== Contents of test case:

    empty_main T1420switch9 {
        switch (args.length) {
            default: return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-9 FAILED


==== 14.20-switch-10  A switch statement cannot complete normally if
        all five preceding conditions are not met  FAILED
==== Contents of test case:

    empty_main T1420switch10 {
        switch (args.length) {
            default: return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-10 FAILED


==== 14.20-switch-13  A switchblock statement is unreachable iff it
        bears no label and the prior statement cannot complete normally  FAILED
==== Contents of test case:

    switch_labels T1420switch13 int {
        case 0: 
            return;
            int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-13 FAILED


==== 14.20-switch-14  A switchblock statement is unreachable iff it
        bears no label and the prior statement cannot complete normally  FAILED
==== Contents of test case:

    switch_labels T1420switch14 int {
        case 0: 
            return;
            ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-14 FAILED


==== 14.20-switch-15  A switchblock statement is unreachable iff it
        bears no label and the prior statement cannot complete normally  FAILED
==== Contents of test case:

    switch_labels T1420switch15 int {
        case 0: 
            return;
            {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-15 FAILED


==== 14.20-switch-16  A switchblock statement is unreachable iff it
        bears no label and the prior statement cannot complete normally  FAILED
==== Contents of test case:

    switch_labels T1420switch16 int {
        case 0: 
            return;
            { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-16 FAILED


==== 14.20-switch-17  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420switch17 {
        switch (args.length) {
            default:
            try {
                break;
            } finally {
                return;
            }
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-17 FAILED


==== 14.20-switch-18  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420switch18 {
        switch (args.length) {
            default:
            try {
                break;
            } finally {
                return;
            }
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-18 FAILED


==== 14.20-switch-19  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420switch19 {
        switch (args.length) {
            default:
            try {
                break;
            } finally {
                return;
            }
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-19 FAILED


==== 14.20-switch-20  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420switch20 {
        switch (args.length) {
            default:
            try {
                break;
            } finally {
                return;
            }
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-20 FAILED


==== 14.20-switch-21  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420switch21 {
        switch (args.length) {
            default:
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-21 FAILED


==== 14.20-switch-22  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420switch22 {
        switch (args.length) {
            default:
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-22 FAILED


==== 14.20-switch-23  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420switch23 {
        switch (args.length) {
            default:
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-23 FAILED


==== 14.20-switch-24  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420switch24 {
        switch (args.length) {
            default:
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-switch-24 FAILED


==== 14.20-while-3  A while statement cannot complete normally iff
        there is no break and the condition is constant true  FAILED
==== Contents of test case:

    empty_main T1420while3 {
        while (true);
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-3 FAILED


==== 14.20-while-4  A while statement cannot complete normally iff
        there is no break and the condition is constant true  FAILED
==== Contents of test case:

    empty_main T1420while4 {
        while (true);
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-4 FAILED


==== 14.20-while-5  A while statement cannot complete normally iff
        there is no break and the condition is constant true  FAILED
==== Contents of test case:

    empty_main T1420while5 {
        while (true);
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-5 FAILED


==== 14.20-while-6  A while statement cannot complete normally iff
        there is no break and the condition is constant true  FAILED
==== Contents of test case:

    empty_main T1420while6 {
        while (true);
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-6 FAILED


==== 14.20-while-8  The contained statement of a while is unreachable
        iff the condition is constant false  FAILED
==== Contents of test case:

    empty_main T1420while8 {
        int i;
        while (false) i = 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-8 FAILED


==== 14.20-while-9  The contained statement of a while is unreachable
        iff the condition is constant false  FAILED
==== Contents of test case:

    empty_main T1420while9 {
        while (false);
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-9 FAILED


==== 14.20-while-10  The contained statement of a while is unreachable
        iff the condition is constant false  FAILED
==== Contents of test case:

    empty_main T1420while10 {
        while (false) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-10 FAILED


==== 14.20-while-11  The contained statement of a while is unreachable
        iff the condition is constant false  FAILED
==== Contents of test case:

    empty_main T1420while11 {
        while (false) { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-11 FAILED


==== 14.20-while-12  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420while12 {
        while (true) {
            try {
                break;
            } finally {
                return;
            }
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-12 FAILED


==== 14.20-while-13  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420while13 {
        while (true) {
            try {
                break;
            } finally {
                return;
            }
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-13 FAILED


==== 14.20-while-14  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420while14 {
        while (true) {
            try {
                break;
            } finally {
                return;
            }
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-14 FAILED


==== 14.20-while-15  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420while15 {
        while (true) {
            try {
                break;
            } finally {
                return;
            }
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-15 FAILED


==== 14.20-while-16  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420while16 {
        while (true) {
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-16 FAILED


==== 14.20-while-17  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420while17 {
        while (true) {
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-17 FAILED


==== 14.20-while-18  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420while18 {
        while (true) {
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-18 FAILED


==== 14.20-while-19  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420while19 {
        while (true) {
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-while-19 FAILED


==== 14.20-do-5  A do statement cannot complete normally iff
        all four preceding conditions are not met  FAILED
==== Contents of test case:

    empty_main T1420do5 {
        int i;
        do i = 1;
        while (true);
        int j;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-5 FAILED


==== 14.20-do-6  A do statement cannot complete normally iff
        all four preceding conditions are not met  FAILED
==== Contents of test case:

    empty_main T1420do6 {
        int i;
        do i = 1;
        while (true);
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-6 FAILED


==== 14.20-do-7  A do statement cannot complete normally iff
        all four preceding conditions are not met  FAILED
==== Contents of test case:

    empty_main T1420do7 {
        int i;
        do i = 1;
        while (true);
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-7 FAILED


==== 14.20-do-8  A do statement cannot complete normally iff
        all four preceding conditions are not met  FAILED
==== Contents of test case:

    empty_main T1420do8 {
        int i;
        do i = 1;
        while (true);
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-8 FAILED


==== 14.20-do-9  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do9 {
        do try {
            break;
        } finally {
            return;
        } while (true);
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-9 FAILED


==== 14.20-do-10  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do10 {
        do try {
            break;
        } finally {
            return;
        } while (true);
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-10 FAILED


==== 14.20-do-11  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do11 {
        do try {
            break;
        } finally {
            return;
        } while (true);
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-11 FAILED


==== 14.20-do-12  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do12 {
        do try {
            break;
        } finally {
            return;
        } while (true);
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-12 FAILED


==== 14.20-do-13  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do13 {
        do try {
            throw new Exception();
        } catch (Exception e) {
            break;
        } finally {
            return;
        } while (true);
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-13 FAILED


==== 14.20-do-14  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do14 {
        do try {
            throw new Exception();
        } catch (Exception e) {
            break;
        } finally {
            return;
        } while (true);
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-14 FAILED


==== 14.20-do-15  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do15 {
        do try {
            throw new Exception();
        } catch (Exception e) {
            break;
        } finally {
            return;
        } while (true);
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-15 FAILED


==== 14.20-do-16  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do16 {
        do try {
            throw new Exception();
        } catch (Exception e) {
            break;
        } finally {
            return;
        } while (true);
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-16 FAILED


==== 14.20-do-17  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do17 {
        do try {
            continue;
        } finally {
            return;
        } while (false);
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-17 FAILED


==== 14.20-do-18  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do18 {
        do try {
            continue;
        } finally {
            return;
        } while (false);
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-18 FAILED


==== 14.20-do-19  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do19 {
        do try {
            continue;
        } finally {
            return;
        } while (false);
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-19 FAILED


==== 14.20-do-20  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do20 {
        do try {
            continue;
        } finally {
            return;
        } while (false);
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-20 FAILED


==== 14.20-do-21  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do21 {
        do try {
            throw new Exception();
        } catch (Exception e) {
            continue;
        } finally {
            return;
        } while (false);
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-21 FAILED


==== 14.20-do-22  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do22 {
        do try {
            throw new Exception();
        } catch (Exception e) {
            continue;
        } finally {
            return;
        } while (false);
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-22 FAILED


==== 14.20-do-23  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do23 {
        do try {
            throw new Exception();
        } catch (Exception e) {
            continue;
        } finally {
            return;
        } while (false);
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-23 FAILED


==== 14.20-do-24  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do24 {
        do try {
            throw new Exception();
        } catch (Exception e) {
            continue;
        } finally {
            return;
        } while (false);
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-24 FAILED


==== 14.20-do-25  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do25 {
        a: do try {
            continue a;
        } finally {
            return;
        } while (false);
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-25 FAILED


==== 14.20-do-26  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do26 {
        a: do try {
            continue a;
        } finally {
            return;
        } while (false);
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-26 FAILED


==== 14.20-do-27  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do27 {
        a: do try {
            continue a;
        } finally {
            return;
        } while (false);
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-27 FAILED


==== 14.20-do-28  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do28 {
        a: do try {
            continue a;
        } finally {
            return;
        } while (false);
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-28 FAILED


==== 14.20-do-29  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do29 {
        a: do try {
            throw new Exception();
        } catch (Exception e) {
            continue a;
        } finally {
            return;
        } while (false);
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-29 FAILED


==== 14.20-do-30  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do30 {
        a: do try {
            throw new Exception();
        } catch (Exception e) {
            continue a;
        } finally {
            return;
        } while (false);
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-30 FAILED


==== 14.20-do-31  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do31 {
        a: do try {
            throw new Exception();
        } catch (Exception e) {
            continue a;
        } finally {
            return;
        } while (false);
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-31 FAILED


==== 14.20-do-32  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do32 {
        a: do try {
            throw new Exception();
        } catch (Exception e) {
            continue a;
        } finally {
            return;
        } while (false);
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-32 FAILED


==== 14.20-do-33  The continue is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420do33 {
        a: do {
            try {
                throw new Exception();
            } catch (Exception e) {
                continue a;
            } finally {
                return;
            }
        } while (false);
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-do-33 FAILED


==== 14.20-for-3  A for statement cannot complete normally if there
        is no condition or the condition is constant true, and there is no break  FAILED
==== Contents of test case:

    empty_main T1420for3 {
        for ( ; ; );
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-3 FAILED


==== 14.20-for-4  A for statement cannot complete normally if there
        is no condition or the condition is constant true, and there is no break  FAILED
==== Contents of test case:

    empty_main T1420for4 {
        for ( ; ; );
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-4 FAILED


==== 14.20-for-5  A for statement cannot complete normally if there
        is no condition or the condition is constant true, and there is no break  FAILED
==== Contents of test case:

    empty_main T1420for5 {
        for ( ; ; );
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-5 FAILED


==== 14.20-for-6  A for statement cannot complete normally if there
        is no condition or the condition is constant true, and there is no break  FAILED
==== Contents of test case:

    empty_main T1420for6 {
        for ( ; ; );
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-6 FAILED


==== 14.20-for-7  A for statement cannot complete normally if there
        is no condition or the condition is constant true, and there is no break  FAILED
==== Contents of test case:

    empty_main T1420for7 {
        for ( ; true; );
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-7 FAILED


==== 14.20-for-8  A for statement cannot complete normally if there
        is no condition or the condition is constant true, and there is no break  FAILED
==== Contents of test case:

    empty_main T1420for8 {
        for ( ; true; );
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-8 FAILED


==== 14.20-for-9  A for statement cannot complete normally if there
        is no condition or the condition is constant true, and there is no break  FAILED
==== Contents of test case:

    empty_main T1420for9 {
        for ( ; true; );
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-9 FAILED


==== 14.20-for-10  A for statement cannot complete normally if there
        is no condition or the condition is constant true, and there is no break  FAILED
==== Contents of test case:

    empty_main T1420for10 {
        for ( ; true; );
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-10 FAILED


==== 14.20-for-11  A for statement cannot have a constant false condition  FAILED
==== Contents of test case:

    empty_main T1420for11 {
        int i;
        for( ; false; ) i = 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-11 FAILED


==== 14.20-for-12  A for statement cannot have a constant false condition  FAILED
==== Contents of test case:

    empty_main T1420for12 {
        for ( ; false; );
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-12 FAILED


==== 14.20-for-13  A for statement cannot have a constant false condition  FAILED
==== Contents of test case:

    empty_main T1420for13 {
        for ( ; false; ) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-13 FAILED


==== 14.20-for-14  A for statement cannot have a constant false condition  FAILED
==== Contents of test case:

    empty_main T1420for14 {
        for ( ; false; ) { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-14 FAILED


==== 14.20-for-15  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420for15 {
        for ( ; ; )
            try {
                break;
            } finally {
                return;
            }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-15 FAILED


==== 14.20-for-16  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420for16 {
        for ( ; ; )
            try {
                break;
            } finally {
                return;
            }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-16 FAILED


==== 14.20-for-17  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420for17 {
        for ( ; ; )
            try {
                break;
            } finally {
                return;
            }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-17 FAILED


==== 14.20-for-18  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420for18 {
        for ( ; ; )
            try {
                break;
            } finally {
                return;
            }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-18 FAILED


==== 14.20-for-19  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420for19 {
        for ( ; ; )
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-19 FAILED


==== 14.20-for-20  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420for20 {
        for ( ; ; )
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-20 FAILED


==== 14.20-for-21  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420for21 {
        for ( ; ; )
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-21 FAILED


==== 14.20-for-22  The break is interrupted by the try-finally  FAILED
==== Contents of test case:

    empty_main T1420for22 {
        for ( ; ; )
            try {
                throw new Exception();
            } catch (Exception e) {
                break;
            } finally {
                return;
            }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-for-22 FAILED


==== 14.20-abrupt-1  break cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt1 {
        while (true) {
            break;
            int i;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-1 FAILED


==== 14.20-abrupt-2  break cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt2 {
        while (true) {
            break;
            ;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-2 FAILED


==== 14.20-abrupt-3  break cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt3 {
        while (true) {
            break;
            {}
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-3 FAILED


==== 14.20-abrupt-4  break cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt4 {
        while (true) {
            break;
            { int x=3; }
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-4 FAILED


==== 14.20-abrupt-5  continue cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt5 {
        while (true) {
            continue;
            int i;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-5 FAILED


==== 14.20-abrupt-6  continue cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt6 {
        while (true) {
            continue;
            ;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-6 FAILED


==== 14.20-abrupt-7  continue cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt7 {
        while (true) {
            continue;
            {}
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-7 FAILED


==== 14.20-abrupt-8  continue cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt8 {
        while (true) {
            continue;
            { int x=3; }
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-8 FAILED


==== 14.20-abrupt-9  return cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt9 {
        return;
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-9 FAILED


==== 14.20-abrupt-10  return cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt10 {
        return;
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-10 FAILED


==== 14.20-abrupt-11  return cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt11 {
        return;
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-11 FAILED


==== 14.20-abrupt-12  return cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt12 {
        return;
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-12 FAILED


==== 14.20-abrupt-13  throw cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt13 {
        throw new RuntimeException();
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-13 FAILED


==== 14.20-abrupt-14  throw cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt14 {
        throw new RuntimeException();
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-14 FAILED


==== 14.20-abrupt-15  throw cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt15 {
        throw new RuntimeException();
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-15 FAILED


==== 14.20-abrupt-16  throw cannot complete normally  FAILED
==== Contents of test case:

    empty_main T1420abrupt16 {
        throw new RuntimeException();
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-abrupt-16 FAILED


==== 14.20-synchronized-2  synchronized completes normally iff the
        contained block does as well  FAILED
==== Contents of test case:

    empty_main T1420synch2 {
        synchronized (args) {
            return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-synchronized-2 FAILED


==== 14.20-synchronized-3  synchronized completes normally iff the
        contained block does as well  FAILED
==== Contents of test case:

    empty_main T1420synch3 {
        synchronized (args) {
            return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-synchronized-3 FAILED


==== 14.20-synchronized-4  synchronized completes normally iff the
        contained block does as well  FAILED
==== Contents of test case:

    empty_main T1420synch4 {
        synchronized (args) {
            return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-synchronized-4 FAILED


==== 14.20-synchronized-5  synchronized completes normally iff the
        contained block does as well  FAILED
==== Contents of test case:

    empty_main T1420synch5 {
        synchronized (args) {
            return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-synchronized-5 FAILED


==== 14.20-try-2  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try2 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-2 FAILED


==== 14.20-try-3  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try3 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-3 FAILED


==== 14.20-try-4  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try4 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-4 FAILED


==== 14.20-try-5  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try5 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-5 FAILED


==== 14.20-try-8  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try8 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } finally {
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-8 FAILED


==== 14.20-try-9  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try9 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } finally {
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-9 FAILED


==== 14.20-try-10  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try10 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } finally {
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-10 FAILED


==== 14.20-try-11  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try11 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } finally {
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-11 FAILED


==== 14.20-try-13  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try13 {
        try {
            new Object();
        } catch (Exception e) {
            return;
        } finally {
            return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-13 FAILED


==== 14.20-try-14  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try14 {
        try {
            new Object();
        } catch (Exception e) {
            return;
        } finally {
            return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-14 FAILED


==== 14.20-try-15  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try15 {
        try {
            new Object();
        } catch (Exception e) {
            return;
        } finally {
            return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-15 FAILED


==== 14.20-try-16  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try16 {
        try {
            new Object();
        } catch (Exception e) {
            return;
        } finally {
            return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-16 FAILED


==== 14.20-try-17  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try17 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } finally {
            return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-17 FAILED


==== 14.20-try-18  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try18 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } finally {
            return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-18 FAILED


==== 14.20-try-19  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try19 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } finally {
            return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-19 FAILED


==== 14.20-try-20  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try20 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } finally {
            return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-20 FAILED


==== 14.20-try-21  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try21 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } catch (Throwable t) {
        } finally {
            return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-21 FAILED


==== 14.20-try-22  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try22 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } catch (Throwable t) {
        } finally {
            return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-22 FAILED


==== 14.20-try-23  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try23 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } catch (Throwable t) {
        } finally {
            return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-23 FAILED


==== 14.20-try-24  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try24 {
        try {
            throw new Exception();
        } catch (Exception e) {
            return;
        } catch (Throwable t) {
        } finally {
            return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-24 FAILED


==== 14.20-try-26  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try26 {
        try {
            throw new RuntimeException();
        } finally {
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-26 FAILED


==== 14.20-try-27  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try27 {
        try {
            throw new RuntimeException();
        } finally {
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-27 FAILED


==== 14.20-try-28  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try28 {
        try {
            throw new RuntimeException();
        } finally {
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-28 FAILED


==== 14.20-try-29  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try29 {
        try {
            throw new RuntimeException();
        } finally {
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-29 FAILED


==== 14.20-try-30  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try30 {
        try {
            new Object();
        } finally {
            return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-30 FAILED


==== 14.20-try-31  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try31 {
        try {
            new Object();
        } finally {
            return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-31 FAILED


==== 14.20-try-32  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try32 {
        try {
            new Object();
        } finally {
            return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-32 FAILED


==== 14.20-try-33  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try33 {
        try {
            new Object();
        } finally {
            return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-33 FAILED


==== 14.20-try-34  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try34 {
        try {
            throw new Exception();
        } finally {
            return;
        }
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-34 FAILED


==== 14.20-try-35  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try35 {
        try {
            throw new Exception();
        } finally {
            return;
        }
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-35 FAILED


==== 14.20-try-36  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try36 {
        try {
            throw new Exception();
        } finally {
            return;
        }
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-36 FAILED


==== 14.20-try-37  A try statement can complete normally iff both:
        The try block can complete normally or any catch block can complete normally.
        The finally block, if present, can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420try37 {
        try {
            throw new Exception();
        } finally {
            return;
        }
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-try-37 FAILED


==== 14.20-catch-4  A catch block C is reachable iff both:
        Some reachable expression or throw statement throws assignable exception.
        No earlier catch block covers type C or superclass.  FAILED
==== Contents of test case:

    empty_main T1420catch4 {
        try {
            throw new Exception();
        } catch (Throwable t) {
        } catch (Exception e) {
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-catch-4 FAILED


==== 14.20-catch-8  A catch block C is reachable iff both:
        Some reachable expression or throw statement throws assignable exception.
        No earlier catch block covers type C or superclass.  FAILED
==== Contents of test case:

    empty_main T1420catch8 {
        try {
            throw new Exception();
        } catch (Exception e) {
        } catch (Exception e1) {
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-catch-8 FAILED


==== 14.20-catch-15  The throw is interrupted by the inner finally  FAILED
==== Contents of test case:

    empty_main T1420catch15 {
        try {
            try {
                throw new ClassNotFoundException();
            } finally {
                return; // discards ClassNotFoundException
            }
        } catch (ClassNotFoundException e) {
            // this is unreachable
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-catch-15 FAILED


==== 14.20-catch-17  The throw is interrupted by the inner finally  FAILED
==== Contents of test case:

    empty_main T1420catch17 {
        try {
            try {
                throw new ClassNotFoundException();
            } catch (ClassNotFoundException e) {
                throw e;
            } finally {
                return; // discards ClassNotFoundException
            }
        } catch (ClassNotFoundException e1) {
            // this is unreachable
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-catch-17 FAILED


==== 14.20-catch-19  A catch block C is reachable iff both:
        Some reachable expression or throw statement throws assignable exception.
        No earlier catch block covers type C or superclass.  FAILED
==== Contents of test case:

    empty_class T1420catch19 {
        class MyException extends ClassNotFoundException {}
        void foo() throws Exception {
            ClassNotFoundException c = new MyException();
            try {
                throw c;
            } catch (MyException e) {
                // reachable, as variable reference can contain subclass
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.20-catch-19 FAILED


==== 14.20-catch-20  A catch block C is reachable iff both:
        Some reachable expression or throw statement throws assignable exception.
        No earlier catch block covers type C or superclass.  FAILED
==== Contents of test case:

    empty_main T1420catch20 {
        class MyException extends ArithmeticException {}
        try {
            int i = 0;
            i /= i; // throws only ArithmeticException, not MyException
        } catch (MyException e) {
            // but this is unchecked
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.20-catch-20 FAILED


==== 14.20-catch-21  A catch block C is reachable iff both:
        Some reachable expression or throw statement throws assignable exception.
        No earlier catch block covers type C or superclass.  FAILED
==== Contents of test case:

    empty_main T1420catch21 {
        final Exception e = new ClassNotFoundException();
        try {
            throw e;
        } catch (ClassNotFoundException c) {
            // this one will be called
        } catch (Exception ex) {
            // this one is reachable, but will never be executed,
            // since analysis does not evaluate variable contents
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.20-catch-21 FAILED


==== 14.20-catch-22  A catch block C is reachable iff both:
        Some reachable expression or throw statement throws assignable exception.
        No earlier catch block covers type C or superclass.  FAILED
==== Contents of test case:

    empty_main T1420catch22 {
        class MyException extends ClassNotFoundException {}
        try {
            throw new MyException();
        } catch (MyException m) {
        } catch (ClassNotFoundException e) {
            // this one is reachable, but will never be executed,
            // as the only exception in the try block has already been caught
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 14.20-catch-22 FAILED


==== 14.20-catch-24  A catch block C is reachable iff both:
        Some reachable expression or throw statement throws assignable exception.
        No earlier catch block covers type C or superclass.  FAILED
==== Contents of test case:

    empty_main T1420catch24 {
        try {
            new Object();
        } catch (RuntimeException e) {
        } catch (NullPointerException n) {
            // although this is unchecked, it is a subclass of
            // a prior clause
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-catch-24 FAILED


==== 14.20-if-5  if-then-else can complete normally iff
        then-statement or else-statement can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420if5 {
        if (true)
            return;
        else
            return;
        int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-if-5 FAILED


==== 14.20-if-6  if-then-else can complete normally iff
        then-statement or else-statement can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420if6 {
        if (true)
            return;
        else
            return;
        ;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-if-6 FAILED


==== 14.20-if-7  if-then-else can complete normally iff
        then-statement or else-statement can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420if7 {
        if (true)
            return;
        else
            return;
        {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-if-7 FAILED


==== 14.20-if-8  if-then-else can complete normally iff
        then-statement or else-statement can complete normally.  FAILED
==== Contents of test case:

    empty_main T1420if8 {
        if (true)
            return;
        else
            return;
        { int x=3; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 14.20-if-8 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/class-declaration

==== 8.1-enclosing-4  A class may not have the same simple name as
        an enclosing type  FAILED
==== Contents of test case:

    empty_class T81e4 {
	Object o = new T81e4() {}; // anonymous classes have no simple name
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1-enclosing-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/class-declaration/class-modifiers

==== 8.1.1-valid-modifier-4  strictfp is valid ClassModifier  FAILED
==== Contents of test case:

    compile [saveas T811vm4.java {
strictfp class T811vm4 {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.1-valid-modifier-4 FAILED


==== 8.1.1-duplicate-modifier-1  compile time
        error to specify a class modifier twice  FAILED
==== Contents of test case:

    compile [saveas T811dm1.java {
public public class T811dm1 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1-duplicate-modifier-1 FAILED


==== 8.1.1-duplicate-modifier-2  compile time
        error to specify a class modifier twice  FAILED
==== Contents of test case:

    compile [saveas T811dm2.java {
abstract abstract class T811dm2 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1-duplicate-modifier-2 FAILED


==== 8.1.1-duplicate-modifier-3  compile time
        error to specify a class modifier twice  FAILED
==== Contents of test case:

    compile [saveas T811dm3.java {
final final class T811dm3 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1-duplicate-modifier-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/class-declaration/class-modifiers/abstract-classes

==== 8.1.1.1-4  a non-abstract class can not have an abstract
        method  FAILED
==== Contents of test case:

    empty_class T8111_4 {
	abstract void foo();
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.1-4 FAILED


==== 8.1.1.1-5  An attempt to inherit from an abstract superclass
        containing an abstract method without implementing the abstract method
        or declaring the subclass abstract is a compile time error  FAILED
==== Contents of test case:

    compile [saveas T8111_5a.java {
abstract class T8111_5a {
    abstract void foo();
}
class T8111_5b extends T8111_5a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.1-5 FAILED


==== 8.1.1.1-6  An attempt to inherit from an abstract superclass that
        extends another class that has an abstract method without implementing
        the abstract method or declaring the subclass abstract should generate
        a compile time error  FAILED
==== Contents of test case:

    compile [saveas T8111_6a.java {
abstract class T8111_6a {
    abstract void foo();
}
abstract class T8111_6b extends T8111_6a {}
class T8111_6c extends T8111_6b {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.1-6 FAILED


==== 8.1.1.1-12  A compile time error should be generated when an
        abstract class has two methods with the same signature but different
        return types, this would create an abstract class that could not be
        sub-classed  FAILED
==== Contents of test case:

    compile [saveas T8111_12a.java {
interface T8111_12a {
    void foo();
}
abstract class T8111_12b implements T8111_12a {
    public abstract int foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.1-12 FAILED


==== 8.1.1.1-default-abstract-1  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da1a.java {
package p1;
public abstract class T8111da1a {
  abstract void m();
}
    }] [saveas T8111da1b.java {
class T8111da1b extends p1.T8111da1a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.1-default-abstract-1 FAILED


==== 8.1.1.1-default-abstract-3  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da3a.java {
package p1;
public abstract class T8111da3a {
  abstract void m();
}
    }] [saveas T8111da3b.java {
abstract class T8111da3b extends p1.T8111da3a {}
class T8111da3c extends T8111da3b {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.1-default-abstract-3 FAILED


==== 8.1.1.1-default-abstract-5  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da5a.java {
package p1;
public abstract class T8111da5a {
  abstract void m();
}
    }] [saveas p2/T8111da5b.java {
package p2;
public abstract class T8111da5b extends p1.T8111da5a {}
    }] [saveas p1/T8111da5c.java {
package p1;
public class T8111da5c extends p2.T8111da5b {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.1-default-abstract-5 FAILED


==== 8.1.1.1-default-abstract-7  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da7b.java {
package p1;
abstract class T8111da7a {
  abstract void m();
}
public abstract class T8111da7b extends T8111da7a {}
    }] [saveas T8111da7c.java {
abstract class T8111da7c extends p1.T8111da7b {}
class T8111da7d extends T8111da7c {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.1-default-abstract-7 FAILED


==== 8.1.1.1-default-abstract-14  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da14a.java {
package p1;
public class T8111da14a {
    public abstract class C {
	abstract void m();
    }
    public interface I {
	void m();
    }
}
    }] [saveas T8111da14b.java {
class T8111da14b extends p1.T8111da14a {
    abstract class D extends C implements I {
	// this implements I.m, but not C.m, since that was not accessible
	// therefore, C.m remains unimplemented, and D must be abstract
	public void m() {}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.1.1-default-abstract-14 FAILED


==== 8.1.1.1-default-abstract-16  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da16a.java {
package p1;
public class T8111da16a {
    public abstract class C {
	abstract void m();
    }
    public interface I {
	void m() throws Exception;
    }
}
    }] [saveas T8111da16b.java {
class T8111da16b extends p1.T8111da16a {
    abstract class D extends C implements I {
	// since C.m is not accessible, this only implements I.m, and hence can
	// throw. However, since C.m remains unimplemented, a concrete subclass
	// will have to override D.m and lose the throws clause
	public void m() throws Exception {}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.1.1-default-abstract-16 FAILED


==== 8.1.1.1-default-abstract-18  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da18a.java {
package p1;
public class T8111da18a {
    public abstract class C {
	abstract void m();
    }
    public interface I {
	void m() throws Exception;
    }
}
class T8111da18c extends p2.T8111da18b {
    class E extends D {
	// This overrides and implements C.m (even though B.m was not inherited)
	// so it cannot throw
	public void m() {}
    }
}
    }] [saveas p2/T8111da18b.java {
package p2;
public class T8111da18b extends p1.T8111da18a {
    public abstract class D extends C implements I {
	// since C.m is not accessible, this only implements I.m, and hence can
	// throw. However, since C.m remains unimplemented, a concrete subclass
	// will have to override D.m and lose the throws clause
	public void m() throws Exception {}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.1.1-default-abstract-18 FAILED


==== 8.1.1.1-default-abstract-20  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da20a.java {
package p1;
public class T8111da20a {
    abstract class C {
	abstract void m();
    }
    interface I {
	void m();
    }
    protected abstract class C1 extends C implements I {}
}
    }] [saveas T8111da20b.java {
class T8111da20b extends p1.T8111da20a {
    abstract class D extends C1 {
	// this implements I.m, but not C.m, since that was not accessible
	// therefore, C.m remains unimplemented, and D must be abstract
	public void m() {}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.1.1-default-abstract-20 FAILED


==== 8.1.1.1-default-abstract-22  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da22a.java {
package p1;
public class T8111da22a {
    abstract class C {
	abstract void m();
    }
    interface I {
	void m() throws Exception;
    }
    protected abstract class C1 extends C implements I {}
}
    }] [saveas T8111da22b.java {
class T8111da22b extends p1.T8111da22a {
    abstract class D extends C1 {
	// since C.m is not accessible, this only implements I.m, and hence can
	// throw. However, since C.m remains unimplemented, a concrete subclass
	// will have to override D.m and lose the throws clause
	public void m() throws Exception {}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.1.1-default-abstract-22 FAILED


==== 8.1.1.1-default-abstract-24  Default access abstract methods are
        not inherited across package boundaries, but do affect whether the
        class must be abstract  FAILED
==== Contents of test case:

    compile [saveas p1/T8111da24a.java {
package p1;
public class T8111da24a {
    abstract class C {
	abstract void m();
    }
    interface I {
	void m() throws Exception;
    }
    protected abstract class C1 extends C implements I {}
}
class T8111da24c extends p2.T8111da24b {
    class E extends D {
	// This overrides and implements C.m (even though B.m was not inherited)
	// so it cannot throw
	public void m() {}
    }
}
    }] [saveas p2/T8111da24b.java {
package p2;
public class T8111da24b extends p1.T8111da24a {
    public abstract class D extends C1 {
	// since C.m is not accessible, this only implements I.m, and hence can
	// throw. However, since C.m remains unimplemented, a concrete subclass
	// will have to override D.m and lose the throws clause
	public void m() throws Exception {}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.1.1-default-abstract-24 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/class-declaration/class-modifiers/final-classes

==== 8.1.1.2-conflicting-modifier-1  a final class
        cannot also be declared abstract  FAILED
==== Contents of test case:

    compile [saveas T8112cm1.java {
final abstract class T8112cm1 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.2-conflicting-modifier-1 FAILED


==== 8.1.1.2-invalid-subclass-1  A compile-time
        error occurs if the name of a final class appears
        in the extends clause of another class declaration  FAILED
==== Contents of test case:

    compile [saveas T8112is1.java {
final class T8112is1_super {}
class T8112is1 extends T8112is1_super {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.1.2-invalid-subclass-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/class-declaration/inner-classes-and-enclosing-instances

==== 8.1.2-static-2  Static variables inside inner class must be
        compile-time constant  FAILED
==== Contents of test case:

    empty_class T812s2 {
        class I {
            // good
            private final static int k = 5;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.2-static-2 FAILED


==== 8.1.2-enclosing-12  A nested class in a non-static context may
        access instance fields of the enclosing class  FAILED
==== Contents of test case:

    empty_class T812e12 {
        int i = 1;
        class Inner {
            int j = i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.2-enclosing-12 FAILED


==== 8.1.2-enclosing-13  A nested class in a non-static context may
        access instance fields of the enclosing class  FAILED
==== Contents of test case:

    empty_class T812e13 {
        final int i = 1;
        class Inner {
            int j = i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.2-enclosing-13 FAILED


==== 8.1.2-enclosing-14  A nested class in a non-static context may
        access instance fields of the enclosing class  FAILED
==== Contents of test case:

    empty_class T812e14 {
        int i = 1;
        {
            class Inner {
                int j = i;
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.2-enclosing-14 FAILED


==== 8.1.2-enclosing-15  A nested class in a non-static context may
        access instance fields of the enclosing class  FAILED
==== Contents of test case:

    empty_class T812e15 {
        final int i = 1;
        {
            class Inner {
                int j = i;
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.2-enclosing-15 FAILED


==== 8.1.2-enclosing-16  A nested class in a non-static context may
        access instance fields of the enclosing class  FAILED
==== Contents of test case:

    empty_class T812e16 {
        int i = 1;
        Object o = new Object() {
            class Inner {
                int j = i;
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.2-enclosing-16 FAILED


==== 8.1.2-enclosing-17  A nested class in a non-static context may
        access instance fields of the enclosing class  FAILED
==== Contents of test case:

    empty_class T812e17 {
        final int i = 1;
        Object o = new Object() {
            class Inner {
                int j = i;
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.2-enclosing-17 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/class-declaration/superclasses-and-subclasses

==== 8.1.3-circular-3  Circular dependencies are illegal  FAILED
==== Contents of test case:

    compile [saveas T813c3.java {
class T813c3 extends T813c3 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.3-circular-3 FAILED


==== 8.1.3-circular-4  Circular dependencies are illegal  FAILED
==== Contents of test case:

    compile [saveas T813c4.java {
class T813c4_1 extends T813c4_2 {}
class T813c4_2 extends T813c4_1 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.3-circular-4 FAILED


==== 8.1.3-non-circular-1  In spite of cross-referencing, this
        declaration is not circular, but is legal  FAILED
==== Contents of test case:

    compile [saveas T813nc1.java {
class T813nc1 {
    static class Inner1 extends Two.Inner2 {}
}
class Two extends T813nc1 {
    static class Inner2 {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.3-non-circular-1 FAILED


==== 8.1.3-object-3  Object must not have an extends clause  FAILED
==== Contents of test case:

    set result [compile -classpath T813o3  [saveas T813o3/java/lang/Object.java {
package java.lang;
public class Object {
    public native boolean equals(Object o);
    public native int hashCode();
    public native String toString();
    protected native void finalize() throws Throwable;
    protected native Object clone() throws CloneNotSupportedException;
    public final native Class getClass();
    public final native void notify() throws IllegalMonitorStateException;
    public final native void notifyAll() throws IllegalMonitorStateException;
    public final native void wait()
        throws IllegalMonitorStateException, InterruptedException;
    public final native void wait(long ms)
        throws IllegalMonitorStateException, InterruptedException;
    public final native void wait(long ms, int ns)
        throws IllegalMonitorStateException, InterruptedException;
}
}]]
    saveas T813o3/java/dummy "need this for cleanup of directory we create"
    saveas T813o3/dummy "need this for cleanup of directory we create"
    return $result

==== Test generated return exception;  result was:
FAIL
---- Result should have been:
PASS
==== 8.1.3-object-3 FAILED


==== 8.1.3-superclass-1  A superclass must be accessible  FAILED
==== Contents of test case:

    compile [saveas T813s1.java "class T813s1 extends NoSuchClass {}"]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.3-superclass-1 FAILED


==== 8.1.3-superclass-2  A superclass must be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T813s2a.java {
package p1;
class T813s2a {}
    }] [saveas T813s2b.java {
class T813s2b extends p1.T813s2a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.3-superclass-2 FAILED


==== 8.1.3-superclass-3  A superclass must be a class  FAILED
==== Contents of test case:

    compile [saveas T813s3a.java {
interface T813s3a {}
class T813s3b extends T813s3a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.3-superclass-3 FAILED


==== 8.1.3-superclass-4  A superclass must be non-final  FAILED
==== Contents of test case:

    compile [saveas T813s4a.java {
final class T813s4a {}
class T813s4b extends T813s4a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.3-superclass-4 FAILED


==== 8.1.3-superclass-7  A superclass must be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T813s7a.java {
package p1;
public class T813s7a {
    protected class Inner {}
}
    }] [saveas T813s7b.java {
class T813s7b extends p1.T813s7a {
    class Sub extends Inner {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.3-superclass-7 FAILED


==== 8.1.3-superclass-8  A superclass must be accessible  FAILED
==== Contents of test case:

    empty_class T813s8 {
	private class One {}
	class Two extends One {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.3-superclass-8 FAILED


==== 8.1.3-superclass-9  Test for accessible inner superclass - Jikes
        bug 3202  FAILED
==== Contents of test case:

    compile [saveas T813s9_1.java {
class T813s9_1 {
    class One {}
}
class T813s9_2 extends T813s9_1 {
    class Two extends One {}
}
class T813s9_3 extends T813s9_2 {
    class Three extends Two {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.3-superclass-9 FAILED


==== 8.1.3-superclass-10  A superclass name may be non-canonical  FAILED
==== Contents of test case:

    compile [saveas T813s10a.java {
class T813s10a {
    static class Super {}
}
class T813s10b extends T813s10a {}
class T813s10c extends T813s10b.Super {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.3-superclass-10 FAILED


==== 8.1.3-superclass-11  A superclass name may be non-canonical  FAILED
==== Contents of test case:

    compile [saveas T813s11a.java {
class T813s11a {
    static class Super {}
}
class T813s11b extends T813s11a {
    class C extends Super {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.3-superclass-11 FAILED


==== 8.1.3-superclass-12  A superclass name may be non-canonical  FAILED
==== Contents of test case:

    compile [saveas T813s12a.java {
class T813s12a {
    static class Super {}
}
class T813s12b extends T813s12a {
    class C extends T813s12b.Super {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.3-superclass-12 FAILED


==== 8.1.3-superclass-13  A superclass name may be non-canonical  FAILED
==== Contents of test case:

    compile [saveas T813s13a.java {
class T813s13a {
    static class Super {}
}
class T813s13b extends T813s13a {
    class C extends Super {}
}
class T813s13c extends T813s13b.Super {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.3-superclass-13 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/class-declaration/superinterfaces

==== 8.1.4-superinterface-1  A superinterface must be accessible  FAILED
==== Contents of test case:

    compile [saveas T814s1.java "class T814s1 implements NoSuchType {}"]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.4-superinterface-1 FAILED


==== 8.1.4-superinterface-2  A superinterface must be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T814s2a.java {
package p1;
interface T814s2a {}
}] [saveas T814s2b.java {
class T814s2b implements p1.T814s2a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.4-superinterface-2 FAILED


==== 8.1.4-superinterface-3  A superinterface must be an
        interface  FAILED
==== Contents of test case:

    compile [saveas T814s3a.java {
class T814s3a {}
class T814s3b implements T814s3a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.4-superinterface-3 FAILED


==== 8.1.4-superinterface-6  A superinterface must be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T814s6a.java {
package p1;
public class T814s6a {
    protected interface Inner {}
}
    }] [saveas T814s6b.java {
class T814s6b extends p1.T814s6a {
    class Sub implements Inner {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.4-superinterface-6 FAILED


==== 8.1.4-superinterface-7  A superinterface must be accessible  FAILED
==== Contents of test case:

    empty_class T814s7 {
	private interface One {}
	class Two implements One {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.4-superinterface-7 FAILED


==== 8.1.4-superinterface-8  A superinterface name may be
        non-canonical  FAILED
==== Contents of test case:

    compile [saveas T814s8a.java {
class T814s8a {
    interface Super {}
}
class T814s8b extends T814s8a {}
class T814s8c implements T814s8b.Super {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.4-superinterface-8 FAILED


==== 8.1.4-superinterface-9  A superinterface name may be
        non-canonical  FAILED
==== Contents of test case:

    compile [saveas T814s9a.java {
class T814s9a {
    interface Super {}
}
class T814s9b extends T814s9a {
    class C implements Super {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.4-superinterface-9 FAILED


==== 8.1.4-superinterface-10  A superinterface name may be
        non-canonical  FAILED
==== Contents of test case:

    compile [saveas T814s10a.java {
class T814s10a {
    interface Super {}
}
class T814s10b extends T814s10a {
    class C implements T814s10b.Super {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.4-superinterface-10 FAILED


==== 8.1.4-superinterface-11  A superinterface name may be
        non-canonical  FAILED
==== Contents of test case:

    compile [saveas T814s11a.java {
class T814s11a {
    interface Super {}
}
class T814s11b extends T814s11a {
    class C implements Super {}
}
class T814s11c implements T814s11b.Super {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.4-superinterface-11 FAILED


==== 8.1.4-duplicate-1  A class may not have duplicate
        superinterfaces  FAILED
==== Contents of test case:

    compile [saveas T814d1.java {
class T814d1 implements Cloneable, Cloneable {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.4-duplicate-1 FAILED


==== 8.1.4-duplicate-2  A class may not have duplicate
        superinterfaces  FAILED
==== Contents of test case:

    compile [saveas T814d2.java {
class T814d2 implements java.lang.Cloneable, Cloneable {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.4-duplicate-2 FAILED


==== 8.1.4-abstract-2  A class must implement, or inherit an
        implementation, of all methods of its superinterfaces, or be
        abstract  FAILED
==== Contents of test case:

    compile [saveas T814a2a.java {
interface T814a2a {
    String foo();
}
class T814a2b implements T814a2a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.4-abstract-2 FAILED


==== 8.1.4-conflict-1  Multiple superinterfaces must not conflict  FAILED
==== Contents of test case:

    compile [saveas T814c1.java {
interface Fish {
    int getNumberOfScales();
}
interface StringBass {
    double getNumberOfScales();
}
class T814c1 implements Fish, StringBass {
    public double getNumberOfScales() { return 91; }
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.1.4-conflict-1 FAILED


==== 8.1.4-conflict-2  Multiple superinterfaces must not conflict  FAILED
==== Contents of test case:

    compile [saveas T814c2a.java {
class E1 extends Exception {}
class E2 extends Exception {}
class E3 extends Exception {}
interface T814c2a { void foo() throws E1, E2; }
interface T814c2b { void foo() throws E2, E3; }
class T814c2c implements T814c2a, T814c2b {
    public void foo() throws E2 {}
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.1.4-conflict-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/class-members

==== 8.2-accessibility-inherited-member-1  members
        declared public are accessible in a subclass  FAILED
==== Contents of test case:

    saveas T82aim1.java {
class T82aim1 {
    public int foo;
}

class T82aim1_Test extends T82aim1 {
    void bar() { foo = 0; }
}
    }

    compile T82aim1.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.2-accessibility-inherited-member-1 FAILED


==== 8.2-accessibility-inherited-member-3  members
        declared protected are accessible in a subclass  FAILED
==== Contents of test case:

    saveas T82aim3.java {
class T82aim3 {
    protected int foo;
}

class T82aim3_Test extends T82aim3 {
    void bar() { foo = 0; }
}
    }

    compile T82aim3.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.2-accessibility-inherited-member-3 FAILED


==== 8.2-accessibility-inherited-member-6  members
        declared private are not accessible in a subclass  FAILED
==== Contents of test case:

    saveas T82aim6.java {
class T82aim6 {
    private void foo() {}
}

class T82aim6_Test extends T82aim6 {
    void bar() { foo(); }
}
    }

    compile T82aim6.java

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.2-accessibility-inherited-member-6 FAILED


==== 8.2-accessibility-inherited-member-7  members
        with default protection are accessible in a subclass  FAILED
==== Contents of test case:

    saveas T82aim7.java {
class T82aim7 {
    int foo;
}

class T82aim7_Test extends T82aim7 {
    void bar() { foo = 0; }
}
    }

    compile T82aim7.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.2-accessibility-inherited-member-7 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/constructor-declarations

==== 8.8-simpletypename-2  SimpleTypeName in the
        ConstructorDeclarator must be the simple name of the
        class that contains the constructor declaration  FAILED
==== Contents of test case:

    empty_class T88stn2 "not_ctor() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8-simpletypename-2 FAILED


==== 8.8-example-1  JLS example  FAILED
==== Contents of test case:

    empty_class Point {
        int x, y;
        Point(int x, int y) { this.x = x; this.y = y; }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8-example-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/constructor-declarations/constructor-body

==== 8.8.5-return-statement-2  A return statement may be
        used in the body of a constructor if it does not include
        an expression  FAILED
==== Contents of test case:

    empty_class T885rs2 "T885rs2() { return 1; }"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.5-return-statement-2 FAILED


==== 8.8.5-example-1  JLS example  FAILED
==== Contents of test case:

    saveas Point.java {
class Point {
           int x, y;
           Point(int x, int y) { this.x = x; this.y = y; }
   }
   class ColoredPoint extends Point {
           static final int WHITE = 0, BLACK = 1;
           int color;
           ColoredPoint(int x, int y) {
                   this(x, y, WHITE);
           }
           ColoredPoint(int x, int y, int color) {
                   super(x, y);
                   this.color = color;
           }
   }
}

    compile Point.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5-example-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/constructor-declarations/constructor-body/explicit-constructor-invocations

==== 8.8.5.1-before-block-statements-this-1  An
        ExplicitConstructorInvocation must appear
        before the optional BlockStatements  FAILED
==== Contents of test case:

    empty_class T8851bbst1 {
	T8851bbst1() {}
	T8851bbst1(int i) { this(); {} }
     }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-before-block-statements-this-1 FAILED


==== 8.8.5.1-before-block-statements-super-1  An
        ExplicitConstructorInvocation must appear
        before the optional BlockStatements  FAILED
==== Contents of test case:

    empty_class T8851bbss1 {
	T8851bbss1(int i) { super(); {} }
     }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-before-block-statements-super-1 FAILED


==== 8.8.5.1-accessible-implicit-super-invocation-2 
        An implicit constructor for an inner class can gain
        access to a private constructor in the enclosing class  FAILED
==== Contents of test case:

    empty_class T8851aisi2 { 
	private T8851aisi2() {}
	static class T8851aisi2_Inner extends T8851aisi2 {
	    T8851aisi2_Inner() {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-implicit-super-invocation-2 FAILED


==== 8.8.5.1-accessible-implicit-super-invocation-3 
        An implicit constructor for an inner class can gain
        access to a private constructor in the enclosing class  FAILED
==== Contents of test case:

    empty_class T8851aisi3 { 
	private T8851aisi3() {}
	class T8851aisi3_Inner extends T8851aisi3 {
	    T8851aisi3_Inner() {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-implicit-super-invocation-3 FAILED


==== 8.8.5.1-accessible-explicit-super-invocation-1 
        explicit superclass constructor invocation  FAILED
==== Contents of test case:

    empty_class T8851aesi1 {
	T8851aesi1(int i) { super(); }
     }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-explicit-super-invocation-1 FAILED


==== 8.8.5.1-accessible-explicit-super-invocation-2 
        An explicit constructor for an inner class can gain
        access to a private constructor in the enclosing class  FAILED
==== Contents of test case:

    empty_class T8851aesi2 { 
	private T8851aesi2() {}
	static class T8851aesi2_Inner extends T8851aesi2 {
	    T8851aesi2_Inner() { super(); }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-explicit-super-invocation-2 FAILED


==== 8.8.5.1-accessible-explicit-super-invocation-3 
        An explicit constructor for an inner class can gain
        access to a private constructor in the enclosing class  FAILED
==== Contents of test case:

    empty_class T8851aesi3 { 
	private T8851aesi3() {}
	class T8851aesi3_Inner extends T8851aesi3 {
	    T8851aesi3_Inner() { super(); }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-explicit-super-invocation-3 FAILED


==== 8.8.5.1-accessible-explicit-super-invocation-args-1 
        explicit superclass constructor invocation  FAILED
==== Contents of test case:

    compile [saveas T8851aesia1.java {
class T8851aesia1_super {
    T8851aesia1_super(int i) {}
}
class T8851aesia1 extends T8851aesia1_super {
    T8851aesia1() { super(1); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-explicit-super-invocation-args-1 FAILED


==== 8.8.5.1-accessible-explicit-super-invocation-args-2 
        explicit superclass constructor invocation  FAILED
==== Contents of test case:

    compile [saveas T8851aesia2.java {
class T8851aesia2_super {
    T8851aesia2_super(Object o) {}
}
class T8851aesia2 extends T8851aesia2_super {
    T8851aesia2() { super(null); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-explicit-super-invocation-args-2 FAILED


==== 8.8.5.1-accessible-explicit-super-invocation-args-3 
        a private constructor in an enclosing class is accessible  FAILED
==== Contents of test case:

    compile [saveas T8851aesia3.java {
class T8851aesia3_super {
    private T8851aesia3_super(int i) {}
    static class T8851aesia3 extends T8851aesia3_super {
        T8851aesia3() { super(1); }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-explicit-super-invocation-args-3 FAILED


==== 8.8.5.1-accessible-explicit-super-invocation-args-4 
        a private constructor in an enclosing class is accessible  FAILED
==== Contents of test case:

    compile [saveas T8851aesia4.java {
class T8851aesia4_super {
    private T8851aesia4_super(Object o) {}
    static class T8851aesia4 extends T8851aesia4_super {
        T8851aesia4() { super(null); }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-explicit-super-invocation-args-4 FAILED


==== 8.8.5.1-accessible-explicit-super-invocation-args-5 
        pass lots of types to multiple accessible constructors  FAILED
==== Contents of test case:

    compile [saveas T8851aesia5.java {
class T8851aesia5_super {
    private T8851aesia5_super(Object o) {}
    private T8851aesia5_super(String s) {}
    private T8851aesia5_super(boolean state) {}
    private T8851aesia5_super(int i) {}
    private T8851aesia5_super(long l) {}
    private T8851aesia5_super(float f) {}
    private T8851aesia5_super(double d) {}
    private T8851aesia5_super(String s, char c) {}
    private T8851aesia5_super(double d, short s) {}
    private T8851aesia5_super(byte b, float f) {}
    static class T8851aesia5_o extends T8851aesia5_super {
        T8851aesia5_o() { super( new Object() ); }
    }
    static class T8851aesia5_s extends T8851aesia5_super {
        T8851aesia5_s() { super("hello"); }
    }
    class T8851aesia5_b extends T8851aesia5_super {
        T8851aesia5_b() { super(true); }
    }
    class T8851aesia5_i extends T8851aesia5_super {
        T8851aesia5_i() { super(1); }
    }
    class T8851aesia5_f extends T8851aesia5_super {
        T8851aesia5_f() { super(0.0F); }
    }
    class T8851aesia5_d extends T8851aesia5_super {
        T8851aesia5_d() { super(0.0D); }
    }
    Object l_obj = new T8851aesia5_super(0L) {
        void foo() {}
    };
    Object sb_obj = new T8851aesia5_super("hello", 'b') {
        void foo() {}
    };
    Object bf_obj = new T8851aesia5_super((byte) 2, 1.0F) {
        void foo() {}
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-accessible-explicit-super-invocation-args-5 FAILED


==== 8.8.5.1-inaccessible-implicit-super-invocation-1 
        A private constructor is not accessible in a subclass  FAILED
==== Contents of test case:

    compile [saveas T8851iisi1.java {
class T8851iisi1_super {
    private T8851iisi1_super() {}
}
class T8851iisi1 extends T8851iisi1_super {
    T8851iisi1() {}
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.5.1-inaccessible-implicit-super-invocation-1 FAILED


==== 8.8.5.1-example-1  Example of qualified superconstructor  FAILED
==== Contents of test case:

    empty_class T8851e1 {
	static class Outer {
	    class Inner {}
	}
	static class ChildOfInner extends Outer.Inner {
	    ChildOfInner() {
		(new Outer()).super();
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-example-1 FAILED


==== 8.8.5.1-example-4  Example of legal access of parameter
        when anonymous class is in explicit constructor invocation  FAILED
==== Contents of test case:

    empty_class T8851e4 {
	static class Top {
	    int x;
	    class Dummy {
		Dummy(Object o) {}
	    }
	    class Inside extends Dummy {
		Inside(final int y) {
		    super(new Object() { int r = y; }); // correct
		}
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-example-4 FAILED


==== 8.8.5.1-ambiguous-super-2  The constructor to call must not be
        ambiguous  FAILED
==== Contents of test case:

    compile [saveas T8851as2a.java {
class T8851as2a {
    T8851as2a(String s) {}
    private T8851as2a(Integer i) {}
}
class T8851as2b extends T8851as2a {
    T8851as2b() {
	super(null); // calls T8851as2a(String)
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-ambiguous-super-2 FAILED


==== 8.8.5.1-ambiguous-super-4  The constructor to call must not be
        ambiguous  FAILED
==== Contents of test case:

    empty_class T8851as4 {
	A a = new A();
	static class A {
	    private A() {}
	    // compiler creates A(T8851as4$1 dummy) { this(); }
	    A(String s) {}
	}
	static class B extends A {
	    B() {
		// no ambiguity between real A(String), synthetic A(dummy)
		super(null);
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-ambiguous-super-4 FAILED


==== 8.8.5.1-ambiguous-super-5  The constructor to call must not be
        ambiguous  FAILED
==== Contents of test case:

    compile [saveas T8851as5a.java {
class T8851as5a {
    A a = new A();
    static class A {
	private A() {}
	// compiler creates A(T8851as5a$1 dummy) { this(); }
	A(String s) {}
    }
}
    }]
    delete T8851as5a.java
    compile -classpath . [saveas T8851as5b.java {
class T8851as5b extends T8851as5a.A {
    T8851as5b() {
	// no ambiguity between real A(String), synthetic A(dummy)
	super(null);
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-ambiguous-super-5 FAILED


==== 8.8.5.1-alternate-constructor-invocation-1 
        An alternate constructor invocation invokes a
        constructor of the same class  FAILED
==== Contents of test case:

    empty_class T8851aci1 {
	T8851aci1() { this(0); }
	T8851aci1(int i) {}
     }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-alternate-constructor-invocation-1 FAILED


==== 8.8.5.1-alternate-constructor-invocation-2 
        An alternate constructor invocation can invoke
        a chain of constructors in the same class  FAILED
==== Contents of test case:

    empty_class T8851aci2 {
	T8851aci2() { this(0); }
	T8851aci2(int i) { this("noggy"); }
	T8851aci2(String s) { this(true); }
	T8851aci2(boolean state) { }
     }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-alternate-constructor-invocation-2 FAILED


==== 8.8.5.1-ambiguous-this-3  The constructor to call must not be
        ambiguous  FAILED
==== Contents of test case:

    empty_class T8851at3 {
	A a = new A();
	static class A {
	    private A() {}
	    // compiler creates A(T8851at3$1 dummy) { this(); }
	    A(String s) {}
	    A(int i) {
		// no ambiguity between real A(String), synthetic A(dummy)
		this(null);
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-ambiguous-this-3 FAILED


==== 8.8.5.1-qualified-1  Qualified explicit invocation allows one
        to specify the enclosing instance of the superclass  FAILED
==== Contents of test case:

    compile [saveas T8851q1.java {
class T8851q1 {
    class Inner {}
}
class Sub1 extends T8851q1.Inner {
    Sub1() {
        new T8851q1().super();
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-1 FAILED


==== 8.8.5.1-qualified-2  Qualified explicit invocation allows one
        to specify the enclosing instance of the superclass  FAILED
==== Contents of test case:

    compile [saveas T8851q2.java {
class T8851q2 {
    class Inner {}
}
class Sub2 extends T8851q2.Inner {
    Sub2() {
        new T8851q2(){}.super();
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-2 FAILED


==== 8.8.5.1-qualified-3  Qualified explicit invocation allows one
        to specify the enclosing instance of the superclass  FAILED
==== Contents of test case:

    compile [saveas T8851q3.java {
class T8851q3 {
    class Inner {}
}
class Sub3 extends T8851q3.Inner {
    Sub3() {
        // this will not execute, but must compile
        ((T8851q3) null).super();
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-3 FAILED


==== 8.8.5.1-qualified-4  Qualified explicit invocation allows one
        to specify the enclosing instance of the superclass  FAILED
==== Contents of test case:

    compile [saveas T8851q4.java {
class T8851q4 {
    class Inner {}
}
class Sub4 extends T8851q4.Inner {
    Sub4(T8851q4 t) {
        // using a parameter is legal
        t.super();
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-4 FAILED


==== 8.8.5.1-qualified-10  Qualified explicit constructors are
        allowed even when the enclosing class of the superclass can be
        determined already  FAILED
==== Contents of test case:

    empty_class T8851q10 {
        class One {}
        class Two extends One {
            Two() {
                new T8851q10().super();
            }
            Two(int i) {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-10 FAILED


==== 8.8.5.1-qualified-11  Explicit constructors may reference
        qualified this or super which names an enclosing class  FAILED
==== Contents of test case:

    empty_class T8851q11 {
        class A {}
        class B extends A {
            B() {
                T8851q11.this.super();
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-11 FAILED


==== 8.8.5.1-qualified-12  Explicit constructors may reference
        qualified this or super which names an enclosing class  FAILED
==== Contents of test case:

    empty_class T8851q12 {
        class Super {
            Middle m;
        }
        class Middle extends Super {
            class A {}
            class B extends A {
                B() {
                    Middle.super.m.super();
                }
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-12 FAILED


==== 8.8.5.1-qualified-14  Explicit constructors may reference
        qualified this or super which names an enclosing class  FAILED
==== Contents of test case:

    empty_class T8851q14 {
        T8851q14(Object o) {}
        class Middle extends T8851q14 {
            Middle(int i) {
                super(null);
            }
            Middle() {
                // Here, new Middle is a member of Middle
                super(T8851q14.this.new Middle(1).new Inner() {});
            }
            class Inner {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-14 FAILED


==== 8.8.5.1-qualified-16  Explicit constructors may reference
        qualified this or super which names an enclosing class  FAILED
==== Contents of test case:

    empty_class T8851q16 {
        T8851q16(Object o) {}
        private class Middle extends T8851q16 {
            Middle(int i) {
                super(null);
            }
            Middle() {
                // Here, new Middle is a member of T8851q16, since it was
		// private and not inherited as a member of Middle
                super(T8851q16.this.new Middle(1).new Inner() {});
            }
            class Inner {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-16 FAILED


==== 8.8.5.1-qualified-17  Explicit constructors may reference
        qualified this or super which names an enclosing class  FAILED
==== Contents of test case:

    compile [saveas T8851q17.java {
class T8851q17 {
    T8851q17(Object o) {}
}
class T8851q17a {
    class Middle extends T8851q17 {
	Middle(int i) {
	    super(null);
	}
	Middle() {
	    // Here, the innermost instance of T8851q17a to enclose
	    // new Middle is T8851q17a.this
	    super(new Middle(1).new Inner() {});
	}
	class Inner {}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-17 FAILED


==== 8.8.5.1-qualified-18  Explicit constructors may reference
        qualified this or super which names an enclosing class  FAILED
==== Contents of test case:

    compile [saveas T8851q18.java {
class T8851q18 {
    T8851q18(Object o) {}
}
class T8851q18a {
    class Middle extends T8851q18 {
	Middle(int i) {
	    super(null);
	}
	Middle() {
	    // Here, the innermost instance of T8851q18a to enclose
	    // new Middle is T8851q18a.this
	    super(T8851q18a.this.new Middle(1).new Inner() {});
	}
	class Inner {}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.5.1-qualified-18 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/constructor-declarations/constructor-modifiers

==== 8.8.3-duplicate-modifiers-1  A compile-time
        error occurs if the same modifier appears more than
       once in a constructor declaration  FAILED
==== Contents of test case:

    empty_class T883dm1 "public public T883dm1() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.3-duplicate-modifiers-1 FAILED


==== 8.8.3-duplicate-modifiers-2  A compile-time
        error occurs if the same modifier appears more than
       once in a constructor declaration  FAILED
==== Contents of test case:

    empty_class T883dm2 "protected protected T883dm2() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.3-duplicate-modifiers-2 FAILED


==== 8.8.3-duplicate-modifiers-3  A compile-time
        error occurs if the same modifier appears more than
       once in a constructor declaration  FAILED
==== Contents of test case:

    empty_class T883dm3 "private private T883dm3() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.3-duplicate-modifiers-3 FAILED


==== 8.8.3-multiple-modifiers-1  A compile-time
        error occurs if a constructor declaration has more
        than one of  public, protected, and private  FAILED
==== Contents of test case:

    empty_class T883mm1 "public protected T883mm1() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.3-multiple-modifiers-1 FAILED


==== 8.8.3-multiple-modifiers-2  A compile-time
        error occurs if a constructor declaration has more
        than one of  public, protected, and private  FAILED
==== Contents of test case:

    empty_class T883mm2 "public private T883mm2() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.3-multiple-modifiers-2 FAILED


==== 8.8.3-multiple-modifiers-3  A compile-time
        error occurs if a constructor declaration has more
        than one of  public, protected, and private  FAILED
==== Contents of test case:

    empty_class T883mm3 "protected public T883mm3() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.3-multiple-modifiers-3 FAILED


==== 8.8.3-multiple-modifiers-4  A compile-time
        error occurs if a constructor declaration has more
        than one of  public, protected, and private  FAILED
==== Contents of test case:

    empty_class T883mm4 "protected private T883mm4() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.3-multiple-modifiers-4 FAILED


==== 8.8.3-multiple-modifiers-5  A compile-time
        error occurs if a constructor declaration has more
        than one of  public, protected, and private  FAILED
==== Contents of test case:

    empty_class T883mm5 "private public T883mm5() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.3-multiple-modifiers-5 FAILED


==== 8.8.3-multiple-modifiers-6  A compile-time
        error occurs if a constructor declaration has more
        than one of  public, protected, and private  FAILED
==== Contents of test case:

    empty_class T883mm6 "private protected T883mm6() {}"

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.3-multiple-modifiers-6 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/constructor-declarations/constructor-overloading

==== 8.8.6-overloaded-1  An overloaded constructor
        is resolved at compiler time as described in 15.9.3  FAILED
==== Contents of test case:

    empty_class T886o1 {
T886o1(Object o) {}
T886o1(String s) {}
void foo() {
    Object obj = new T886o1("");
}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.6-overloaded-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/constructor-declarations/constructor-signature

==== 8.8.2-invalid-signature-1  A class may not
        declare two constructors with the same signature,
        or a compile-time error occurs  FAILED
==== Contents of test case:

    empty_class T882is1 {
T882is1(int i) {}
T882is1(int j) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.2-invalid-signature-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/constructor-declarations/default-constructor

==== 8.8.7-default-1  If a class
        contains no constructor declarations,
        then a default constructor that takes
        no parameters is automatically provided  FAILED
==== Contents of test case:

    empty_class T887d1 {
Object o = new T887d1();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-default-1 FAILED


==== 8.8.7-default-2  If a class
        contains no constructor declarations,
        then a default constructor that takes
        no parameters is automatically provided  FAILED
==== Contents of test case:

    saveas T887d2.java {
class T887d2_super {}
class T887d2_subclass extends T887d2_super {}
class T887d2 {
    Object o = new T887d2_subclass();
}
    }

    compile T887d2.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-default-2 FAILED


==== 8.8.7-inaccessible-default-constructor-toplevel-1 
        A private constructor is not accessible in a subclass  FAILED
==== Contents of test case:

    saveas T887idct1.java {
class T887idct1_super {
    private T887idct1_super() {}
}

class T887idct1_subclass extends T887idct1_super {}
    }

    compile T887idct1.java

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.7-inaccessible-default-constructor-toplevel-1 FAILED


==== 8.8.7-inaccessible-default-constructor-toplevel-2 
        A constructor with default accessibility in some other
        package is not accessible in a subclass  FAILED
==== Contents of test case:


    saveas T887idct2_super.java {
package T887idct2_pkg;
public class T887idct2_super {
    T887idct2_super() {}
}
    }

    saveas T887idct2.java {
import T887idct2_pkg.T887idct2_super;
class T887idct2_subclass extends T887idct2_super {}
    }

    compile T887idct2_super.java T887idct2.java

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.8.7-inaccessible-default-constructor-toplevel-2 FAILED


==== 8.8.7-accessible-default-constructor-inner-1 
        A constructor with private accessibility can be accessed
        from a nested class defined in the same class  FAILED
==== Contents of test case:

    empty_class T887adci1 {
        private T887adci1() {}
        static class T887adci1_nested extends T887adci1 {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-1 FAILED


==== 8.8.7-accessible-default-constructor-inner-2 
        A constructor with private accessibility can be accessed
        from an inner class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci2 {
        private T887adci2() {}
        class T887adci2_inner extends T887adci2 {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-2 FAILED


==== 8.8.7-accessible-default-constructor-inner-3 
        A constructor with private accessibility can be accessed
        from an inner anonymous class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci3 {
        private T887adci3() {}
        Object o = new T887adci3() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-3 FAILED


==== 8.8.7-accessible-default-constructor-inner-4 
        A constructor with private accessibility can be accessed
        from a static anonymous class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci4 {
        private T887adci4() {}
        static Object o = new T887adci4() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-4 FAILED


==== 8.8.7-accessible-default-constructor-inner-5 
        A constructor with private accessibility can be accessed
        from an inner local class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci5 {
        private T887adci5() {}
        {
            class T887adci5_inner_local extends T887adci5 {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-5 FAILED


==== 8.8.7-accessible-default-constructor-inner-6 
        A constructor with private accessibility can be accessed
        from a static local class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci6 {
        private T887adci6() {}
        static {
            class T887adci6_static_local extends T887adci6 {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-6 FAILED


==== 8.8.7-accessible-default-constructor-inner-7 
        A constructor with private accessibility can be accessed
        from a nested class defined in the same class  FAILED
==== Contents of test case:

    empty_class T887adci7 {
        static class A {
            private A() {}
        }
        static class B extends A {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-7 FAILED


==== 8.8.7-accessible-default-constructor-inner-8 
        A constructor with private accessibility can be accessed
        from an inner class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci8 {
        static class A {
            private A() {}
        }
        class B extends A {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-8 FAILED


==== 8.8.7-accessible-default-constructor-inner-9 
        A constructor with private accessibility can be accessed
        from an inner anonymous class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci9 {
        static class A {
            private A() {}
        }
        Object o = new A() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-9 FAILED


==== 8.8.7-accessible-default-constructor-inner-10 
        A constructor with private accessibility can be accessed
        from a static anonymous class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci10 {
        static class A {
            private A() {}
        }
        static Object o = new A() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-10 FAILED


==== 8.8.7-accessible-default-constructor-inner-11 
        A constructor with private accessibility can be accessed
        from an inner local class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci11 {
        static class A {
            private A() {}
        }
        {
            class B extends A {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-11 FAILED


==== 8.8.7-accessible-default-constructor-inner-12 
        A constructor with private accessibility can be accessed
        from a static local class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci12 {
        static class A {
            private A() {}
        }
        static {
            class B extends A {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-12 FAILED


==== 8.8.7-accessible-default-constructor-inner-14 
        A constructor with private accessibility can be accessed
        from an inner class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci14 {
        class A {
            private A() {}
        }
        class B extends A {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-14 FAILED


==== 8.8.7-accessible-default-constructor-inner-15 
        A constructor with private accessibility can be accessed
        from an inner anonymous class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci15 {
        class A {
            private A() {}
        }
        Object o = new A() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-15 FAILED


==== 8.8.7-accessible-default-constructor-inner-16 
        A constructor with private accessibility can be accessed
        from a static anonymous class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci16 {
        class A {
            private A() {}
        }
        static Object o = new T887adci16().new A() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-16 FAILED


==== 8.8.7-accessible-default-constructor-inner-17 
        A constructor with private accessibility can be accessed
        from an inner local class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci17 {
        class A {
            private A() {}
        }
        {
            class B extends A {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-17 FAILED


==== 8.8.7-accessible-default-constructor-inner-19 
        A constructor with private accessibility can be accessed
        from an inner class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci19 {
        static {
            class A {
                private A() {}
                class B extends A {}
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-19 FAILED


==== 8.8.7-accessible-default-constructor-inner-20 
        A constructor with private accessibility can be accessed
        from an inner anonymous class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci20 {
        static {
            class A {
                private A() {}
                Object o = new A() {};
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-20 FAILED


==== 8.8.7-accessible-default-constructor-inner-21 
        A constructor with private accessibility can be accessed
        from a static anonymous class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci21 {
        static {
            class A {
                private A() {}
            }
            new A() {};
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-21 FAILED


==== 8.8.7-accessible-default-constructor-inner-22 
        A constructor with private accessibility can be accessed
        from an inner local class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci22 {
        static {
            class A {
                private A() {}
                {
                    class B extends A {}
                }
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-22 FAILED


==== 8.8.7-accessible-default-constructor-inner-23 
        A constructor with private accessibility can be accessed
        from a static local class defined inside the same class.  FAILED
==== Contents of test case:

    empty_class T887adci23 {
        static {
            class A {
                private A() {}
            }
            class B extends A {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-23 FAILED


==== 8.8.7-accessible-default-constructor-inner-24 
        A constructor with private accessibility can be accessed
        from an inner class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci24 {
        {
            class A {
                private A() {}
                class B extends A {}
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-24 FAILED


==== 8.8.7-accessible-default-constructor-inner-25 
        A constructor with private accessibility can be accessed
        from an inner anonymous class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci25 {
        {
            class A {
                private A() {}
            }
            new A() {};
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-25 FAILED


==== 8.8.7-accessible-default-constructor-inner-27 
        A constructor with private accessibility can be accessed
        from an inner local class defined inside the same class  FAILED
==== Contents of test case:

    empty_class T887adci27 {
        {
            class A {
                private A() {}
            }
            class B extends A {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-27 FAILED


==== 8.8.7-accessible-default-constructor-inner-28 
        A constructor with private accessibility can be accessed
        from an inner class of an anonymous class  FAILED
==== Contents of test case:

    empty_class T887adci28 {
        Object o = new Object() {
            class Inner {
                private Inner() {}
            }
        }.new Inner();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-28 FAILED


==== 8.8.7-accessible-default-constructor-inner-29 
        A constructor with private accessibility can be accessed
        from an inner class of an anonymous class  FAILED
==== Contents of test case:

    empty_class T887adci29 {
        Object o = new Object() {
            class Inner {
                private Inner() {}
            }
        }.new Inner(){};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.7-accessible-default-constructor-inner-29 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/constructor-declarations/formal-parameters

==== 8.8.1-formal-parameters-4  See 8.4.1  FAILED
==== Contents of test case:

    empty_class T881fp4 "T881fp4(int i, final Object j) {}"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.1-formal-parameters-4 FAILED


==== 8.8.1-formal-parameters-6  See 8.4.1  FAILED
==== Contents of test case:

    empty_class T881fp6 {T881fp6(final int[] arr) {}}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.8.1-formal-parameters-6 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/field-declarations

==== 8.3-inheritance-7  A class inherits non-private accessible
        fields that it does not hide by redeclaration  FAILED
==== Contents of test case:

    empty_class T83i7 {
	class One {
	    int i;
	}
	class Two extends One {
	    {
		i = this.i;
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3-inheritance-7 FAILED


==== 8.3-inheritance-8  Multiple fields may be inherited with the
        same name, causing no problems if no ambiguous reference is made  FAILED
==== Contents of test case:

    empty_class T83i8 {
	interface I {
	    int i = 1;
	}
	class C {
	    int i;
	}
	class Sub extends C implements I {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3-inheritance-8 FAILED


==== 8.3-inheritance-9  Inheritance along multiple paths is still
        single inheritance  FAILED
==== Contents of test case:

    empty_class T83i9 {
	interface Super {
	    int i = 1;
	}
	interface I1 extends Super {}
	interface I2 extends Super {}
	class C implements I1, I2 {
	    int j = i;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3-inheritance-9 FAILED


==== 8.3-name-1  Duplicate field names are forbidden  FAILED
==== Contents of test case:

    empty_class T83n1 {
	int i, i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3-name-1 FAILED


==== 8.3-name-2  Field names may match method and type names  FAILED
==== Contents of test case:

    empty_class T83n2 {
	int i;
	void i() {}
	class i {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3-name-2 FAILED


==== 8.3-hiding-1  Fields can hide supertype fields regardless of
        accessibility relationships  FAILED
==== Contents of test case:

    empty_class T83h1 {
	class One {
	    public int pub;
	    protected int pro;
	    int pack;
	    private int priv;
	}
	class Two extends One {
	    private int pub;
	    private int pro;
	    private int pack;
	    private int priv;
	}
	class Three extends One {
	    int pub;
	    int pro;
	    int pack;
	    int priv;
	}
	class Four extends One {
	    protected int pub;
	    protected int pro;
	    protected int pack;
	    protected int priv;
	}
	class Five extends One {
	    public int pub;
	    public int pro;
	    public int pack;
	    public int priv;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3-hiding-1 FAILED


==== 8.3-hiding-2  Fields can hide supertype fields regardless of
        type relationships  FAILED
==== Contents of test case:

    empty_class T83h2 {
	class One {
	    int i;
	}
	class Two extends One {
	    Object i;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3-hiding-2 FAILED


==== 8.3-hiding-3  Fields can hide supertype fields regardless of
        instance relationships  FAILED
==== Contents of test case:

    empty_class T83h3 {
	static class One {
	    static int stat;
	    int inst;
	}
	static class Two extends One {
	    int stat;
	    static int inst;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3-hiding-3 FAILED


==== 8.3-hiding-4  Fields can hide supertype fields regardless of
        modifier relationships  FAILED
==== Contents of test case:

    empty_class T83h4 {
	class One {
	    final int fin = 1;
	    transient int trans;
	    volatile int vol;
	    int plain;
	}
	class Two extends One {
	    int fin;
	    int trans;
	    int vol;
	    int plain;
	}
	class Three extends One {
	    final int fin = 1;
	    final int trans = 1;
	    final int vol = 1;
	    final int plain = 1;
	}
	class Four extends One {
	    transient int fin;
	    transient int trans;
	    transient int vol;
	    transient int plain;
	}
	class Five extends One {
	    volatile int fin;
	    volatile int trans;
	    volatile int vol;
	    volatile int plain;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3-hiding-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/field-declarations/field-modifiers

==== 8.3.1-access-1  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T831access1 {
        public public int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-access-1 FAILED


==== 8.3.1-access-2  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T831access2 {
        public protected int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-access-2 FAILED


==== 8.3.1-access-3  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T831access3 {
        public private int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-access-3 FAILED


==== 8.3.1-access-4  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T831access4 {
        protected public int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-access-4 FAILED


==== 8.3.1-access-5  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T831access5 {
        protected protected int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-access-5 FAILED


==== 8.3.1-access-6  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T831access6 {
        protected private int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-access-6 FAILED


==== 8.3.1-access-7  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T831access7 {
        private public int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-access-7 FAILED


==== 8.3.1-access-8  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T831access8 {
        private protected int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-access-8 FAILED


==== 8.3.1-access-9  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T831access9 {
        private private int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-access-9 FAILED


==== 8.3.1-static-8  static static is illegal  FAILED
==== Contents of test case:

    empty_class T831static8 {
        static static int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-static-8 FAILED


==== 8.3.1-final-8  final final is illegal  FAILED
==== Contents of test case:

    empty_class T831final8 {
        final final int i = 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-final-8 FAILED


==== 8.3.1-final-11  final volatile is illegal  FAILED
==== Contents of test case:

    empty_class T831final11 {
        final volatile int i = 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-final-11 FAILED


==== 8.3.1-final-12  volatile final is illegal  FAILED
==== Contents of test case:

    empty_class T831final12 {
        volatile final int i = 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-final-12 FAILED


==== 8.3.1-transient-8  transient transient is illegal  FAILED
==== Contents of test case:

    empty_class T831transient8 {
        transient transient int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-transient-8 FAILED


==== 8.3.1-volatile-8  volatile volatile is illegal  FAILED
==== Contents of test case:

    empty_class T831volatile8 {
        volatile volatile int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1-volatile-8 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/field-declarations/field-modifiers/final-fields

==== 8.3.1.2-final-2  blank final class variables must be assigned
        in an initializer  FAILED
==== Contents of test case:

    empty_class T8312f2 {
	static final int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1.2-final-2 FAILED


==== 8.3.1.2-final-5  blank final class variables must be assigned
        in an initializer  FAILED
==== Contents of test case:

    empty_class T8312f5 {
	static final int i;
	static {
	    i = 1;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.1.2-final-5 FAILED


==== 8.3.1.2-final-7  blank final instance variables must be assigned
        by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f7 {
	final int i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1.2-final-7 FAILED


==== 8.3.1.2-final-9  blank final instance variables must be assigned
        by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f9 {
	final int i;
	T8312f9() {
	    if (false)
                i = 1;
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1.2-final-9 FAILED


==== 8.3.1.2-final-11  blank final instance variables must be
        assigned by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f11 {
	final int i;
	T8312f11(int j){
	}
	T8312f11() {
	    i = 1;
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1.2-final-11 FAILED


==== 8.3.1.2-final-14  blank final instance variables must be
        assigned by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f14 {
	final int i;
	{ i = 1; }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.1.2-final-14 FAILED


==== 8.3.1.2-final-16  blank final instance variables must be
        assigned by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f16 {
	final int i;
	T8312f16(int j) {
	    this();
	}
	T8312f16() {
	    i = 1;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.1.2-final-16 FAILED


==== 8.3.1.2-final-17  blank final instance variables must be
        assigned by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f17 {
	final int i;
	T8312f17() {
	    if (true)
	        return;
	    i = 1;
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1.2-final-17 FAILED


==== 8.3.1.2-final-19  blank final instance variables must be
        assigned by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f19 {
	final int i;
	T8312f19(boolean b) {
	    if (b)
	        return;
	    i = 1;
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1.2-final-19 FAILED


==== 8.3.1.2-final-21  blank final instance variables must be
        assigned by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f21 {
	final int i;
	T8312f21(boolean b) {
	    try {
		if (b)
		    return;
	    } finally {
	    }
	    i = 1;
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1.2-final-21 FAILED


==== 8.3.1.2-final-23  blank final instance variables must be
        assigned by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f23 {
	final int i;
	T8312f23(boolean b) {
	    while (b || true);
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.1.2-final-23 FAILED


==== 8.3.1.2-final-24  blank final instance variables must be
        assigned by the end of every constructor  FAILED
==== Contents of test case:

    empty_class T8312f24 {
	final int i;
	T8312f24() {
	    return;
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.1.2-final-24 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/field-declarations/field-modifiers/static-fields

==== 8.3.1.1-other-1  access an initialized final
        static field in another class that has not yet been compiled  FAILED
==== Contents of test case:

    saveas T8311o1_1.java {
class T8311o1_1
{
    int i = T8311o1_2.i;
}
    }

    saveas T8311o1_2.java {
class T8311o1_2
{
    final static int i = 0;
}
    }

    compile T8311o1_1.java T8311o1_2.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.1.1-other-1 FAILED


==== 8.3.1.1-other-2  access an uninitialized final
        static field in another class that has not yet been compiled  FAILED
==== Contents of test case:

    saveas T8311o2_1.java {
class T8311o2_1
{
    int i = T8311o2_2.i;
}
    }

    saveas T8311o2_2.java {
class T8311o2_2
{
    final static int i;
    static { i = 0; }
}
    }

    compile T8311o2_1.java T8311o2_2.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.1.1-other-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/field-declarations/initialization-of-fields

==== 8.3.2-abrupt-3  An instance variable initializer may not
        complete abruptly with a checked exception, unless all constructors
        have a compatible throws clause  FAILED
==== Contents of test case:

    empty_class T832a3 {
        int m() throws ClassNotFoundException { return 1; }
        int i = m();
        T832a3() throws ClassNotFoundException {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2-abrupt-3 FAILED


==== 8.3.2-abrupt-5  An instance variable initializer may not
        complete abruptly with a checked exception, unless all constructors
        have a compatible throws clause  FAILED
==== Contents of test case:

    empty_class T832a5 {
        int m() throws ClassNotFoundException { return 1; }
        int i = m();
        T832a5() throws Throwable {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2-abrupt-5 FAILED


==== 8.3.2-abrupt-6  An instance variable initializer may not
        complete abruptly with a checked exception, unless all constructors
        have a compatible throws clause; the generated constructor in an
        anonymous class always has the right throws clause  FAILED
==== Contents of test case:

    empty_main T832a6 {
        try {
            new Object() {
                int m() throws ClassNotFoundException { return 1; }
                int i = m();
            };
        } catch (ClassNotFoundException e) {
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2-abrupt-6 FAILED


==== 8.3.2-abrupt-7  An instance variable initializer may not
        complete abruptly with a checked exception, unless all constructors
        have a compatible throws clause; the generated constructor in an
        anonymous class always has the right throws clause  FAILED
==== Contents of test case:

    empty_class T832a7 {
        void foo() throws ClassNotFoundException {
            new Object() {
                int m() throws ClassNotFoundException { return 1; }
                int i = m();
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2-abrupt-7 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/field-declarations/initialization-of-fields/initializers-for-class-variables
leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/field-declarations/initialization-of-fields/initializers-for-instance-variables

==== 8.3.2.2-static-1  Instance field initializers may use static
        members, regardless of their declaration order  FAILED
==== Contents of test case:

    empty_class T8322st1 {
        float f = j;
        static int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.2-static-1 FAILED


==== 8.3.2.2-this-1  Instance field initializers may refer to this,
        even implicitly  FAILED
==== Contents of test case:

    empty_class T8322t1 {
        String s = toString();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.2-this-1 FAILED


==== 8.3.2.2-this-2  Instance field initializers may refer to this,
        even implicitly  FAILED
==== Contents of test case:

    empty_class T8322t2 {
        String s = this.toString();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.2-this-2 FAILED


==== 8.3.2.2-this-3  Instance field initializers may refer to this,
        even implicitly  FAILED
==== Contents of test case:

    empty_class T8322t3 {
        String s = T8322t3.this.toString();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.2-this-3 FAILED


==== 8.3.2.2-super-1  Instance field initializers may refer to
        super  FAILED
==== Contents of test case:

    empty_class T8322s1 {
        String s = super.toString();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.2-super-1 FAILED


==== 8.3.2.2-super-2  Instance field initializers may refer to
        super  FAILED
==== Contents of test case:

    empty_class T8322s2 {
        String s = T8322s2.super.toString();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.2-super-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/field-declarations/initialization-of-fields/restrictions

==== 8.3.2.3-illegal-forward-instance-7  Reading a variable is not
        legal before declaration, even if it was assigned before declaration  FAILED
==== Contents of test case:

    empty_class T8323ifi7 {
        int i = (i = 1) + i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.2.3-illegal-forward-instance-7 FAILED


==== 8.3.2.3-legal-forward-instance-1  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi1 {
        int i = this.j; // not simple usage
        int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-1 FAILED


==== 8.3.2.3-legal-forward-instance-2  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi2 {
        void foo() { int i = j; } // not in initializer
        int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-2 FAILED


==== 8.3.2.3-legal-forward-instance-3  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi3 {
        T8323lfi3() { int i = j; } // not in initializer
        int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-3 FAILED


==== 8.3.2.3-legal-forward-instance-4  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi4 {
        int i = j = 2; // simple assignment
        int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-4 FAILED


==== 8.3.2.3-legal-forward-instance-5  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi5 {
        { j = 2; } // simple assignment
        int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-5 FAILED


==== 8.3.2.3-legal-forward-instance-6  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi6 {
        int i = new Object(){ int bar() { return j; } }.bar();
        // not in declaring class
        int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-6 FAILED


==== 8.3.2.3-legal-forward-instance-7  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi7 {
        { new Object(){ { j++; } }; } // not in declaring class
        int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-7 FAILED


==== 8.3.2.3-legal-forward-instance-8  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi8 {
        int i = j; // j is static
        static int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-8 FAILED


==== 8.3.2.3-legal-forward-instance-9  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi9 {
        { j++; } // j is static
        static int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-9 FAILED


==== 8.3.2.3-legal-forward-instance-10  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi10 {
        final int i = j; // j is static
        static final int j = 1;
        void foo(int n) {
            switch (n) {
                case 0:
                case i: // i == 1
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-10 FAILED


==== 8.3.2.3-legal-forward-instance-11  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfi11 {
        final int i = this.j; // not simple usage
        final int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-11 FAILED


==== 8.3.2.3-legal-forward-instance-12  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T83231fi12 {
        int j = i = 1;
        final int i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-instance-12 FAILED


==== 8.3.2.3-illegal-forward-static-7  Reading a variable is not
        legal before declaration, even if it was assigned before declaration  FAILED
==== Contents of test case:

    empty_class T8323ifs7 {
        static int i = (i = 1) + i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.3.2.3-illegal-forward-static-7 FAILED


==== 8.3.2.3-legal-forward-static-1  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfs1 {
        static int i = T8323lfs1.j; // not simple usage
        static int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-1 FAILED


==== 8.3.2.3-legal-forward-static-2  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfs2 {
        static void foo() { int i = j; } // not in initializer
        static int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-2 FAILED


==== 8.3.2.3-legal-forward-static-3  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfs3 {
        T8323lfs3() { int i = j; } // not in initializer
        int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-3 FAILED


==== 8.3.2.3-legal-forward-static-4  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfs4 {
        static int i = j = 2; // simple assignment
        static int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-4 FAILED


==== 8.3.2.3-legal-forward-static-5  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfs5 {
        static { j = 2; } // simple assignment
        static int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-5 FAILED


==== 8.3.2.3-legal-forward-static-6  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfs6 {
        static int i = new Object(){ int bar() { return j; } }.bar();
        // not in declaring class
        static int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-6 FAILED


==== 8.3.2.3-legal-forward-static-7  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfs7 {
        static { new Object(){ { j++; } }; } // not in declaring class
        static int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-7 FAILED


==== 8.3.2.3-legal-forward-static-8  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfs8 {
        static final int i = T8323lfs8.j; // not simple usage
        static final int j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-8 FAILED


==== 8.3.2.3-legal-forward-static-9  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T83231fs9 {
	static int j = i = 1;
	static final int i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-9 FAILED


==== 8.3.2.3-legal-forward-static-10  Simple usage before
        declaration legal if 1. not in initializer; 2. simple assignment;
        or 3. not in declaring class  FAILED
==== Contents of test case:

    empty_class T8323lfs10 {
	static final int j = T8323lfs10.k;
	static final int k = new Q().i;
	private static class Q {
	    static int i = 1;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.3.2.3-legal-forward-static-10 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/instance-initializers

==== 8.6-checked-exception-2  Instance initializers of non-anonymous
        classes may throw checked exceptions only if all constructors
        have compatible throws clauses  FAILED
==== Contents of test case:

    empty_class T86ce2 {
        { if (true) throw new ClassNotFoundException(); }
        T86ce2() throws ClassNotFoundException {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-checked-exception-2 FAILED


==== 8.6-checked-exception-4  Instance initializers of non-anonymous
        classes may throw checked exceptions only if all constructors
        have compatible throws clauses  FAILED
==== Contents of test case:

    empty_class T86ce4 {
        { if (true) throw new ClassNotFoundException(); }
        T86ce4() throws Throwable {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-checked-exception-4 FAILED


==== 8.6-checked-exception-5  Instance initializers of anonymous
        classes may throw any exception, and the generated constructor must
        automatically throw such exceptions  FAILED
==== Contents of test case:

    empty_main T86ce5 {
        try {
            new Object() {
                { if (true) throw new ClassNotFoundException(); }
            };
        } catch (ClassNotFoundException e) {
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-checked-exception-5 FAILED


==== 8.6-checked-exception-6  Instance initializers of anonymous
        classes may throw any exception, and the generated constructor must
        automatically throw such exceptions  FAILED
==== Contents of test case:

    empty_class T86ce6 {
        void foo() throws ClassNotFoundException {
            new Object() {
                { if (true) throw new ClassNotFoundException(); }
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-checked-exception-6 FAILED


==== 8.6-checked-exception-8  Instance initializers of non-anonymous
        classes may throw checked exceptions only if all constructors
        have compatible throws clauses  FAILED
==== Contents of test case:

    empty_class T86ce8 {
        int m() throws ClassNotFoundException { return 1; }
        { m(); }
        T86ce8() throws ClassNotFoundException {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-checked-exception-8 FAILED


==== 8.6-checked-exception-10  Instance initializers of non-anonymous
        classes may throw checked exceptions only if all constructors
        have compatible throws clauses  FAILED
==== Contents of test case:

    empty_class T86ce10 {
        int m() throws ClassNotFoundException { return 1; }
        { m(); }
        T86ce10() throws Throwable {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-checked-exception-10 FAILED


==== 8.6-checked-exception-11  Instance initializers of anonymous
        classes may throw any exception, and the generated constructor must
        automatically throw such exceptions  FAILED
==== Contents of test case:

    empty_main T86ce11 {
        try {
            new Object() {
                int m() throws ClassNotFoundException { return 1; }
                { m(); }
            };
        } catch (ClassNotFoundException e) {
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-checked-exception-11 FAILED


==== 8.6-checked-exception-12  Instance initializers of anonymous
        classes may throw any exception, and the generated constructor must
        automatically throw such exceptions  FAILED
==== Contents of test case:

    empty_class T86ce12 {
        void foo() throws ClassNotFoundException {
            new Object() {
                int m() throws ClassNotFoundException { return 1; }
                { m(); }
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-checked-exception-12 FAILED


==== 8.6-complete-3  Instance initializers must be able to complete
        normally, by 14.20, if(true) always completes normally  FAILED
==== Contents of test case:

    empty_class T86c3 {
        { if (true) throw new RuntimeException(); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-complete-3 FAILED


==== 8.6-complete-4  Instance initializers must be able to complete
        normally  FAILED
==== Contents of test case:

    empty_class T86c4 {
        int m() throws ClassNotFoundException { return 1; }
        { m(); }
        T86c4() throws ClassNotFoundException {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-complete-4 FAILED


==== 8.6-complete-6  Instance initializers must be able to complete
        normally, by 14.20, if(true) always completes normally  FAILED
==== Contents of test case:

    empty_class T86c6 {
        { if (true) while (true); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-complete-6 FAILED


==== 8.6-this-1  Instance initializers may access this  FAILED
==== Contents of test case:

    empty_class T86t1 {
        { this.toString(); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-this-1 FAILED


==== 8.6-super-1  Instance initializers may access super  FAILED
==== Contents of test case:

    empty_class T86s1 {
        { super.toString(); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.6-super-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/member-type-declarations

==== 8.5-inheritance-4  A class inherits non-private accessible
        types that it does not hide by redeclaration  FAILED
==== Contents of test case:

    empty_class T85i4 {
	class One {
	    class C {}
	}
	class Two extends One {
	    C c = new Two.C();
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5-inheritance-4 FAILED


==== 8.5-inheritance-5  Multiple types may be inherited with the
        same name, causing no problems if no ambiguous reference is made  FAILED
==== Contents of test case:

    empty_class T85i5 {
	interface I {
	    class Dup {}
	}
	class C {
	    class Dup {}
	}
	class Sub extends C implements I {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5-inheritance-5 FAILED


==== 8.5-inheritance-6  Inheritance along multiple paths is still
        single inheritance  FAILED
==== Contents of test case:

    empty_class T85i6 {
	interface Super {
	    class C {}
	}
	interface I1 extends Super {}
	interface I2 extends Super {}
	class Sub implements I1, I2 {
	    C c = new Sub.C();
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5-inheritance-6 FAILED


==== 8.5-hiding-1  Types can hide supertype types regardless of
        accessibility relationships  FAILED
==== Contents of test case:

    empty_class T85h1 {
	class One {
	    public class Pub {}
	    protected class Pro {}
	    class Pack {}
	    private class Priv {}
	}
	class Two extends One {
	    private class Pub {}
	    private class Pro {}
	    private class Pack {}
	    private class Priv {}
	}
	class Three extends One {
	    class Pub {}
	    class Pro {}
	    class Pack {}
	    class Priv {}
	}
	class Four extends One {
	    protected class Pub {}
	    protected class Pro {}
	    protected class Pack {}
	    protected class Priv {}
	}
	class Five extends One {
	    public class Pub {}
	    public class Pro {}
	    public class Pack {}
	    public class Priv {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5-hiding-1 FAILED


==== 8.5-hiding-2  Types can hide supertype types regardless of
        type relationships  FAILED
==== Contents of test case:

    empty_class T85h2 {
	static class One {
	    class C {}
	    interface I {}
	}
	static class Two extends One {
	    interface C {}
	    class I {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5-hiding-2 FAILED


==== 8.5-hiding-3  Types can hide supertype types regardless of
        instance relationships  FAILED
==== Contents of test case:

    empty_class T85h3 {
	static class One {
	    static class Stat {}
	    class Inst {}
	}
	static class Two extends One {
	    class Stat {}
	    static class Inst {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5-hiding-3 FAILED


==== 8.5-hiding-4  Types can hide supertype types regardless of
        modifier relationships  FAILED
==== Contents of test case:

    empty_class T85h4 {
	class One {
	    abstract class Abs {}
	    final class Fin {}
	    strictfp class Strict {}
	}
	class Two extends One {
	    final class Abs {}
	    strictfp class Fin {}
	    abstract class Strict {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5-hiding-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/member-type-declarations/access-modifiers

==== 8.5.1-valid-modifier-1  public is a
        valid ClassModifier for a member class  FAILED
==== Contents of test case:

    empty_class T851vm1 {
    public class Inner {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.1-valid-modifier-1 FAILED


==== 8.5.1-valid-modifier-2  protected
        is a valid ClassModifier for a member class  FAILED
==== Contents of test case:

    empty_class T851vm2 {
    protected class Inner {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.1-valid-modifier-2 FAILED


==== 8.5.1-valid-modifier-3  private
        is a valid ClassModifier for a member class  FAILED
==== Contents of test case:

    empty_class T851vm3 {
    protected class Inner {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.1-valid-modifier-3 FAILED


==== 8.5.1-valid-modifier-4  static
        is a valid ClassModifier for a member class  FAILED
==== Contents of test case:

    empty_class T851vm4 {
    static class Member {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.1-valid-modifier-4 FAILED


==== 8.5.1-valid-modifier-5  strictfp
        is a valid ClassModifier for a member class  FAILED
==== Contents of test case:

    empty_class T851vm5 {
    strictfp class Member {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.1-valid-modifier-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/member-type-declarations/static-member-type-declarations

==== 8.5.2-static-member-usage-1  a member type
        with the static modifier may use static members
        of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852smu1 {
        static int foo;
        static class T852smu1_Test {
            T852smu1_Test() { foo = 0; }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-static-member-usage-1 FAILED


==== 8.5.2-static-member-usage-2  a member type
        with the static modifier may use static members
        of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852smu2 {
        static void foo() {}
        static class T852smu2_Test {
            T852smu2_Test() { foo(); }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-static-member-usage-2 FAILED


==== 8.5.2-static-member-usage-3  a member type
        with the static modifier may use static members
        of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852smu3 {
        static final int foo = 1;
        static class T852smu1_Test {
            void m(int i) {
                switch (i) {
                    case foo:
                }
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-static-member-usage-3 FAILED


==== 8.5.2-static-member-usage-4  a member type
        with the static modifier may use static members
        of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852smu4 {
        static class C {}
        static class T852smu4_Test {
            C c;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-static-member-usage-4 FAILED


==== 8.5.2-static-member-usage-5  a member type
        with the static modifier may use static members
        of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852smu5 {
        interface I {}
        static class T852smu5Test {
            I i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-static-member-usage-5 FAILED


==== 8.5.2-non-static-member-usage-6  It is a compile-time error if
        a static class contains a usage of a non-static member of the
        enclosing class; usage implies unqualified names  FAILED
==== Contents of test case:

    empty_class T852nsmu6 {
        int i;
        static class T852nsmu6_Test {
            void m(T852nsmu6 t) {
                t.i = 1; // i is qualified, doesn't count as usage
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-non-static-member-usage-6 FAILED


==== 8.5.2-non-static-member-usage-7  It is a compile-time error if
        a static class contains a usage of a non-static member of the
        enclosing class; usage implies unqualified names  FAILED
==== Contents of test case:

    empty_class T852nsmu7 {
        void foo() {}
        static class T852nsmu7_Test {
            void bar(T852nsmu7 t) {
                t.foo(); // foo is qualified, doesn't count as usage
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-non-static-member-usage-7 FAILED


==== 8.5.2-non-static-member-usage-8  It is a compile-time error if
        a static class contains a usage of a non-static member of the
        enclosing class; usage implies unqualified names  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T852nsmu8 {
        final int i = 1;
        static class T852nsmu8_Test {
            void m(T852nsmu8 t) {
                int j = t.i; // i is qualified, doesn't count as usage
            }
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.5.2-non-static-member-usage-8 FAILED


==== 8.5.2-non-static-member-usage-9  It is a compile-time error if
        a static class contains a usage of a non-static member of the
        enclosing class; usage implies unqualified names  FAILED
==== Contents of test case:

    empty_class T852nsmu9 {
        class C {}
        static class T852nsmu9_Test {
            T852nsmu9.C c; // C is qualified, doesn't count as usage
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-non-static-member-usage-9 FAILED


==== 8.5.2-non-static-member-usage-10  It is a compile-time error if
        a static class contains a usage of a non-static member of the
        enclosing class; usage implies unqualified names  FAILED
==== Contents of test case:

    empty_class T852nsmu10 {
        class C {}
        static class T852nsmu10_Test {
            {
                // C is qualified, doesn't count as usage
                new T852nsmu10().new C();
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-non-static-member-usage-10 FAILED


==== 8.5.2-accessible-static-member-usage-1 
        a member type with the static modifer may access
        private static members of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852asmu1 {
        private static int foo;
        static class T852asmu1_Test {
            T852asmu1_Test() { foo = 0; }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-accessible-static-member-usage-1 FAILED


==== 8.5.2-accessible-static-member-usage-2 
        a member type with the static modifer may access
        private static members of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852asmu2 {
        private static void foo() {}
        static class T852asmu2_Test {
            T852asmu2_Test() { foo(); }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-accessible-static-member-usage-2 FAILED


==== 8.5.2-accessible-static-member-usage-3 
        a member type with the static modifer may access
        private static members of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852asmu3 {
        private static final int foo = 1;
        static class T852asmu1_Test {
            void m(int i) {
                switch (i) {
                    case foo:
                }
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-accessible-static-member-usage-3 FAILED


==== 8.5.2-accessible-static-member-usage-4 
        a member type with the static modifer may access
        private static members of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852asmu4 {
        private static class C {}
        static class T852asmu4_Test {
            C c;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-accessible-static-member-usage-4 FAILED


==== 8.5.2-accessible-static-member-usage-5 
        a member type with the static modifer may access
        private static members of the enclosing class  FAILED
==== Contents of test case:

    empty_class T852asmu5 {
        private interface I {}
        static class T852asmu5Test {
            I i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-accessible-static-member-usage-5 FAILED


==== 8.5.2-inherited-non-static-member-usage-1 
        a static member type may use non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    empty_class T852insmu1 {
        int foo;
        static class T852insmu1_Test extends T852insmu1 {
            T852insmu1_Test() { foo = 0; }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-inherited-non-static-member-usage-1 FAILED


==== 8.5.2-inherited-non-static-member-usage-2 
        a static member type may use non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    empty_class T852insmu2 {
        void foo() {}
        static class T852insmu2_Test extends T852insmu2 {
            T852insmu2_Test() { foo(); }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-inherited-non-static-member-usage-2 FAILED


==== 8.5.2-inherited-non-static-member-usage-3 
        a static member type may use non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T852insmu3 {
        final int foo = 1;
        static class T852insmu3_Test extends T852insmu3 {
            void m(int i) {
                switch (i) {
                    case foo:
                }
            }
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.5.2-inherited-non-static-member-usage-3 FAILED


==== 8.5.2-inherited-non-static-member-usage-4 
        a static member type may use non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    empty_class T852insmu4 {
        class C {}
        static class T852insmu4_Test extends T852insmu4 {
            C c;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-inherited-non-static-member-usage-4 FAILED


==== 8.5.2-inherited-non-static-member-usage-5 
        a static member type may use non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    empty_class T852insmu5 {
        class C {}
        static class T852insmu5_Test extends T852insmu5 {
            {
                new C();
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-inherited-non-static-member-usage-5 FAILED


==== 8.5.2-accessible-inherited-non-static-member-usage-1 
        a static member type may use private non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    empty_class T852ainsmu1 {
        private int foo;
        static class T852ainsmu1_Test extends T852ainsmu1 {
            T852ainsmu1_Test() { super.foo = 0; }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-accessible-inherited-non-static-member-usage-1 FAILED


==== 8.5.2-accessible-inherited-non-static-member-usage-2 
        a static member type may use private non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    empty_class T852ainsmu2 {
        private void foo() {}
        static class T852ainsmu2_Test extends T852ainsmu2 {
            T852ainsmu2_Test() { super.foo(); }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-accessible-inherited-non-static-member-usage-2 FAILED


==== 8.5.2-accessible-inherited-non-static-member-usage-3 
        a static member type may use private non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T852ainsmu3 {
        private final int foo = 1;
        static class T852ainsmu3_Test extends T852ainsmu3 {
            int bar = super.foo;
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.5.2-accessible-inherited-non-static-member-usage-3 FAILED


==== 8.5.2-accessible-inherited-non-static-member-usage-4 
        a static member type may use private non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    empty_class T852ainsmu4 {
        private class C {}
        static class T852ainsmu4_Test extends T852ainsmu4 {
            C c;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-accessible-inherited-non-static-member-usage-4 FAILED


==== 8.5.2-accessible-inherited-non-static-member-usage-5 
        a static member type may use private non-static members of
        a superclass that happens to be the enclosing class  FAILED
==== Contents of test case:

    empty_class T852ainsmu5 {
        private class C {}
        static class T852ainsmu5_Test extends T852ainsmu5 {
            {
                new C();
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.5.2-accessible-inherited-non-static-member-usage-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/method-declarations/inheritance-overriding-and-hiding

==== 8.4.6-miranda-1  Abstract classes no longer need Miranda
        methods (generated place-holders in classes which inherit an abstract
        method from an interface without overriding it)  FAILED
==== Contents of test case:

    compile [saveas T846m1a.java {
interface T846m1a { void m(); }
}] [saveas T846m1b.java {
// If a compiler still inserts Miranda methods, then class b will have a
// bogus declaration "abstract void m();"
abstract class T846m1b implements T846m1a {}
}]
# Now, leave b in .class form only, and recompile a to lose m()
    delete T846m1b.java
    compile [saveas T846m1a.java {
interface T846m1a {}
}]
# The real test: if c inherits b.m(), the compiler goofed in compiling b
    compile -classpath . [saveas T846m1c.java {
abstract class T846m1c extends T846m1b {
    void foo() { m(); }
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6-miranda-1 FAILED


==== 8.4.6-miranda-3  Abstract classes no longer need Miranda
        methods (generated place-holders in classes which inherit an abstract
        method from an interface without overriding it)  FAILED
==== Contents of test case:

    compile [saveas T846m3b.java {
interface T846m3a { void m(); }
abstract class T846m3b implements T846m3a {}
    }]
# Now, leave b in .class form only. If c avoids implementing m(), the compiler
# goofed by looking for Miranda methods in b instead of inheriting from a
    compile -classpath . [saveas T846m3c.java {
class T846m3c extends T846m3b {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6-miranda-3 FAILED


==== 8.4.6-miranda-4  Abstract classes no longer need Miranda
        methods (generated place-holders in classes which inherit an abstract
        method from an interface without overriding it)  FAILED
==== Contents of test case:

    compile [saveas T846m4b.java {
interface T846m4a { void m(); }
abstract class T846m4b implements T846m4a {}
    }]
# Now, leave b in .class form only. If c changes accessibility, the compiler
# goofed by looking for Miranda methods in b instead of inheriting from a
    compile -classpath . [saveas T846m4c.java {
abstract class T846m4c extends T846m4b {
    abstract void m();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6-miranda-4 FAILED


==== 8.4.6-inheritance-6  A class inherits non-private accessible
        methods that it does not hide by redeclaration  FAILED
==== Contents of test case:

    empty_class T846i6 {
	class One {
	    int m() { return 1; }
	}
	class Two extends One {
	    {
		m();
		this.m();
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6-inheritance-6 FAILED


==== 8.4.3.3-final-1  It is an error to attempt to override
	a final method  FAILED
==== Contents of test case:

    compile [saveas T8433final1.java {
class T8433final1a { final int x() { return 5; } }
class T8433final1b extends T8433final1a {
  int x () { return 7; }
}
    }]
---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3.3-final-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/method-declarations/inheritance-overriding-and-hiding/hiding

==== 8.4.6.2-hiding-2  overloading does not affect hiding  FAILED
==== Contents of test case:

    empty_class T8462h2 {
	static class One {
	    void m() {}
	}
	static class Two extends One {
	    static int m(int i) throws Exception { return 1; }
	}
	static class Three extends Two {
	    {
		m();
		this.m();
		try {
		    m(1);
		    this.m(1);
		} catch (Exception e) {
		}
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.2-hiding-2 FAILED


==== 8.4.6.2-hiding-4  static methods cannot hide what is not
        accessible in superclass  FAILED
==== Contents of test case:

    compile [saveas p1/T8462h4a.java {
package p1;
public class T8462h4a {
    void m() {}
}
class T8462h4c extends p2.T8462h4b {
    // if this were not static, it would override a.m. Therefore, there is
    // a conflict, and this static method is hiding an instance method, even
    // though a.m is not inherited
    static void m() {}
}
    }] [saveas p2/T8462h4b.java {
package p2;
public class T8462h4b extends p1.T8462h4a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.2-hiding-4 FAILED


==== 8.4.6.2-hiding-6  static methods cannot hide what is not
        accessible in superclass  FAILED
==== Contents of test case:

    compile [saveas p1/T8462h6a.java {
package p1;
public class T8462h6a {
    void m() {}
}
class T8462h6c extends p2.T8462h6b {
    // if this were not static, it would override a.m. Therefore, there is
    // a conflict, and this static method is hiding an instance method, even
    // though a.m is not inherited
    protected static void m() {}
}
    }] [saveas p2/T8462h6b.java {
package p2;
public class T8462h6b extends p1.T8462h6a {
    protected static void m() {} // legal
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.2-hiding-6 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/method-declarations/inheritance-overriding-and-hiding/inheriting-same-signature

==== 8.4.6.4-multiple-1  multiple inheritance is not a problem  FAILED
==== Contents of test case:

    empty_class T8464m1 {
	interface I1 {
	    void m();
	}
	interface I2 {
	    void m();
	}
	abstract class C implements I1, I2 {
	    { m(); }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-1 FAILED


==== 8.4.6.4-multiple-2  multiple paths still gives single
        inheritance  FAILED
==== Contents of test case:

    empty_class T8464m2 {
	interface Super {
	    void m();
	}
	interface I1 extends Super {}
	interface I2 extends Super {}
	abstract class C implements I1, I2 {
	    { m(); }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-2 FAILED


==== 8.4.6.4-multiple-3  It is possible to have access to multiple
        methods, when one is not inherited across package boundaries. The
        inherited method need not match the hidden one.  FAILED
==== Contents of test case:

    compile [saveas p1/T8464m3a.java {
package p1;
public class T8464m3a {
    int m() { return 1; }
}
class T8464m3c extends p2.T8464m3b {
    // inherited static b.m() does not clash with accessible instance a.m()
    int i = m();
}
    }] [saveas p2/T8464m3b.java {
package p2;
public class T8464m3b extends p1.T8464m3a {
    protected static int m() { return 1; }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-3 FAILED


==== 8.4.6.4-multiple-4  It is possible to have access to multiple
        methods, when one is not inherited across package boundaries. The
        inherited method need not match the hidden one.  FAILED
==== Contents of test case:

    compile [saveas p1/T8464m4a.java {
package p1;
public class T8464m4a {
    void m() {}
}
class T8464m4c extends p2.T8464m4b {
    // inherited return type of b.m() does not clash with accessible a.m()
    int i = m();
}
    }] [saveas p2/T8464m4b.java {
package p2;
public class T8464m4b extends p1.T8464m4a {
    protected int m() { return 1; }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-4 FAILED


==== 8.4.6.4-multiple-5  It is possible to have access to multiple
        methods, when one is not inherited across package boundaries. The
        inherited method need not match the hidden one.  FAILED
==== Contents of test case:

    compile [saveas p1/T8464m5a.java {
package p1;
public class T8464m5a {
    public class E extends Exception {}
    void m() {}
}
class T8464m5c extends p2.T8464m5b {
    // inherited throws clause of b.m() does not clash with accessible a.m()
    {
	try {
	    m();
	} catch (E e) {
	}
    }
}
    }] [saveas p2/T8464m5b.java {
package p2;
public class T8464m5b extends p1.T8464m5a {
    protected void m() throws E {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-5 FAILED


==== 8.4.6.4-multiple-6  It is possible to have access to multiple
        methods, when one is not inherited across package boundaries. The
        inherited method need not match the hidden one.  FAILED
==== Contents of test case:

    compile [saveas p1/T8464m6a.java {
package p1;
public class T8464m6a {
    int m() throws Exception { return 1; }
}
class T8464m6c extends p2.T8464m6b {
    // inherited of b.m() does not clash with throws clause of accessible a.m()
    int i = m();
}
    }] [saveas p2/T8464m6b.java {
package p2;
public class T8464m6b extends p1.T8464m6a {
    protected int m() { return 1; }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-6 FAILED


==== 8.4.6.4-multiple-7  It is possible to have access to multiple
        methods, when one is not inherited across package boundaries. The
        inherited method need not match the hidden one.  FAILED
==== Contents of test case:

    compile [saveas p1/T8464m7a.java {
package p1;
public class T8464m7a {
    final int m() { return 1; }
}
class T8464m7c extends p2.T8464m7b {
    // inherited b.m() does not violate final accessible a.m()
    int i = m();
}
    }] [saveas p2/T8464m7b.java {
package p2;
public class T8464m7b extends p1.T8464m7a {
    protected int m() { return 1; }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-7 FAILED


==== 8.4.6.4-multiple-8  It is possible to have access to multiple
        methods, when one is not inherited across package boundaries. The
        inherited method need not match the hidden one.  FAILED
==== Contents of test case:

    compile [saveas p1/T8464m8a.java {
package p1;
public class T8464m8a {
    final int m() { return 1; }
}
abstract class T8464m8c extends p2.T8464m8b {
    // inherited abstract b.m() can be implemented outside package p1.
    // Therefore, even though accessible a.m() is final, it need not provide
    // the implementation of b.m() since it is not inherited
    // Note, however, that no concrete subclass of b can live in p1.
    int i = m();
}
    }] [saveas p2/T8464m8b.java {
package p2;
public abstract class T8464m8b extends p1.T8464m8a {
    protected abstract int m();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-8 FAILED


==== 8.4.6.4-multiple-9  multiple inheritance is not a problem  FAILED
==== Contents of test case:

    empty_class T8464m9 {
	interface I {
	    void m();
	}
	class C {
	    public void m() {}
	}
	class D extends C implements I {
	    { m(); }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-9 FAILED


==== 8.4.6.4-multiple-10  multiple paths still gives single
        inheritance  FAILED
==== Contents of test case:

    empty_class T8464m10 {
	interface I {
	    void m();
	}
	abstract class C implements I {}
	abstract class D extends C implements I {
	    { m(); }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-10 FAILED


==== 8.4.6.4-multiple-11  It is possible to have access to multiple
        methods, when one is not inherited across package boundaries. The
        inherited method need not match the hidden one.  FAILED
==== Contents of test case:

    compile [saveas p1/T8464m11a.java {
package p1;
public abstract class T8464m11a {
    abstract int m();
}
abstract class T8464m11c extends p2.T8464m11b {
    // inherited b.m() is concrete, but does not implement a.m()
    int i = m();
}
    }] [saveas p2/T8464m11b.java {
package p2;
public abstract class T8464m11b extends p1.T8464m11a {
    protected int m() { return 1; }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-multiple-11 FAILED


==== 8.4.6.4-abstract-5  in multiple inheritance, a non-abstract
        method must implement the inherited abstract ones  FAILED
==== Contents of test case:

    empty_class T8464a5 {
	interface I {
	    void m() throws Exception;
	}
	class C {
	    public void m() {}
	}
	class D extends C implements I {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-abstract-5 FAILED


==== 8.4.6.4-abstract-6  in multiple inheritance with no
        implementation, all abstract methods are inherited, regardless of
        throws clauses  FAILED
==== Contents of test case:

    empty_class T8464a6 {
	class E1 extends Exception {}
	class E2 extends Exception {}
	interface I1 {
	    void m() throws E1;
	}
	interface I2 {
	    void m() throws E2;
	}
	abstract class C implements I1, I2 {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-abstract-6 FAILED


==== 8.4.6.4-abstract-7  in multiple inheritance with no
        implementation, all abstract methods are inherited  FAILED
==== Contents of test case:

    empty_class T8464a7 {
	abstract class C {
	    abstract void m(); // note non-public accessibility
	}
	interface I {
	    void m();
	}
	abstract class D extends C implements I {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-abstract-7 FAILED


==== 8.4.6.4-abstract-8  in multiple inheritance with no
        implementation, all abstract methods are inherited, regardless of
        throws clauses  FAILED
==== Contents of test case:

    empty_class T8464a8 {
	class E1 extends Exception {}
	class E2 extends Exception {}
	abstract class C {
	    public abstract void m() throws E1;
	}
	interface I {
	    void m() throws E2;
	}
	abstract class D extends C implements I {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.4-abstract-8 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/method-declarations/inheritance-overriding-and-hiding/overriding

==== 8.4.6.1-override-2  overloading does not affect overriding  FAILED
==== Contents of test case:

    empty_class T8461o2 {
	static class One {
	    static void m() {}
	}
	static class Two extends One {
	    int m(int i) throws Exception { return 1; }
	}
	static class Three extends Two {
	    {
		m();
		this.m();
		try {
		    m(1);
		    this.m(1);
		} catch (Exception e) {
		}
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.1-override-2 FAILED


==== 8.4.6.1-override-4  instance methods cannot override what is not
        accessible in superclass  FAILED
==== Contents of test case:

    compile [saveas p1/T8461o4a.java {
package p1;
public class T8461o4a {
    static void m() {}
}
class T8461o4c extends p2.T8461o4b {
    // if a.m were not static, this would override it. Therefore, there is
    // a conflict, and this instance method is overriding a static method, even
    // though a.m is not inherited
    void m() {}
}
    }] [saveas p2/T8461o4b.java {
package p2;
public class T8461o4b extends p1.T8461o4a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.1-override-4 FAILED


==== 8.4.6.1-override-5  non-abstract methods implement abstract
        ones that they override  FAILED
==== Contents of test case:

    empty_class T8461o5 {
	interface I {
	    void m();
	}
	class C implements I {
	    public void m() {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.1-override-5 FAILED


==== 8.4.6.1-override-6  instance methods cannot override what is not
        accessible in superclass  FAILED
==== Contents of test case:

    compile [saveas p1/T8461o6a.java {
package p1;
public class T8461o6a {
    static void m() {}
}
class T8461o6c extends p2.T8461o6b {
    // if a.m were not static, this would override it. Therefore, there is
    // a conflict, and this instance method is overriding a static method, even
    // though a.m is not inherited
    protected void m() {}
}
    }] [saveas p2/T8461o6b.java {
package p2;
public class T8461o6b extends p1.T8461o6a {
    protected void m() {} // legal
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.1-override-6 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/method-declarations/inheritance-overriding-and-hiding/requirements

==== 8.4.6.3-modifier-1  Access of overriding or hiding methods
        must equal or exceed prior access  FAILED
==== Contents of test case:

    empty_class T8463m1 {
	static class One {
	    public void pub() {}
	    protected void pro() {}
	    void pack() {}
	    public static void spub() {}
	    protected static void spro() {}
	    static void spack() {}
	}
	static class Two extends One {
	    public void pub() {}
	    public void pro() {}
	    public void pack() {}
	    public static void spub() {}
	    public static void spro() {}
	    public static void spack() {}
	}
	static class Three extends One {
	    protected static void spro() {}
	    protected static void spack() {}
	}
	static class Four extends One {
	    static void spack() {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.3-modifier-1 FAILED


==== 8.4.6.3-modifier-14  strictfp, abstract, native, and
        synchronized modifiers may change in overridden or hidden versions  FAILED
==== Contents of test case:

    empty_class T8463m14 {
	abstract static class One {
	    strictfp void strict() {}
	    abstract void abs();
	    native void nat();
	    synchronized void synch() {}
	    static strictfp void sstrict() {}
	    static native void snat();
	    static synchronized void ssynch() {}
	}
	abstract static class Two extends One {
	    abstract void strict();
	    native void abs();
	    synchronized void nat() {}
	    strictfp void synch() {}
	    static native void sstrict();
	    static synchronized void snat() {}
	    static strictfp void ssynch() {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.3-modifier-14 FAILED


==== 8.4.6.3-private-1  private methods are not overridden or
        hidden  FAILED
==== Contents of test case:

    empty_class T8463p1 {
	static class One {
	    private final int m() { return 1; }
	}
	static class Two extends One {
	    private static void m() {}
	}
	static class Three extends Two {
	    Object m() { return null; }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.3-private-1 FAILED


==== 8.4.6.3-default-1  It is possible to avoid inheriting a
        package scope method, but it must still be overridden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d1a.java {
package p1;
public class T8463d1a {
    void m() {}
}
class T8463d1c extends p2.T8463d1b {
    // conflicting return type, even though a.m() not inherited
    int m() { return 1; }
}
    }] [saveas p2/T8463d1b.java {
package p2;
public class T8463d1b extends p1.T8463d1a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-1 FAILED


==== 8.4.6.3-default-2  It is possible to avoid inheriting a
        package scope method, but it must still be hidden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d2a.java {
package p1;
public class T8463d2a {
    static void m() {}
}
class T8463d2c extends p2.T8463d2b {
    // conflicting return type, even though a.m() not inherited
    static int m() { return 1; }
}
    }] [saveas p2/T8463d2b.java {
package p2;
public class T8463d2b extends p1.T8463d2a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-2 FAILED


==== 8.4.6.3-default-3  It is possible to avoid inheriting a
        package scope method, but it must still be overridden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d3a.java {
package p1;
public class T8463d3a {
    void m() {}
}
class T8463d3c extends p2.T8463d3b {
    // conflicting throws clause, even though a.m() not inherited
    void m() throws Exception {}
}
    }] [saveas p2/T8463d3b.java {
package p2;
public class T8463d3b extends p1.T8463d3a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-3 FAILED


==== 8.4.6.3-default-4  It is possible to avoid inheriting a
        package scope method, but it must still be hidden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d4a.java {
package p1;
public class T8463d4a {
    static void m() {}
}
class T8463d4c extends p2.T8463d4b {
    // conflicting throws clause, even though a.m() not inherited
    static void m() throws Exception {}
}
    }] [saveas p2/T8463d4b.java {
package p2;
public class T8463d4b extends p1.T8463d4a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-4 FAILED


==== 8.4.6.3-default-5  It is possible to avoid inheriting a
        package scope method, but it must still be overridden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d5a.java {
package p1;
public class T8463d5a {
    final void m() {}
}
class T8463d5c extends p2.T8463d5b {
    // can't override final a.m, even though not inherited
    void m() {}
}
    }] [saveas p2/T8463d5b.java {
package p2;
public class T8463d5b extends p1.T8463d5a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-5 FAILED


==== 8.4.6.3-default-6  It is possible to avoid inheriting a
        package scope method, but it must still be hidden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d6a.java {
package p1;
public class T8463d6a {
    static final void m() {}
}
class T8463d6c extends p2.T8463d6b {
    // can't override final a.m, even though not inherited
    static void m() {}
}
    }] [saveas p2/T8463d6b.java {
package p2;
public class T8463d6b extends p1.T8463d6a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-6 FAILED


==== 8.4.6.3-default-7  It is possible to avoid inheriting a
        package scope method, but it must still be overridden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d7a.java {
package p1;
public class T8463d7a {
    void m() {}
}
class T8463d7c extends p2.T8463d7b {
    // conflicting return type, even though a.m() not inherited
    public int m() { return 1; }
}
    }] [saveas p2/T8463d7b.java {
package p2;
public class T8463d7b extends p1.T8463d7a {
    public int m() { return 1; }
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-7 FAILED


==== 8.4.6.3-default-8  It is possible to avoid inheriting a
        package scope method, but it must still be hidden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d8a.java {
package p1;
public class T8463d8a {
    static void m() {}
}
class T8463d8c extends p2.T8463d8b {
    // conflicting return type, even though a.m() not inherited
    public static int m() { return 1; }
}
    }] [saveas p2/T8463d8b.java {
package p2;
public class T8463d8b extends p1.T8463d8a {
    public static int m() { return 1; }
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-8 FAILED


==== 8.4.6.3-default-9  It is possible to avoid inheriting a
        package scope method, but it must still be overridden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d9a.java {
package p1;
public class T8463d9a {
    void m() {}
}
class T8463d9c extends p2.T8463d9b {
    // conflicting throws clause, even though a.m() not inherited
    public void m() throws Exception {}
}
    }] [saveas p2/T8463d9b.java {
package p2;
public class T8463d9b extends p1.T8463d9a {
    public void m() throws Exception {}
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-9 FAILED


==== 8.4.6.3-default-10  It is possible to avoid inheriting a
        package scope method, but it must still be hidden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d10a.java {
package p1;
public class T8463d10a {
    static void m() {}
}
class T8463d10c extends p2.T8463d10b {
    // conflicting throws clause, even though a.m() not inherited
    public static void m() throws Exception {}
}
    }] [saveas p2/T8463d10b.java {
package p2;
public class T8463d10b extends p1.T8463d10a {
    public static void m() throws Exception {}
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-10 FAILED


==== 8.4.6.3-default-11  It is possible to avoid inheriting a
        package scope method, but it must still be overridden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d11a.java {
package p1;
public class T8463d11a {
    final void m() {}
}
class T8463d11c extends p2.T8463d11b {
    // can't override final a.m, even though not inherited
    public void m() {}
}
    }] [saveas p2/T8463d11b.java {
package p2;
public class T8463d11b extends p1.T8463d11a {
    public void m() {}
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-11 FAILED


==== 8.4.6.3-default-12  It is possible to avoid inheriting a
        package scope method, but it must still be hidden correctly  FAILED
==== Contents of test case:

    compile [saveas p1/T8463d12a.java {
package p1;
public class T8463d12a {
    static final void m() {}
}
class T8463d12c extends p2.T8463d12b {
    // can't override final a.m, even though not inherited
    public static void m() {}
}
    }] [saveas p2/T8463d12b.java {
package p2;
public class T8463d12b extends p1.T8463d12a {
    public static void m() {}
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.6.3-default-12 FAILED


==== 8.4.6.3-signature-5  throws clauses must be compatible  FAILED
==== Contents of test case:

    empty_class T8463s5 {
	class E1 extends Exception {}
	class E2 extends Exception {}
	class E3 extends Exception {}
	interface I1 {
	    void m() throws E1, E2;
	}
	interface I2 {
	    void m() throws E2, E3;
	}
	class C implements I1, I2 {
	    public void m() throws E2 {}
	}
	class D extends C {
	    public void m() {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.3-signature-5 FAILED


==== 8.4.6.3-signature-8  throws clauses must be compatible  FAILED
==== Contents of test case:

    empty_class T8463s8 {
	class E1 extends Exception {}
	class E2 extends Exception {}
	interface I1 {
	    void m() throws E1;
	}
	interface I2 {
	    void m() throws E2;
	}
	abstract class C implements I1, I2 {}
	class D extends C {
	    public void m() {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.3-signature-8 FAILED


==== 8.4.6.3-signature-11  throws clauses must be compatible  FAILED
==== Contents of test case:

    empty_class T8463s11 {
	class E1 extends Exception {}
	class E2 extends Exception {}
	abstract class C1 {
	    public abstract void m() throws E1;
	}
	interface I {
	    void m() throws E2;
	}
	abstract class C2 extends C1 implements I {}
	class D extends C2 {
	    public void m() {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.3-signature-11 FAILED


==== 8.4.6.3-signature-14  throws clauses must be compatible  FAILED
==== Contents of test case:

    empty_class T8463s14 {
	class E1 extends Exception {}
	class E2 extends Exception {}
	abstract class C1 {
	    abstract void m() throws E1; // note non-public accessibility
	}
	interface I {
	    void m() throws E2;
	}
	abstract class C2 extends C1 implements I {}
	class D extends C2 {
	    public void m() {}
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.6.3-signature-14 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/method-declarations/method-body

==== 8.4.5-2  only a native or abstract method can have no method body  FAILED
==== Contents of test case:

    compile [saveas InvalidEmptyMethodBody.java  {
public class InvalidEmptyMethodBody {
    public void foo() ;
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.5-2 FAILED


==== 8.4.5-4  a native method can not have a body  FAILED
==== Contents of test case:

    compile [saveas InvalidNativeMethodBody.java  {
public class InvalidNativeMethodBody {
    public native void foo() {}
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.5-4 FAILED


==== 8.4.5-6  an abstract method can not have a body  FAILED
==== Contents of test case:

    compile [saveas InvalidAbstractMethodBody.java  {
public abstract class InvalidAbstractMethodBody {
    public abstract void foo() {}
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.5-6 FAILED


==== 8.4.5-7  non void method without a return is invalid  FAILED
==== Contents of test case:

    compile [saveas NoReturnInNonVoid.java  {
public class NoReturnInNonVoid {
    public boolean foo() {}
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.5-7 FAILED


==== 8.4.5-9  a return with no expression in a non void method is invalid  FAILED
==== Contents of test case:

    compile [saveas ConflictingReturnInNonVoid.java  {
public class ConflictingReturnInNonVoid {
    public boolean foo() {
        int i = 0;
        if (i == 1) {
            return true;
        } else {
            return;
        }
    }
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.5-9 FAILED


==== 8.4.5-10  a return with an expression in a void method is invalid  FAILED
==== Contents of test case:

    compile [saveas ConflictingReturnInVoid.java  {
public class ConflictingReturnInVoid {
    public void foo() {
        int i = 0;
        if (i == 1) {
            return true;
        } else {
            return;
        }
    }
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.5-10 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/method-declarations/method-modifiers

==== 8.4.3-access-1  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T843access1 {
        public public void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-access-1 FAILED


==== 8.4.3-access-2  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T843access2 {
        public protected void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-access-2 FAILED


==== 8.4.3-access-3  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T843access3 {
        public private void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-access-3 FAILED


==== 8.4.3-access-4  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T843access4 {
        protected public void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-access-4 FAILED


==== 8.4.3-access-5  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T843access5 {
        protected protected void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-access-5 FAILED


==== 8.4.3-access-6  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T843access6 {
        protected private void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-access-6 FAILED


==== 8.4.3-access-7  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T843access7 {
        private public void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-access-7 FAILED


==== 8.4.3-access-8  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T843access8 {
        private protected void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-access-8 FAILED


==== 8.4.3-access-9  Multiple access modifiers is an error  FAILED
==== Contents of test case:

    empty_class T843access9 {
        private private void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-access-9 FAILED


==== 8.4.3-abstract-6  private abstract is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract6.java {
abstract class T843abstract6 {
    private abstract void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-6 FAILED


==== 8.4.3-abstract-7  abstract private is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract7.java {
abstract class T843abstract7 {
    abstract private void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-7 FAILED


==== 8.4.3-abstract-8  abstract abstract is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract8.java {
abstract class T843abstract8 {
    abstract abstract void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-8 FAILED


==== 8.4.3-abstract-9  static abstract is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract9.java {
abstract class T843abstract9 {
    static abstract void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-9 FAILED


==== 8.4.3-abstract-10  abstract static is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract10.java {
abstract class T843abstract10 {
    abstract static void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-10 FAILED


==== 8.4.3-abstract-11  final abstract is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract11.java {
abstract class T843abstract11 {
    final abstract void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-11 FAILED


==== 8.4.3-abstract-12  abstract final is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract12.java {
abstract class T843abstract12 {
    abstract final void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-12 FAILED


==== 8.4.3-abstract-13  synchronized abstract is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract13.java {
abstract class T843abstract13 {
    synchronized abstract void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-13 FAILED


==== 8.4.3-abstract-14  abstract synchronized is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract14.java {
abstract class T843abstract14 {
    abstract synchronized void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-14 FAILED


==== 8.4.3-abstract-15  native abstract is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract15.java {
abstract class T843abstract15 {
    native abstract void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-15 FAILED


==== 8.4.3-abstract-16  abstract native is illegal  FAILED
==== Contents of test case:

    compile [saveas T843abstract16.java {
abstract class T843abstract16 {
    abstract native void foo();
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-abstract-16 FAILED


==== 8.4.3-static-8  static static is illegal  FAILED
==== Contents of test case:

    empty_class T843static8 {
        static static void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-static-8 FAILED


==== 8.4.3-static-15  static strictfp is legal  FAILED
==== Contents of test case:

    empty_class T843static15 {
        static strictfp void foo() {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.3-static-15 FAILED


==== 8.4.3-static-16  strictfp static is legal, but not in
        the preferred order  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T843static16 {
        strictfp static void foo() {}
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.4.3-static-16 FAILED


==== 8.4.3-final-8  final final is illegal  FAILED
==== Contents of test case:

    empty_class T843final8 {
        final final void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-final-8 FAILED


==== 8.4.3-final-13  final strictfp is legal  FAILED
==== Contents of test case:

    empty_class T843final13 {
        final strictfp void foo() {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.3-final-13 FAILED


==== 8.4.3-final-14  strictfp final is legal, but not in
        the preferred order  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T843final14 {
        strictfp final void foo() {}
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.4.3-final-14 FAILED


==== 8.4.3-synchronized-8  synchronized synchronized is illegal  FAILED
==== Contents of test case:

    empty_class T843synchronized8 {
        synchronized synchronized void foo() {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-synchronized-8 FAILED


==== 8.4.3-synchronized-11  synchronized strictfp is legal  FAILED
==== Contents of test case:

    empty_class T843synchronized11 {
        synchronized strictfp void foo() {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.3-synchronized-11 FAILED


==== 8.4.3-synchronized-12  strictfp synchronized is legal, but
        not in the preferred order  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T843synchronized12 {
        strictfp synchronized void foo() {}
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.4.3-synchronized-12 FAILED


==== 8.4.3-native-8  native native is illegal  FAILED
==== Contents of test case:

    empty_class T843native8 {
        native native void foo();
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.3-native-8 FAILED


==== 8.4.3-strictfp-1  strictfp alone is legal  FAILED
==== Contents of test case:

    empty_class T843strictfp1 {
        strictfp void foo() {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.3-strictfp-1 FAILED


==== 8.4.3-strictfp-2  public strictfp is legal  FAILED
==== Contents of test case:

    empty_class T843strictfp2 {
        public strictfp void foo() {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.3-strictfp-2 FAILED


==== 8.4.3-strictfp-3  strictfp public is legal, but not in
        the preferred order  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T843strictfp3 {
        strictfp public void foo() {}
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.4.3-strictfp-3 FAILED


==== 8.4.3-strictfp-4  protected strictfp is legal  FAILED
==== Contents of test case:

    empty_class T843strictfp4 {
        protected strictfp void foo() {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.3-strictfp-4 FAILED


==== 8.4.3-strictfp-5  strictfp protected is legal, but
        not in the preferred order  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T843strictfp5 {
        strictfp protected void foo() {}
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.4.3-strictfp-5 FAILED


==== 8.4.3-strictfp-6  private strictfp is legal  FAILED
==== Contents of test case:

    empty_class T843strictfp6 {
        private strictfp void foo() {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.3-strictfp-6 FAILED


==== 8.4.3-strictfp-7  strictfp private is legal, but
        not in the preferred order  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T843strictfp7 {
        strictfp private void foo() {}
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.4.3-strictfp-7 FAILED


==== 8.4.3-strictfp-9  strictfp in a strictfp class is legal, but
        redundant  FAILED
==== Contents of test case:

    ok_pass_or_warn [compile [saveas T843strictfp9.java {
strictfp class T843strictfp9 {
    strictfp void foo() {}
}
    }]]

---- Result was:
FAIL
---- Result should have been:
OK
==== 8.4.3-strictfp-9 FAILED


==== 8.4.3-big-1  largest number of modifiers allowed  FAILED
==== Contents of test case:

    empty_class T843big1 {
        public static final synchronized strictfp void foo() {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.4.3-big-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/method-declarations/method-signature

==== 8.4.2-invalid-signature-1  A class may not declare two methods
        with the same signature, or a compile-time error occurs  FAILED
==== Contents of test case:

    empty_class T842is1 {
        T882is1(int i) {}
        T882is1(int j) {}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.2-invalid-signature-1 FAILED


==== 8.4.2-invalid-signature-2  A class may not declare two methods
        with the same signature, or a compile-time error occurs  FAILED
==== Contents of test case:

    empty_class T842is2 {
        int x, y;
        abstract void move(int dx, int dy);
        void move(int dx, int dy) { x += dx; y += dy; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.2-invalid-signature-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/method-declarations/method-throws

==== 8.4.4-throws-5  Class mentioned in throws clause
  must be Throwable or subclass  FAILED
==== Contents of test case:

    empty_class T844t5 {
      // Non-exception type
      void m() throws String { }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.4-throws-5 FAILED


==== 8.4.4-throws-6  Class mentioned in throws clause
  must be Throwable or subclass  FAILED
==== Contents of test case:

    empty_class T844t6 {
      // Try an interface
      void m() throws java.io.Serializable { }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 8.4.4-throws-6 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/classes/static-initializers

==== 8.7-complete-2  Static initializers must be able to complete
        normally, by 14.20, if(true) always completes normally  FAILED
==== Contents of test case:

    empty_class T87c2 {
        static { if (true) throw new RuntimeException(); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.7-complete-2 FAILED


==== 8.7-complete-4  Static initializers must be able to complete
        normally, by 14.20, if(true) always completes normally  FAILED
==== Contents of test case:

    empty_class T87c4 {
        static { if (true) while (true); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 8.7-complete-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/conversions-and-promotions/assignment-conversion

==== 5.2-byte-widening-3  Assignment contexts allow the use
        of a widening primitive conversion  FAILED
==== Contents of test case:

    empty_main T52bw3 {
        long l = (byte) 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-byte-widening-3 FAILED


==== 5.2-byte-narrowing-1  Assignment conversion may narrow if
        a constant expression of type byte is assigned to a variable
        of type char  FAILED
==== Contents of test case:

    empty_main T52bn1 {
        char c = (byte) 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-byte-narrowing-1 FAILED


==== 5.2-short-widening-2  Assignment contexts allow the use
        of a widening primitive conversion  FAILED
==== Contents of test case:

    empty_main T52sw2 {
        long l = (short) 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-short-widening-2 FAILED


==== 5.2-short-narrowing-1  Assignment conversion may narrow if
        a constant expression of type short is assigned to a variable
        of type byte  FAILED
==== Contents of test case:

    empty_main T52sn1 {
        byte b = (short) 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-short-narrowing-1 FAILED


==== 5.2-short-narrowing-2  Assignment conversion may narrow if
        a constant expression of type short is assigned to a variable
        of type char  FAILED
==== Contents of test case:

    empty_main T52sn2 {
        char c = (short) 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-short-narrowing-2 FAILED


==== 5.2-char-widening-2  Assignment contexts allow the use
        of a widening primitive conversion  FAILED
==== Contents of test case:

    empty_main T52cw2 {
        long l = '1';
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-char-widening-2 FAILED


==== 5.2-char-narrowing-1  Assignment conversion may narrow if
        a constant expression of type char is assigned to a variable
        of type byte  FAILED
==== Contents of test case:

    empty_main T52cn1 {
        byte b = '1';
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-char-narrowing-1 FAILED


==== 5.2-char-narrowing-2  Assignment conversion may narrow if
        a constant expression of type char is assigned to a variable
        of type short  FAILED
==== Contents of test case:

    empty_main T52cn2 {
        short s = '1';
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-char-narrowing-2 FAILED


==== 5.2-int-widening-1  Assignment contexts allow the use
        of a widening primitive conversion  FAILED
==== Contents of test case:

    empty_main T52iw1 {
        long l = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-int-widening-1 FAILED


==== 5.2-int-narrowing-3  Assignment conversion may narrow if
        a constant expression of type int is assigned to a variable
        of type char  FAILED
==== Contents of test case:

    empty_main T52in3 {
        char c = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-int-narrowing-3 FAILED


==== 5.2-int-narrowing-error-2  Assignment conversion
        may not narrow if the expression is not representable in the type
        of the variable  FAILED
==== Contents of test case:

    empty_main T52ine2 {
        byte b = -129;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 5.2-int-narrowing-error-2 FAILED


==== 5.2-int-narrowing-error-3  Assignment conversion
        may not narrow if the expression is not representable in the type
        of the variable  FAILED
==== Contents of test case:

    empty_main T52ine3 {
        short s = 32768;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 5.2-int-narrowing-error-3 FAILED


==== 5.2-long-identity-1  Assignment contexts allow the use
        of an identity conversion  FAILED
==== Contents of test case:

    empty_main T52li1 {
        long l = 1L;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-long-identity-1 FAILED


==== 5.2-long-narrowing-error-1  Assignment conversion may
        not narrow an expression of type long  FAILED
==== Contents of test case:

    empty_main T52lne1 {
        byte b = 1L;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 5.2-long-narrowing-error-1 FAILED


==== 5.2-long-narrowing-error-2  Assignment conversion may
        not narrow an expression of type long  FAILED
==== Contents of test case:

    empty_main T52lne2 {
        short s = 1L;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 5.2-long-narrowing-error-2 FAILED


==== 5.2-long-narrowing-error-4  Assignment conversion may
        not narrow an expression of type long  FAILED
==== Contents of test case:

    empty_main T52lne4 {
        int i = 1L;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 5.2-long-narrowing-error-4 FAILED


==== 5.2-double-narrowing-error-6  Assignment conversion may
        not narrow an expression of type double  FAILED
==== Contents of test case:

    empty_main T52dne6 {
        float f = 1.0D;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 5.2-double-narrowing-error-6 FAILED


==== 5.2-interface-identity-1  Assignment contexts allow the use
        of an identity conversion  FAILED
==== Contents of test case:

    empty_class T52ii1 {
        void foo(Cloneable c) {
            Cloneable c1 = c;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-interface-identity-1 FAILED


==== 5.2-interface-widening-1  Assignment contexts allow the use
        of a widening reference conversion  FAILED
==== Contents of test case:

    empty_class T52iw1 {
        interface I extends Cloneable {}
        void foo(I i) {
            Cloneable c = i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-interface-widening-1 FAILED


==== 5.2-interface-widening-2  Assignment contexts allow the use
        of a widening reference conversion  FAILED
==== Contents of test case:

    empty_main T52iw2 {
        Cloneable c = null;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.2-interface-widening-2 FAILED


==== 5.2-array-error-4  Assignment conversion cannot
        assign a array with a different primitive base type FAILED
==== Contents of test case:

    empty_main T52ae4 {
        int[] i = new short[0];
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 5.2-array-error-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/conversions-and-promotions/kinds-of-conversion/identity-conversions

==== 5.1.1-primitive-1  boolean identity conversion  FAILED
==== Contents of test case:

    empty_class T511p1 {
        boolean b1 = (boolean) true;
        boolean b2 = (boolean) b1;
        boolean b3 = (boolean) (false != false);
        boolean b4 = (boolean) Boolean.TRUE.booleanValue();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-primitive-1 FAILED


==== 5.1.1-primitive-2  byte identity conversion  FAILED
==== Contents of test case:

    empty_class T511p2 {
        static final byte b1 = 1;
        byte b2 = (byte) b1;
        byte b3 = (byte) (new Byte(Byte.MAX_VALUE).byteValue());
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-primitive-2 FAILED


==== 5.1.1-primitive-3  short identity conversion  FAILED
==== Contents of test case:

    empty_class T511p3 {
        static final short s1 = 1;
        short s2 = (short) s1;
        short s3 = (short) (new Short(Short.MAX_VALUE).shortValue());
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-primitive-3 FAILED


==== 5.1.1-primitive-4  char identity conversion  FAILED
==== Contents of test case:

    empty_class T511p4 {
        char c1 = (char) '1';
        char c2 = (char) c1;
        char c3 = (char) (new Character(Character.MAX_VALUE).charValue());
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-primitive-4 FAILED


==== 5.1.1-primitive-5  int identity conversion  FAILED
==== Contents of test case:

    empty_class T511p5 {
        int i1 = (int) 1;
        int i2 = (int) i1;
        int i3 = (int) (1 + 2);
        int i4 = (int) (new Integer(Integer.MAX_VALUE).intValue());
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-primitive-5 FAILED


==== 5.1.1-primitive-6  long identity conversion  FAILED
==== Contents of test case:

    empty_class T511p6 {
        long l1 = (long) 1L;
        long l2 = (long) l1;
        long l3 = (long) (1L + 2L);
        long l4 = (long) (new Long(Long.MAX_VALUE).longValue());
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-primitive-6 FAILED


==== 5.1.1-primitive-7  float identity conversion  FAILED
==== Contents of test case:

    empty_class T511p7 {
        float f1 = (float) 1.0f;
        float f2 = (float) f1;
        float f3 = (float) (1f + 2f);
        float f4 = (float) (new Float(Float.MAX_VALUE).floatValue());
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-primitive-7 FAILED


==== 5.1.1-primitive-8  double identity conversion  FAILED
==== Contents of test case:

    empty_class T511p8 {
        double d1 = (double) 1.0;
        double d2 = (double) d1;
        double d3 = (double) (1.0 + 2.0);
        double d4 = (double) (new Double(Double.MAX_VALUE).doubleValue());
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-primitive-8 FAILED


==== 5.1.1-reference-1  reference identity conversion: Object  FAILED
==== Contents of test case:

    empty_class T511r1 {
        Object o1 = (Object) new Object();
        Object o2 = (Object) null;
        Object o3 = (Object) o1;
        Object o4 = (Object) o2;
        Object foo() { return new Object(); }
        Object o5 = (Object) foo();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-reference-1 FAILED


==== 5.1.1-reference-2  reference identity conversion: String  FAILED
==== Contents of test case:

    empty_class T511r2 {
        String s1 = (String) "";
        String s2 = (String) null;
        String s3 = (String) s1;
        String s4 = (String) s2;
        String s5 = (String) ("1" + "2");
        String s6 = (String) "1".concat("2");
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-reference-2 FAILED


==== 5.1.1-reference-3  reference identity conversion: this class  FAILED
==== Contents of test case:

    empty_class T511r3 {
        T511r3 t1 = (T511r3) new T511r3();
        T511r3 t2 = (T511r3) null;
        T511r3 t3 = (T511r3) t1;
        T511r3 t4 = (T511r3) t2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-reference-3 FAILED


==== 5.1.1-reference-4  reference identity conversion: primitive array  FAILED
==== Contents of test case:

    empty_class T511r4 {
        int[] ia1 = {1, 2};
        int[] ia2 = (int[]) null;
        int[] ia3 = (int[]) ia1;
        int[] ia4 = (int[]) ia2;
        int[] foo() { return new int[0]; }
        int[] ia5 = (int[]) foo();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.1-reference-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/conversions-and-promotions/kinds-of-conversion/narrowing-primitive-conversions

==== 5.1.3-nan-1  narrowing from float NaN to int produces 0  FAILED
==== Contents of test case:

    constant_expression T513nan1 {(int) Float.NaN == 0} {(int) -Float.NaN == 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-nan-1 FAILED


==== 5.1.3-nan-2  narrowing from double NaN to int produces 0  FAILED
==== Contents of test case:

    constant_expression T513nan2 {(int) Double.NaN == 0} {(int) -Double.NaN == 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-nan-2 FAILED


==== 5.1.3-nan-3  narrowing from float NaN to long produces 0  FAILED
==== Contents of test case:

    constant_expression T513nan3 {(long) Float.NaN == 0L} {(long) -Float.NaN == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-nan-3 FAILED


==== 5.1.3-nan-4  narrowing from double NaN to long produces 0  FAILED
==== Contents of test case:

    constant_expression T513nan4 {(long) Double.NaN == 0L} {(long) -Double.NaN == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-nan-4 FAILED


==== 5.1.3-nan-5  narrowing from double NaN to float produces NaN  FAILED
==== Contents of test case:

    constant_expression T513nan5 {(float) Double.NaN != (float) Double.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-nan-5 FAILED


==== 5.1.3-dtf-1  narrowing from double to float can overflow  FAILED
==== Contents of test case:

    constant_expression T513dtf1 {(float) 1e100 == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtf-1 FAILED


==== 5.1.3-dtf-2  narrowing from double to float can underflow  FAILED
==== Contents of test case:

    constant_expression T513dtf2 {(float) 1e-100 == 0.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtf-2 FAILED


==== 5.1.3-dtf-3  narrowing from double to float rounds down if
        remainder < .5  FAILED
==== Contents of test case:

    constant_expression T513dtf3 {(float)(double)0x8000ff7ffffL == (float)0x8000ff00000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtf-3 FAILED


==== 5.1.3-dtf-4  narrowing from double to float rounds up if
        remainder > .5  FAILED
==== Contents of test case:

    constant_expression T513dtf4 {(float)(double)0x8000ff80001L == (float)0x80010000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtf-4 FAILED


==== 5.1.3-dtf-5  narrowing from double to float rounds to lsb 0 if
        remainder == .5  FAILED
==== Contents of test case:

    constant_expression T513dtf5 {(float)(double)0x8000ff80000L == (float)0x80010000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtf-5 FAILED


==== 5.1.3-dtf-6  narrowing from double to float rounds to lsb 0 if
        remainder == .5  FAILED
==== Contents of test case:

    constant_expression T513dtf6 {(float)(double)0x8000f080000L == (float)0x8000f000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtf-6 FAILED


==== 5.1.3-dtf-7  narrowing from double to denorm float rounds to nearest  FAILED
==== Contents of test case:

    constant_expression T513dtf7  {(float)5.877475257357598E-39 == 5.877475e-39f}  {(float)5.8774752573576E-39 == 5.877476e-39f}  {(float)5.87747595800683E-39 == 5.877476e-39f}  {(float)5.877476658656061E-39 == 5.877476e-39f}  {(float)5.877476658656063E-39 == 5.877477e-39f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtf-7 FAILED


==== 5.1.3-dtl-1  narrowing from double to long truncates  FAILED
==== Contents of test case:

    constant_expression T513dtl1  {(long)Double.POSITIVE_INFINITY == 0x7fffffffffffffffL}  {(long)Double.NEGATIVE_INFINITY == 0x8000000000000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtl-1 FAILED


==== 5.1.3-dtl-2  narrowing from double to long truncates  FAILED
==== Contents of test case:

    constant_expression T513dtl2 {(long)1e40 == 0x7fffffffffffffffL}  {(long)-1e40 == 0x8000000000000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtl-2 FAILED


==== 5.1.3-dtl-3  narrowing from double to long truncates  FAILED
==== Contents of test case:

    constant_expression T513dtl3 {(long)0.0 == 0L}  {(long)-0.0 == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtl-3 FAILED


==== 5.1.3-dtl-4  narrowing from double to long truncates  FAILED
==== Contents of test case:

    constant_expression T513dtl4 {(long)1.999 == 1L}  {(long)-1.999 == -1L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dtl-4 FAILED


==== 5.1.3-dti-1  narrowing from double to int truncates  FAILED
==== Contents of test case:

    constant_expression T513dti1  {(int)Double.POSITIVE_INFINITY == 0x7fffffff}  {(int)Double.NEGATIVE_INFINITY == 0x80000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dti-1 FAILED


==== 5.1.3-dti-2  narrowing from double to int truncates  FAILED
==== Contents of test case:

    constant_expression T513dti2 {(int)1e40 == 0x7fffffff}  {(int)-1e40 == 0x80000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dti-2 FAILED


==== 5.1.3-dti-3  narrowing from double to int truncates  FAILED
==== Contents of test case:

    constant_expression T513dti3 {(int)0.0 == 0L}  {(int)-0.0 == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dti-3 FAILED


==== 5.1.3-dti-4  narrowing from double to int truncates  FAILED
==== Contents of test case:

    constant_expression T513dti4 {(int)1.999 == 1L}  {(int)-1.999 == -1L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-dti-4 FAILED


==== 5.1.3-ftl-1  narrowing from float to long truncates  FAILED
==== Contents of test case:

    constant_expression T513ftl1  {(long)Float.POSITIVE_INFINITY == 0x7fffffffffffffffL}  {(long)Float.NEGATIVE_INFINITY == 0x8000000000000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-ftl-1 FAILED


==== 5.1.3-ftl-2  narrowing from float to long truncates  FAILED
==== Contents of test case:

    constant_expression T513ftl2 {(long)1e30f == 0x7fffffffffffffffL}  {(long)-1e30f == 0x8000000000000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-ftl-2 FAILED


==== 5.1.3-ftl-3  narrowing from float to long truncates  FAILED
==== Contents of test case:

    constant_expression T513ftl3 {(long)0.0f == 0L}  {(long)-0.0f == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-ftl-3 FAILED


==== 5.1.3-ftl-4  narrowing from float to long truncates  FAILED
==== Contents of test case:

    constant_expression T513ftl4 {(long)1.999f == 1L}  {(long)-1.999f == -1L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-ftl-4 FAILED


==== 5.1.3-fti-1  narrowing from float to int truncates  FAILED
==== Contents of test case:

    constant_expression T513fti1  {(int)Float.POSITIVE_INFINITY == 0x7fffffff}  {(int)Float.NEGATIVE_INFINITY == 0x80000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-fti-1 FAILED


==== 5.1.3-fti-2  narrowing from float to int truncates  FAILED
==== Contents of test case:

    constant_expression T513fti2 {(int)1e30f == 0x7fffffff}  {(int)-1e30f == 0x80000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-fti-2 FAILED


==== 5.1.3-fti-3  narrowing from float to int truncates  FAILED
==== Contents of test case:

    constant_expression T513fti3 {(int)0.0f == 0}  {(int)-0.0f == 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-fti-3 FAILED


==== 5.1.3-fti-4  narrowing from float to int truncates  FAILED
==== Contents of test case:

    constant_expression T513fti4 {(int)1.999f == 1}  {(int)-1.999f == -1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.3-fti-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/conversions-and-promotions/kinds-of-conversion/widening-primitive-conversions

==== 5.1.2-bts-1  byte to short conversion never loses information  FAILED
==== Contents of test case:

    empty_main T512bts1 {
        final byte b = 72;
        final short s = 72;
        switch (args.length) {
            case 0:
            case (((short)b == s) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bts-1 FAILED


==== 5.1.2-bts-2  byte to short boundary case  FAILED
==== Contents of test case:

    empty_main T512bts2 {
        final byte b = Byte.MAX_VALUE;
        final short s = 127;
        switch (args.length) {
            case 0:
            case (((short)b == s) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bts-2 FAILED


==== 5.1.2-bts-3  byte to short boundary case  FAILED
==== Contents of test case:

    empty_main T512bts3 {
        final byte b = 0;
        final short s = 0;
        switch (args.length) {
            case 0:
            case (((short)b == s) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bts-3 FAILED


==== 5.1.2-bts-4  byte to short boundary case  FAILED
==== Contents of test case:

    empty_main T512bts4 {
        final byte b = Byte.MIN_VALUE;
        final short s = -128;
        switch (args.length) {
            case 0:
            case (((short)b == s) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bts-4 FAILED


==== 5.1.2-bts-5  byte to short boundary case  FAILED
==== Contents of test case:

    empty_main T512bts5 {
        final byte b = -1;
        final short s = -1;
        switch (args.length) {
            case 0:
            case (((short)b == s) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bts-5 FAILED


==== 5.1.2-bti-1  byte to int conversion never loses information  FAILED
==== Contents of test case:

    empty_main T512bti1 {
        final byte b = 72;
        switch (args.length) {
            case 0:
            case (((int)b == 72) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bti-1 FAILED


==== 5.1.2-bti-2  byte to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512bti2 {(int)Byte.MAX_VALUE == 127}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bti-2 FAILED


==== 5.1.2-bti-3  byte to int boundary case  FAILED
==== Contents of test case:

    empty_main T512bti3 {
        final byte b = 0;
        switch (args.length) {
            case 0:
            case (((int)b == 0) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bti-3 FAILED


==== 5.1.2-bti-4  byte to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512bti4 {(int)Byte.MIN_VALUE == -128}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bti-4 FAILED


==== 5.1.2-bti-5  byte to int boundary case  FAILED
==== Contents of test case:

    empty_main T512bti5 {
        final byte b = -1;
        switch (args.length) {
            case 0:
            case (((int)b == -1) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-bti-5 FAILED


==== 5.1.2-btl-1  byte to long conversion never loses information  FAILED
==== Contents of test case:

    empty_main T512btl1 {
        final byte b = 72;
        switch (args.length) {
            case 0:
            case (((long)b == 72L) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btl-1 FAILED


==== 5.1.2-btl-2  byte to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512btl2 {(long)Byte.MAX_VALUE == 127L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btl-2 FAILED


==== 5.1.2-btl-3  byte to long boundary case  FAILED
==== Contents of test case:

    empty_main T512btl3 {
        final byte b = 0;
        switch (args.length) {
            case 0:
            case (((long)b == 0L) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btl-3 FAILED


==== 5.1.2-btl-4  byte to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512btl4 {(long)Byte.MIN_VALUE == -128L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btl-4 FAILED


==== 5.1.2-btl-5  byte to long boundary case  FAILED
==== Contents of test case:

    empty_main T512btl5 {
        final byte b = -1;
        switch (args.length) {
            case 0:
            case (((long)b == -1L) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btl-5 FAILED


==== 5.1.2-btf-1  byte to float conversion never loses information  FAILED
==== Contents of test case:

    empty_main T512btf1 {
        final byte b = 72;
        switch (args.length) {
            case 0:
            case (((float)b == 72.0f) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btf-1 FAILED


==== 5.1.2-btf-2  byte to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512btf2 {(float)Byte.MAX_VALUE == 127.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btf-2 FAILED


==== 5.1.2-btf-3  byte to float boundary case  FAILED
==== Contents of test case:

    empty_main T512btf3 {
        final byte b = 0;
        switch (args.length) {
            case 0:
            case (((float)b == 0.0f) ? 1 : 0):
            case ((1/(float)b == Float.POSITIVE_INFINITY) ? 2 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btf-3 FAILED


==== 5.1.2-btf-4  byte to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512btf4 {(float)Byte.MIN_VALUE == -128.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btf-4 FAILED


==== 5.1.2-btf-5  byte to float boundary case  FAILED
==== Contents of test case:

    empty_main T512btf5 {
        final byte b = -1;
        switch (args.length) {
            case 0:
            case (((float)b == -1.0f) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btf-5 FAILED


==== 5.1.2-btd-1  byte to double conversion never loses information  FAILED
==== Contents of test case:

    empty_main T512btd1 {
        final byte b = 72;
        switch (args.length) {
            case 0:
            case (((double)b == 72.0) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btd-1 FAILED


==== 5.1.2-btd-2  byte to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512btd2 {(double)Byte.MAX_VALUE == 127.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btd-2 FAILED


==== 5.1.2-btd-3  byte to double boundary case  FAILED
==== Contents of test case:

    empty_main T512btd3 {
        final byte b = 0;
        switch (args.length) {
            case 0:
            case (((double)b == 0.0) ? 1 : 0):
            case ((1/(double)b == Double.POSITIVE_INFINITY) ? 2 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btd-3 FAILED


==== 5.1.2-btd-4  byte to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512btd4 {(double)Byte.MIN_VALUE == -128.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btd-4 FAILED


==== 5.1.2-btd-5  byte to double boundary case  FAILED
==== Contents of test case:

    empty_main T512btd5 {
        final byte b = -1;
        switch (args.length) {
            case 0:
            case (((double)b == -1.0) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-btd-5 FAILED


==== 5.1.2-sti-1  short to int conversion never loses information  FAILED
==== Contents of test case:

    empty_main T512sti1 {
        final short s = 12345;
        switch (args.length) {
            case 0:
            case (((int)s == 12345) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-sti-1 FAILED


==== 5.1.2-sti-2  short to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512sti2 {(int)Short.MAX_VALUE == 32767}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-sti-2 FAILED


==== 5.1.2-sti-3  short to int boundary case  FAILED
==== Contents of test case:

    empty_main T512sti3 {
        final short s = 0;
        switch (args.length) {
            case 0:
            case (((int)s == 0) ? 1 : 0):
        }
    }
    constant_expression T512sti3 {(int)0 == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-sti-3 FAILED


==== 5.1.2-sti-4  short to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512sti4 {(int)Short.MIN_VALUE == -32768}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-sti-4 FAILED


==== 5.1.2-sti-5  short to int boundary case  FAILED
==== Contents of test case:

    empty_main T512sti5 {
        final short s = -1;
        switch (args.length) {
            case 0:
            case (((int)s == -1) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-sti-5 FAILED


==== 5.1.2-stl-1  short to long conversion never loses information  FAILED
==== Contents of test case:

    empty_main T512stl1 {
        final short s = 12345;
        switch (args.length) {
            case 0:
            case (((long)s == 12345L) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stl-1 FAILED


==== 5.1.2-stl-2  short to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512stl2 {(long)Short.MAX_VALUE == 32767L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stl-2 FAILED


==== 5.1.2-stl-3  short to long boundary case  FAILED
==== Contents of test case:

    empty_main T512stl3 {
        final short s = 0;
        switch (args.length) {
            case 0:
            case (((long)s == 0L) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stl-3 FAILED


==== 5.1.2-stl-4  short to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512stl4 {(long)Short.MIN_VALUE == -32768L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stl-4 FAILED


==== 5.1.2-stl-5  short to long boundary case  FAILED
==== Contents of test case:

    empty_main T512stl5 {
        final short s = -1;
        switch (args.length) {
            case 0:
            case (((long)s == -1L) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stl-5 FAILED


==== 5.1.2-stf-1  short to float conversion never loses information  FAILED
==== Contents of test case:

    empty_main T512stf3 {
        final short s = 12345;
        switch (args.length) {
            case 0:
            case (((float)s == 12345.0f) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stf-1 FAILED


==== 5.1.2-stf-2  short to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512stf2 {(float)Short.MAX_VALUE == 32767.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stf-2 FAILED


==== 5.1.2-stf-3  short to float boundary case  FAILED
==== Contents of test case:

    empty_main T512stf3 {
        final short s = 0;
        switch (args.length) {
            case 0:
            case (((float)s == 0.0f) ? 1 : 0):
            case ((1/(float)s == Float.POSITIVE_INFINITY) ? 2 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stf-3 FAILED


==== 5.1.2-stf-4  short to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512stf4 {(float)Short.MIN_VALUE == -32768.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stf-4 FAILED


==== 5.1.2-stf-5  short to float boundary case  FAILED
==== Contents of test case:

    empty_main T512stf5 {
        final short s = -1;
        switch (args.length) {
            case 0:
            case (((float)s == -1.0f) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-stf-5 FAILED


==== 5.1.2-std-1  short to double conversion never loses information  FAILED
==== Contents of test case:

    empty_main T512std1 {
        final short s = 12345;
        switch (args.length) {
            case 0:
            case (((double)s == 12345.0) ? 1 : 0):
        }
    }
    constant_expression T512std1 {(double)12345678 == 12345678L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-std-1 FAILED


==== 5.1.2-std-2  short to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512std2 {(double)Short.MAX_VALUE == 32767.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-std-2 FAILED


==== 5.1.2-std-3  short to double boundary case  FAILED
==== Contents of test case:

    empty_main T512std3 {
        final short s = 0;
        switch (args.length) {
            case 0:
            case (((double)s == 0.0) ? 1 : 0):
            case ((1/(double)s == Double.POSITIVE_INFINITY) ? 2 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-std-3 FAILED


==== 5.1.2-std-4  short to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512std4 {(double)Short.MIN_VALUE == -32768.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-std-4 FAILED


==== 5.1.2-std-5  short to double boundary case  FAILED
==== Contents of test case:

    empty_main T512std5 {
        final short s = -1;
        switch (args.length) {
            case 0:
            case (((double)s == -1.0) ? 1 : 0):
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-std-5 FAILED


==== 5.1.2-cti-1  char to int conversion never loses information  FAILED
==== Contents of test case:

    constant_expression T512cti1 {(int)'\u789a' == 0x789a}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-cti-1 FAILED


==== 5.1.2-cti-2  char to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512cti2 {(int)'\uffff' == 0xffff}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-cti-2 FAILED


==== 5.1.2-cti-3  char to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512cti3 {(int)'\0' == 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-cti-3 FAILED


==== 5.1.2-cti-4  char to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512cti4 {(int)'\u7fff' == 0x7fff}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-cti-4 FAILED


==== 5.1.2-cti-5  char to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512cti5 {(int)'\u8000' == 0x8000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-cti-5 FAILED


==== 5.1.2-cti-6  char to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512cti6 {(int)'\177' == 0x7f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-cti-6 FAILED


==== 5.1.2-cti-7  char to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512cti7 {(int)'\200' == 0x80}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-cti-7 FAILED


==== 5.1.2-cti-8  char to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512cti8 {(int)'\377' == 0xff}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-cti-8 FAILED


==== 5.1.2-cti-9  char to int boundary case  FAILED
==== Contents of test case:

    constant_expression T512cti9 {(int)'\u0100' == 0x100}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-cti-9 FAILED


==== 5.1.2-ctl-1  char to long conversion never loses information  FAILED
==== Contents of test case:

    constant_expression T512ctl1 {(long)'\u789a' == 0x789aL}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctl-1 FAILED


==== 5.1.2-ctl-2  char to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctl2 {(long)'\uffff' == 0xffffL}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctl-2 FAILED


==== 5.1.2-ctl-3  char to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctl3 {(long)'\0' == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctl-3 FAILED


==== 5.1.2-ctl-4  char to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctl4 {(long)'\u7fff' == 0x7fffL}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctl-4 FAILED


==== 5.1.2-ctl-5  char to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctl5 {(long)'\u8000' == 0x8000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctl-5 FAILED


==== 5.1.2-ctl-6  char to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctl6 {(long)'\177' == 0x7fL}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctl-6 FAILED


==== 5.1.2-ctl-7  char to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctl7 {(long)'\200' == 0x80L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctl-7 FAILED


==== 5.1.2-ctl-8  char to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctl8 {(long)'\377' == 0xffL}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctl-8 FAILED


==== 5.1.2-ctl-9  char to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctl9 {(int)'\u0100' == 0x100L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctl-9 FAILED


==== 5.1.2-ctf-1  char to float conversion never loses information  FAILED
==== Contents of test case:

    constant_expression T512ctf1 {(float)'\u789a' == 30874.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctf-1 FAILED


==== 5.1.2-ctf-2  char to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctf2 {(float)'\uffff' == 65535.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctf-2 FAILED


==== 5.1.2-ctf-3  char to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctf3 {(float)'\0' == 0.0f}  {1/(float)'\0' == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctf-3 FAILED


==== 5.1.2-ctf-4  char to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctf4 {(float)'\u7fff' == 32767.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctf-4 FAILED


==== 5.1.2-ctf-5  char to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctf5 {(float)'\u8000' == 32768.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctf-5 FAILED


==== 5.1.2-ctf-6  char to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctf6 {(float)'\177' == 127.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctf-6 FAILED


==== 5.1.2-ctf-7  char to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctf7 {(float)'\200' == 128.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctf-7 FAILED


==== 5.1.2-ctf-8  char to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctf8 {(float)'\377' == 255.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctf-8 FAILED


==== 5.1.2-ctf-9  char to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctf9 {(float)'\u0100' == 256.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctf-9 FAILED


==== 5.1.2-ctd-1  char to double conversion never loses information  FAILED
==== Contents of test case:

    constant_expression T512ctd1 {(double)'\u789a' == 30874.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctd-1 FAILED


==== 5.1.2-ctd-2  char to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctd2 {(double)'\uffff' == 65535.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctd-2 FAILED


==== 5.1.2-ctd-3  char to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctd3 {(double)'\0' == 0.0}  {1/(double)'\0' == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctd-3 FAILED


==== 5.1.2-ctd-4  char to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctd4 {(double)'\u7fff' == 32767.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctd-4 FAILED


==== 5.1.2-ctd-5  char to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctd5 {(double)'\u8000' == 32768.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctd-5 FAILED


==== 5.1.2-ctd-6  char to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctd6 {(double)'\177' == 127.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctd-6 FAILED


==== 5.1.2-ctd-7  char to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctd7 {(double)'\200' == 128.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctd-7 FAILED


==== 5.1.2-ctd-8  char to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctd8 {(double)'\377' == 255.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctd-8 FAILED


==== 5.1.2-ctd-9  char to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ctd9 {(double)'\u0100' == 256.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ctd-9 FAILED


==== 5.1.2-itl-1  int to long conversion never loses information  FAILED
==== Contents of test case:

    constant_expression T512itl1 {(long)12345678 == 12345678L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itl-1 FAILED


==== 5.1.2-itl-2  int to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512itl2 {(long)Integer.MAX_VALUE == 0x7fffffffL}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itl-2 FAILED


==== 5.1.2-itl-3  int to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512itl3 {(long)0 == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itl-3 FAILED


==== 5.1.2-itl-4  int to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512itl4 {(long)Integer.MIN_VALUE == 0xffffffff80000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itl-4 FAILED


==== 5.1.2-itl-5  int to long boundary case  FAILED
==== Contents of test case:

    constant_expression T512itl5 {(long)-1 == 0xffffffffffffffffL}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itl-5 FAILED


==== 5.1.2-itf-1  int to float conversion may lose precision  FAILED
==== Contents of test case:

    constant_expression T512itf1 {1.23456792e8f == (float)123456789}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itf-1 FAILED


==== 5.1.2-itf-2  int to float conversion rounds down to nearest
        if remainder < .5 FAILED
==== Contents of test case:

    constant_expression T512itf2 {(float)0x7fffff3f == (float)0x7fffff00}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itf-2 FAILED


==== 5.1.2-itf-3  int to float conversion rounds up to nearest
        if remainder > .5 FAILED
==== Contents of test case:

    constant_expression T512itf3 {(float)0x70ffffc1 == (float)0x71000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itf-3 FAILED


==== 5.1.2-itf-4  int to float conversion rounds to least
        significant bit 0 if remainder = .5 FAILED
==== Contents of test case:

    constant_expression T512itf4 {(float)0x7fffff40 == (float)0x7fffff00}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itf-4 FAILED


==== 5.1.2-itf-5  int to float conversion rounds to least
        significant bit 0 if remainder = .5 FAILED
==== Contents of test case:

    constant_expression T512itf5 {(float)0x70ffffc0 == (float)0x71000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itf-5 FAILED


==== 5.1.2-itf-6  int to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512itf6 {(float)Integer.MAX_VALUE == 2.14748365E9f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itf-6 FAILED


==== 5.1.2-itf-7  int to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512itf7 {(float)0 == 0f} {1/(float)0 == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itf-7 FAILED


==== 5.1.2-itf-8  int to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512itf8 {(float)Integer.MIN_VALUE == -2.14748365E9f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itf-8 FAILED


==== 5.1.2-itf-9  int to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512itf9 {(float)-1 == -1.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itf-9 FAILED


==== 5.1.2-itd-1  int to double conversion never loses precision  FAILED
==== Contents of test case:

    constant_expression T512itd1 {123456789.0 == (double)123456789}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itd-1 FAILED


==== 5.1.2-itd-2  int to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512itd2 {(double)Integer.MAX_VALUE == 2.147483647E9}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itd-2 FAILED


==== 5.1.2-itd-3  int to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512itd3 {(double)0 == 0.0} {1/(double)0 == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itd-3 FAILED


==== 5.1.2-itd-4  int to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512itd4 {(double)Integer.MIN_VALUE == -2.147483648e9}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itd-4 FAILED


==== 5.1.2-itd-5  int to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512itd5 {(double)-1 == -1.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-itd-5 FAILED


==== 5.1.2-ltf-1  long to float conversion may lose precision  FAILED
==== Contents of test case:

    constant_expression T512ltf1 {1.23456792e8f == (float)123456789L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-1 FAILED


==== 5.1.2-ltf-2  long to float conversion rounds down to nearest
        if remainder < .5 FAILED
==== Contents of test case:

    constant_expression T512ltf2 {(float)0x7fffff3fL == (float)0x7fffff00L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-2 FAILED


==== 5.1.2-ltf-3  long to float conversion rounds up to nearest if
        remainder > .5 FAILED
==== Contents of test case:

    constant_expression T512ltf3 {(float)0x7fffffc1L == (float)0x80000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-3 FAILED


==== 5.1.2-ltf-4  long to float conversion rounds to least
        significant bit 0 if remainder = .5 FAILED
==== Contents of test case:

    constant_expression T512ltf4 {(float)0x7fffff40L == (float)0x7fffff00L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-4 FAILED


==== 5.1.2-ltf-5  long to float conversion rounds to least
        significant bit 0 if remainder = .5 FAILED
==== Contents of test case:

    constant_expression T512ltf5 {(float)0x7fffffc0L == (float)0x80000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-5 FAILED


==== 5.1.2-ltf-6  long to float conversion rounds down to
        nearest if remainder < .5 FAILED
==== Contents of test case:

    constant_expression T512ltf6  {(float)0xffffff7ffffffbfL == (float)0xffffff000000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-6 FAILED


==== 5.1.2-ltf-7  long to float conversion rounds down to
        nearest if remainder < .5. Hardware FP  that rounds to 64-bit
        double precision before rounding to 32-bit single precision
        will fail for this test case  FAILED
==== Contents of test case:

    constant_expression T512ltf7  {(float)0xffffff7ffffffffL == (float)0xffffff000000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-7 FAILED


==== 5.1.2-ltf-8  long to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ltf8 {(float)Long.MAX_VALUE == 9.223372e18f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-8 FAILED


==== 5.1.2-ltf-9  long to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ltf9 {(float)0L == 0f} {1/(float)0L == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-9 FAILED


==== 5.1.2-ltf-10  long to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ltf10 {(float)Long.MIN_VALUE == -9.223372e18f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-10 FAILED


==== 5.1.2-ltf-11  long to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ltf11 {(float)-1L == -1.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-11 FAILED


==== 5.1.2-ltf-12  long to float conversion rounds up to nearest if
        remainder > .5 FAILED
==== Contents of test case:

    constant_expression T512ltf12  {(float)0x100000101L == (float)0x100000200L}  {(float)0x100000101L == 4.294968e9f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltf-12 FAILED


==== 5.1.2-ltd-1  long to double conversion may lose precision  FAILED
==== Contents of test case:

    constant_expression T512ltd1 {0x123456789abcde0L == (double)0x123456789abcde7L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltd-1 FAILED


==== 5.1.2-ltd-2  long to double conversion rounds down to nearest
        if remainder < .5 FAILED
==== Contents of test case:

    constant_expression T512ltd2 {(double)0xffffff7ffffffbfL == 0xffffff7ffffff80L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltd-2 FAILED


==== 5.1.2-ltd-3  long to double conversion rounds up to nearest
        if remainder > .5 FAILED
==== Contents of test case:

    constant_expression T512ltd3 {(double)0xffffff7ffffffc1L == 0xffffff800000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltd-3 FAILED


==== 5.1.2-ltd-4  long to double conversion rounds to least
        significant bit 0 if remainder = .5 FAILED
==== Contents of test case:

    constant_expression T512ltd4 {(double)0xffffff7ffffff40L == 0xffffff7ffffff00L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltd-4 FAILED


==== 5.1.2-ltd-5  long to double conversion rounds to least
        significant bit 0 if remainder = .5 FAILED
==== Contents of test case:

    constant_expression T512ltd5 {(double)0xffffff7ffffffc0L == 0xffffff800000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltd-5 FAILED


==== 5.1.2-ltd-6  long to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ltd6  {(double)Long.MAX_VALUE == 9.223372036854776e18}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltd-6 FAILED


==== 5.1.2-ltd-7  long to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ltd7 {(double)0L == 0f} {1/(double)0L == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltd-7 FAILED


==== 5.1.2-ltd-8  long to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ltd8  {(double)Long.MIN_VALUE == -9.223372036854776e18}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltd-8 FAILED


==== 5.1.2-ltd-9  long to float boundary case  FAILED
==== Contents of test case:

    constant_expression T512ltd9 {(double)-1L == -1.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ltd-9 FAILED


==== 5.1.2-ftd-1  float to double conversion never loses precision  FAILED
==== Contents of test case:

    constant_expression T512ftd1 {(double)1234567.75f == 1234567.75}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ftd-1 FAILED


==== 5.1.2-ftd-2  float to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ftd2  {(double)Float.MAX_VALUE == 3.4028234663852886e38}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ftd-2 FAILED


==== 5.1.2-ftd-3  float to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ftd3  {(double)Float.MIN_VALUE == 1.401298464324817e-45}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ftd-3 FAILED


==== 5.1.2-ftd-4  float to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ftd4 {(double)0f == 0.0}  {1/(double)0f == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ftd-4 FAILED


==== 5.1.2-ftd-5  float to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ftd5 {(double)-0f == -0.0}  {1/(double)-0f == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ftd-5 FAILED


==== 5.1.2-ftd-6  float to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ftd6  {(double)Float.POSITIVE_INFINITY == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ftd-6 FAILED


==== 5.1.2-ftd-7  float to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ftd7  {(double)Float.NEGATIVE_INFINITY == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ftd-7 FAILED


==== 5.1.2-ftd-8  float to double boundary case  FAILED
==== Contents of test case:

    constant_expression T512ftd8 {(double)Float.NaN != Double.NaN}  {(double)Float.NaN != (double)Float.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ftd-8 FAILED


==== 5.1.2-ftd-9  float to double on a negative  FAILED
==== Contents of test case:

    constant_expression T512ftd9 {(double)-12345.678f == -12345.677734375}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 5.1.2-ftd-9 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment

==== 16-static-3  A blank final field may only be assigned by
        simple name  FAILED
==== Contents of test case:

    empty_class T16s3 {
        static final int i;
        static {
            i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16-static-3 FAILED


==== 16-instance-3  A blank final field may only be assigned by
        simple name or this.name  FAILED
==== Contents of test case:

    empty_class T16i3 {
        final int i;
        {
            i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16-instance-3 FAILED


==== 16-instance-4  A blank final field may only be assigned by
        simple name or this.name  FAILED
==== Contents of test case:

    empty_class T16i4 {
        final int i;
        {
            this.i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16-instance-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/anonymous-classes

==== 16.5-anonymous-2  V is DA before an anonymous class iff V is
        DA after the class instance creation expression  FAILED
==== Contents of test case:

    empty_main T165a2 {
        final int v;
        v = 1;
        new Object() {
            int i = v;
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.5-anonymous-2 FAILED


==== 16.5-anonymous-3  V is DA before an anonymous class iff V is
        DA after the class instance creation expression  FAILED
==== Contents of test case:

    empty_class T165a3 {
        T165a3(int j) {}
        void foo() {
            final int v;
            new T165a3(v = 1) {
                int i = v;
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.5-anonymous-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/constructors-and-instance-initializers

==== 16.8-constructor-2  A blank final instance variable is DA
        after alternate constructor invocation  FAILED
==== Contents of test case:

    empty_class T168c2 {
        final int i;
        T168c2() {
            this(1);
        }
        T168c2(int j) {
            i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.8-constructor-2 FAILED


==== 16.8-constructor-3  A blank final instance variable is DA
        after superconstructor if it is DA after initializers  FAILED
==== Contents of test case:

    empty_class T168c3 {
        final int i;
        static {}
        Object o = new Object();
        T168c3() {
            i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.8-constructor-3 FAILED


==== 16.8-constructor-4  A blank final instance variable is DA
        after superconstructor if it is DA after initializers  FAILED
==== Contents of test case:

    empty_class T168c4 {
        final int i;
        Object o = new Integer(i = 1);
        T168c4() {
            i = 1;
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.8-constructor-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/expressions/assignment-expressions

==== 16.1.7-simple-definite-assignment-fail-1  V is DA after
        a=b iff either a is V or V is DA after b  FAILED
==== Contents of test case:

    empty_main T1617sdaf1 {
	int i, x;
	i = 1;
	x++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-simple-definite-assignment-fail-1 FAILED


==== 16.1.7-simple-definite-assignment-fail-5  V is DA before
        b iff V is DA after the subexpressions of a in a=b  FAILED
==== Contents of test case:

    empty_main T1617sdaf5 {
	int i, x;
	i = x;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-simple-definite-assignment-fail-5 FAILED


==== 16.1.7-simple-definite-assignment-fail-8  V is DA after
        boolean a=b when true iff V is DA after a=b  FAILED
==== Contents of test case:

    empty_main T1617sdaf8 {
	boolean b;
	int x;
	if (b = false)
	    x++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-simple-definite-assignment-fail-8 FAILED


==== 16.1.7-simple-definite-assignment-fail-9  V is DA after
        boolean a=b when false iff V is DA after a=b  FAILED
==== Contents of test case:

    empty_main T1617sdaf9 {
	boolean b;
	int x;
	if (b = true);
	else x++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-simple-definite-assignment-fail-9 FAILED


==== 16.1.7-compound-definite-assignment-fail-1  V is DA after
        a<op>=b iff either a is V or V is DA after b  FAILED
==== Contents of test case:

    empty_main T1617cdaf1 {
	int i = 0, x;
	i += 1;
	x++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-compound-definite-assignment-fail-1 FAILED


==== 16.1.7-compound-definite-assignment-fail-5  V is DA before
        b iff V is DA after the subexpressions of a in a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdaf5 {
	int i = 0, x;
	i += x;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-compound-definite-assignment-fail-5 FAILED


==== 16.1.7-compound-definite-assignment-fail-8  V is DA after
        boolean a<op>=b when true iff V is DA after a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdaf8 {
	boolean b = false;
	int x;
	if (b &= false)
	    x++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-compound-definite-assignment-fail-8 FAILED


==== 16.1.7-compound-definite-assignment-fail-9  V is DA after
        boolean a<op>=b when false iff V is DA after a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdaf9 {
	boolean b = true;
	int x;
	if (b |= true);
	else x++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-compound-definite-assignment-fail-9 FAILED


==== 16.1.7-compound-definite-assignment-fail-10  V must be DA
        before a if V is a in a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdaf10 {
	int x;
	x += 0;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-compound-definite-assignment-fail-10 FAILED


==== 16.1.7-compound-definite-assignment-fail-11  V must be DA
        before a if V is a in a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdaf11 {
	int x;
	x += x = 0;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.7-compound-definite-assignment-fail-11 FAILED


==== 16.1.7-simple-definite-assignment-pass-3  V is DA before
        the subexpressions of a iff V is DA before a=b  FAILED
==== Contents of test case:

    empty_main T1617sdap3 {
	int ia[] = {0}, i, x = 0;
	ia[i = x]++;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-assignment-pass-3 FAILED


==== 16.1.7-simple-definite-assignment-pass-4  V is DA before
        the subexpressions of a iff V is DA before a=b  FAILED
==== Contents of test case:

    empty_class T1617sdap4 {
	T1617sdap4 t;
        void foo() {
            T1617sdap4 x = null;
	    x.t = x;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-assignment-pass-4 FAILED


==== 16.1.7-simple-definite-assignment-pass-6  V is DA before
        b iff V is DA after the subexpressions of a in a=b  FAILED
==== Contents of test case:

    empty_main T1617sdap6 {
	int ia[] = {0}, x;
	ia[true ? x = 0 : 0] = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-assignment-pass-6 FAILED


==== 16.1.7-simple-definite-assignment-pass-7  V is DA before
        b iff V is DA after the subexpressions of a in a=b  FAILED
==== Contents of test case:

    empty_class T1617sdap7 {
        T1617sdap7 t;
        void foo() {
            T1617sdap7 x;
	    (true ? x = new T1617sdap7() : null).t = x;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-assignment-pass-7 FAILED


==== 16.1.7-simple-definite-assignment-pass-8  V is DA after
        boolean a=b when true iff V is DA after a=b  FAILED
==== Contents of test case:

    empty_main T1617sdap8 {
	boolean b;
	int x;
	if ((b = false) && false)
	    x++;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-assignment-pass-8 FAILED


==== 16.1.7-simple-definite-assignment-pass-9  V is DA after
        boolean a=b when false iff V is DA after a=b  FAILED
==== Contents of test case:

    empty_main T1617sdap9 {
	boolean b;
	int x;
	if ((b = true) || true);
	else x++;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-assignment-pass-9 FAILED


==== 16.1.7-compound-definite-assignment-pass-3  V is DA before
        the subexpressions of a iff V is DA before a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdap3 {
	int ia[] = {0}, i = 0, x = 0;
	ia[i += x]++;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-assignment-pass-3 FAILED


==== 16.1.7-compound-definite-assignment-pass-4  V is DA before
        the subexpressions of a iff V is DA before a<op>=b  FAILED
==== Contents of test case:

    empty_class T1617cdap4 {
	String s;
	void foo() {
            T1617cdap4 x = null;
	    x.s += x;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-assignment-pass-4 FAILED


==== 16.1.7-compound-definite-assignment-pass-6  V is DA before
        b iff V is DA after the subexpressions of a in a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdap6 {
	int ia[] = {0}, x;
	ia[true ? x = 0 : 0] += x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-assignment-pass-6 FAILED


==== 16.1.7-compound-definite-assignment-pass-7  V is DA before
        b iff V is DA after the subexpressions of a in a<op>=b  FAILED
==== Contents of test case:

    empty_class T1617cdap7 {
	String s;
	void foo() {
            T1617cdap7 x;
	    (true ? x = new T1617cdap7() : null).s += x;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-assignment-pass-7 FAILED


==== 16.1.7-compound-definite-assignment-pass-8  V is DA after
        boolean a<op>=b when true iff V is DA after a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdap8 {
	boolean b = false;
	int x;
	if ((b &= false) && false)
	    x++;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-assignment-pass-8 FAILED


==== 16.1.7-compound-definite-assignment-pass-9  V is DA after
        boolean a<op>=b when false iff V is DA after a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdap9 {
	boolean b = true;
	int x;
	if ((b |= true) || true);
	else x++;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-assignment-pass-9 FAILED


==== 16.1.7-simple-definite-unassignment-pass-1  a blank final
        V must be DU before a=b if V is a  FAILED
==== Contents of test case:

    empty_main T1617sdup1 {
	final int x;
	x = 1;
	if (false) {
	    x = 1;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-unassignment-pass-1 FAILED


==== 16.1.7-simple-definite-unassignment-pass-2  V is DU after
        a=b iff both a is not V and V is DU after b  FAILED
==== Contents of test case:

    empty_main T1617sdup2 {
	final int x;
	int i;
	i = 1;
	x = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-unassignment-pass-2 FAILED


==== 16.1.7-simple-definite-unassignment-pass-3  V is DU before
        the subexpressions of a iff V is DU before a=b  FAILED
==== Contents of test case:

    empty_main T1617sdup3 {
	final int x;
	int ia[] = {0}, i = 0;
	ia[x = i]++;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-unassignment-pass-3 FAILED


==== 16.1.7-simple-definite-unassignment-pass-4  V is DU before
        the subexpressions of a iff V is DU before a=b  FAILED
==== Contents of test case:

    empty_class T1617sdup4 {
	final T1617sdup4 x;
	int i;
	{
	    (x = new T1617sdup4()).i++;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-unassignment-pass-4 FAILED


==== 16.1.7-simple-definite-unassignment-pass-5  V is DU before
        b iff V is DU after the subexpressions of a in a=b  FAILED
==== Contents of test case:

    empty_main T1617sdup5 {
	final int x;
	int i = 0;
	i = x = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-unassignment-pass-5 FAILED


==== 16.1.7-simple-definite-unassignment-pass-6  V is DU after
        boolean a=b when true iff V is DU after a=b  FAILED
==== Contents of test case:

    empty_main T1617sdup6 {
	boolean b;
	final int x;
	x = 0;
	if ((b = false) && false)
	    x = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-unassignment-pass-6 FAILED


==== 16.1.7-simple-definite-unassignment-pass-7  V is DU after
        boolean a=b when false iff V is DU after a=b  FAILED
==== Contents of test case:

    empty_main T1617sdup7 {
	boolean b;
	final int x;
	x = 0;
	if ((b = true) || true);
	else x = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-unassignment-pass-7 FAILED


==== 16.1.7-simple-definite-unassignment-pass-8  V must be DU
        after b if V is a blank final and V is a in a=b  FAILED
==== Contents of test case:

    empty_main T1617sdup8 {
	final int x;
	int i;
	x = i = 10;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-simple-definite-unassignment-pass-8 FAILED


==== 16.1.7-compound-definite-unassignment-pass-1  a blank final
        V must be DU before a<op>=b if V is a  FAILED
==== Contents of test case:

    empty_main T1617cdup1 {
	final int x;
	if (false) {
	    x += 1;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-unassignment-pass-1 FAILED


==== 16.1.7-compound-definite-unassignment-pass-2  V is DU after
        a<op>=b iff both a is not V and V is DU after b  FAILED
==== Contents of test case:

    empty_main T1617cdup2 {
	final int x;
	int i = 0;
	i += 1;
	x = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-unassignment-pass-2 FAILED


==== 16.1.7-compound-definite-unassignment-pass-3  V is DU before
        the subexpressions of a iff V is DU before a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdup3 {
	final int x;
	int ia[] = {0}, i = 0;
	ia[x = i] += 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-unassignment-pass-3 FAILED


==== 16.1.7-compound-definite-unassignment-pass-4  V is DU before
        the subexpressions of a iff V is DU before a<op>=b  FAILED
==== Contents of test case:

    empty_class T1617cdup4 {
	final T1617cdup4 x;
	int i;
	{
	    (x = new T1617cdup4()).i += 1;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-unassignment-pass-4 FAILED


==== 16.1.7-compound-definite-unassignment-pass-5  V is DU before
        b iff V is DU after the subexpressions of a in a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdup5 {
	final int x;
	int i = 0;
	i += x = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-unassignment-pass-5 FAILED


==== 16.1.7-compound-definite-unassignment-pass-6  V is DU after
        boolean a<op>=b when true iff V is DU after a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdup6 {
	boolean b = false;
	final int x;
	x = 0;
	if ((b &= false) && false)
	    x = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-unassignment-pass-6 FAILED


==== 16.1.7-compound-definite-unassignment-pass-7  V is DU after
        boolean a<op>=b when false iff V is DU after a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdup7 {
	boolean b = true;
	final int x;
	x = 0;
	if ((b |= true) || true);
	else x = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-unassignment-pass-7 FAILED


==== 16.1.7-compound-definite-unassignment-pass-8  V must be DU
        after b if V is a blank final and V is a in a<op>=b  FAILED
==== Contents of test case:

    empty_main T1617cdup8 {
	final int x;
	int i = 0;
	x = i += 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.7-compound-definite-unassignment-pass-8 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/expressions/boolean-conditional-and

==== 16.1.2-definite-assignment-pass-1  V is DA after a && b when
        true iff V is DA after b when true  FAILED
==== Contents of test case:

    empty_main T1612dap1 {
        boolean x, y = true;
        if (y && false)
            y = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-assignment-pass-1 FAILED


==== 16.1.2-definite-assignment-pass-2  V is DA after a && b when
        true iff V is DA after b when true  FAILED
==== Contents of test case:

    empty_main T1612dap2 {
        boolean x, y = true;
        if (false && y)
            y = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-assignment-pass-2 FAILED


==== 16.1.2-definite-assignment-pass-3  V is DA after a && b when
        false iff V is DA after a when false and V is DA after b when false  FAILED
==== Contents of test case:

    empty_main T1612dap3 {
        boolean x, y = true;
        if (true && (true ? true : y));
        else y = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-assignment-pass-3 FAILED


==== 16.1.2-definite-assignment-pass-4  V is DA before a iff V is
        DA before a && b  FAILED
==== Contents of test case:

    empty_main T1612dap4 {
        boolean x = false;
        boolean y = x && true;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-assignment-pass-4 FAILED


==== 16.1.2-definite-assignment-pass-5  V is DA before b iff V is
        DA after a when true  FAILED
==== Contents of test case:

    empty_main T1612dap5 {
        boolean x;
        boolean y = false && x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-assignment-pass-5 FAILED


==== 16.1.2-definite-assignment-pass-6  V is DA after a && b iff
        V is DA after a && b when true and when false  FAILED
==== Contents of test case:

    empty_main T1612dap6 {
        boolean x, y = true;
        y = (x = true) && y;
        y = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-assignment-pass-6 FAILED


==== 16.1.2-definite-unassignment-pass-1  V is DU after a && b when
        true iff V is DU after b when true  FAILED
==== Contents of test case:

    empty_main T1612dup1 {
        final boolean x;
        if ((x = true) && false)
            x = true;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-unassignment-pass-1 FAILED


==== 16.1.2-definite-unassignment-pass-2  V is DU after a && b when
        false iff V is DU after a when false and V is DU after b when false  FAILED
==== Contents of test case:

    empty_main T1612dup2 {
        final boolean x;
        if (true && ((x = false) || true));
        else x = true;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-unassignment-pass-2 FAILED


==== 16.1.2-definite-unassignment-pass-3  V is DU before a iff V is
        DU before a && b  FAILED
==== Contents of test case:

    empty_main T1612dup3 {
        final boolean x;
        boolean y = (x = true) && true;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-unassignment-pass-3 FAILED


==== 16.1.2-definite-unassignment-pass-4  V is DU before b iff V is
        DU after a when true  FAILED
==== Contents of test case:

    empty_main T1612dup4 {
        final boolean x;
        x = true;
        boolean y = false && (x = false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-unassignment-pass-4 FAILED


==== 16.1.2-definite-unassignment-pass-5  V is DU after a && b iff
        V is DU after a && b when true and when false  FAILED
==== Contents of test case:

    empty_main T1612dup5 {
        final boolean x;
        boolean y = false;
        y = true && y;
        x = y;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.2-definite-unassignment-pass-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/expressions/boolean-conditional-operator

==== 16.1.5-definite-assignment-pass-1  V is DA before
        a iff V is DA before boolean a?b:c  FAILED
==== Contents of test case:

    empty_main T1615dap1 {
	boolean x = true;
	if (x ? true : false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-1 FAILED


==== 16.1.5-definite-assignment-pass-2  V is DA before
        b iff V is DA after a when true  FAILED
==== Contents of test case:

    empty_main T1615dap2 {
	boolean a = true, x = true;
	if (a ? x : false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-2 FAILED


==== 16.1.5-definite-assignment-pass-3  V is DA before
        b iff V is DA after a when true  FAILED
==== Contents of test case:

    empty_main T1615dap3 {
	boolean x = true;
	if (true ? x : false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-3 FAILED


==== 16.1.5-definite-assignment-pass-4  V is DA before
        b iff V is DA after a when true  FAILED
==== Contents of test case:

    empty_main T1615dap4 {
	boolean x;
	if (false ? x : false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-4 FAILED


==== 16.1.5-definite-assignment-pass-5  V is DA before
        b iff V is DA after a when true  FAILED
==== Contents of test case:

    empty_main T1615dap5 {
	boolean x;
	if ((x = true) ? x : false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-5 FAILED


==== 16.1.5-definite-assignment-pass-6  V is DA before
        c iff V is DA after a when false  FAILED
==== Contents of test case:

    empty_main T1615dap6 {
	boolean a = true, x = true;
	if (a ? true : x);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-6 FAILED


==== 16.1.5-definite-assignment-pass-7  V is DA before
        c iff V is DA after a when false  FAILED
==== Contents of test case:

    empty_main T1615dap7 {
	boolean x = true;
	if (false ? true : x);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-7 FAILED


==== 16.1.5-definite-assignment-pass-8  V is DA before
        c iff V is DA after a when false  FAILED
==== Contents of test case:

    empty_main T1615dap8 {
	boolean x;
	if (true ? true : x);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-8 FAILED


==== 16.1.5-definite-assignment-pass-9  V is DA before
        c iff V is DA after a when false  FAILED
==== Contents of test case:

    empty_main T1615dap9 {
	boolean x;
	if ((x = false) ? true : x);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-9 FAILED


==== 16.1.5-definite-assignment-pass-10  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap10 {
	boolean a = true, x = true;
	if (a ? true : true)
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-10 FAILED


==== 16.1.5-definite-assignment-pass-11  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap11 {
	boolean a = true, x;
	if (a ? false : (x = true))
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-11 FAILED


==== 16.1.5-definite-assignment-pass-12  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap12 {
	boolean a, x;
	if (true ? false : (x = true))
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-12 FAILED


==== 16.1.5-definite-assignment-pass-13  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap13 {
	boolean a = false, x;
	if (a ? x = true : false)
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-13 FAILED


==== 16.1.5-definite-assignment-pass-14  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap14 {
	boolean a, x;
	if (false ? x = true : false)
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-14 FAILED


==== 16.1.5-definite-assignment-pass-15  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap15 {
	boolean a = true, x;
	if (a ? x = true : (x = true))
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-15 FAILED


==== 16.1.5-definite-assignment-pass-16  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap16 {
	boolean a, x;
	if (true ? x = true : (x = true))
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-16 FAILED


==== 16.1.5-definite-assignment-pass-17  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap17 {
	boolean a = true, x;
	if (false ? x = true : (x = true))
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-17 FAILED


==== 16.1.5-definite-assignment-pass-18  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap18 {
	boolean a, x;
	if (true ? x = true : true)
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-18 FAILED


==== 16.1.5-definite-assignment-pass-19  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap19 {
	boolean a, x;
	if (false ? true : (x = true))
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-19 FAILED


==== 16.1.5-definite-assignment-pass-20  V is DA after
        boolean a?b:c when true iff V is DA after b when true
        and V is DA after c when true  FAILED
==== Contents of test case:

    empty_main T1615dap20 {
	boolean a, x;
	if ((x = true) ? true : true)
	    a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-20 FAILED


==== 16.1.5-definite-assignment-pass-21  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap21 {
	boolean a = true, x = true;
	if (a ? false : false);
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-21 FAILED


==== 16.1.5-definite-assignment-pass-22  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap22 {
	boolean a = true, x;
	if (a ? true : (x = false));
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-22 FAILED


==== 16.1.5-definite-assignment-pass-23  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap23 {
	boolean a, x;
	if (true ? true : (x = false));
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-23 FAILED


==== 16.1.5-definite-assignment-pass-24  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap24 {
	boolean a = false, x;
	if (a ? x = false : true);
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-24 FAILED


==== 16.1.5-definite-assignment-pass-25  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap25 {
	boolean a, x;
	if (false ? x = false : true);
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-25 FAILED


==== 16.1.5-definite-assignment-pass-26  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap26 {
	boolean a = true, x;
	if (a ? x = false : (x = false));
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-26 FAILED


==== 16.1.5-definite-assignment-pass-27  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap27 {
	boolean a, x;
	if (true ? x = false : (x = false));
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-27 FAILED


==== 16.1.5-definite-assignment-pass-28  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap28 {
	boolean a = true, x;
	if (false ? x = false : (x = false));
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-28 FAILED


==== 16.1.5-definite-assignment-pass-29  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap29 {
	boolean a, x;
	if (true ? x = false : false);
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-29 FAILED


==== 16.1.5-definite-assignment-pass-30  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap30 {
	boolean a, x;
	if (false ? false : (x = false));
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-30 FAILED


==== 16.1.5-definite-assignment-pass-31  V is DA after
        boolean a?b:c when false iff V is DA after b when false
        and V is DA after c when false  FAILED
==== Contents of test case:

    empty_main T1615dap31 {
	boolean a, x;
	if ((x = false) ? false : false);
	else a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-31 FAILED


==== 16.1.5-definite-assignment-pass-32  V is DA after
        boolean a?b:c iff V is DA after boolean a?b:c when true
        and V is DA after boolean a?b:c when false  FAILED
==== Contents of test case:

    empty_main T1615dap32 {
	boolean a = true, x = true;
	if (a ? true : true);
	a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-32 FAILED


==== 16.1.5-definite-assignment-pass-33  V is DA after
        boolean a?b:c iff V is DA after boolean a?b:c when true
        and V is DA after boolean a?b:c when false  FAILED
==== Contents of test case:

    empty_main T1615dap33 {
	boolean a, x;
	if ((x = true) ? true : true);
	a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-33 FAILED


==== 16.1.5-definite-assignment-pass-34  V is DA after
        boolean a?b:c iff V is DA after boolean a?b:c when true
        and V is DA after boolean a?b:c when false  FAILED
==== Contents of test case:

    empty_main T1615dap34 {
	boolean a = true, x;
	if (a ? x = true : (x = true));
	a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-34 FAILED


==== 16.1.5-definite-assignment-pass-35  V is DA after
        boolean a?b:c iff V is DA after boolean a?b:c when true
        and V is DA after boolean a?b:c when false  FAILED
==== Contents of test case:

    empty_main T1615dap35 {
	boolean a, x;
	if (true ? x = true : false);
	a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-35 FAILED


==== 16.1.5-definite-assignment-pass-36  V is DA after
        boolean a?b:c iff V is DA after boolean a?b:c when true
        and V is DA after boolean a?b:c when false  FAILED
==== Contents of test case:

    empty_main T1615dap36 {
	boolean a, x;
	if (false ? true : (x = true));
	a = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-assignment-pass-36 FAILED


==== 16.1.5-definite-unassignment-pass-1  V is DU before
        a iff V is DU before boolean a?b:c  FAILED
==== Contents of test case:

    empty_main T1615dup1 {
	final boolean x;
	if ((x = true) ? true : false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-unassignment-pass-1 FAILED


==== 16.1.5-definite-unassignment-pass-2  V is DU before
        b iff V is DU after a when true  FAILED
==== Contents of test case:

    empty_main T1615dup2 {
	final boolean x;
	boolean a = true;
	if (a ? x = true : false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-unassignment-pass-2 FAILED


==== 16.1.5-definite-unassignment-pass-3  V is DU before
        b iff V is DU after a when true  FAILED
==== Contents of test case:

    empty_main T1615dup3 {
	final boolean x;
	if (true ? x = true : false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-unassignment-pass-3 FAILED


==== 16.1.5-definite-unassignment-pass-4  V is DU before
        b iff V is DU after a when true  FAILED
==== Contents of test case:

    empty_main T1615dup4 {
	final boolean x;
	x = true;
	if (false ? x = true : false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-unassignment-pass-4 FAILED


==== 16.1.5-definite-unassignment-pass-5  V is DU before
        c iff V is DU after a when false  FAILED
==== Contents of test case:

    empty_main T1615dup5 {
	final boolean x;
	boolean a = true;
	if (a ? true : (x = true));
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-unassignment-pass-5 FAILED


==== 16.1.5-definite-unassignment-pass-6  V is DU before
        c iff V is DU after a when false  FAILED
==== Contents of test case:

    empty_main T1615dup6 {
	final boolean x;
	if (false ? true : (x = true));
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-unassignment-pass-6 FAILED


==== 16.1.5-definite-unassignment-pass-7  V is DU before
        c iff V is DU after a when false  FAILED
==== Contents of test case:

    empty_main T1615dup7 {
	final boolean x;
	x = true;
	if (true ? true : (x = true));
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.5-definite-unassignment-pass-7 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/expressions/boolean-conditional-or

==== 16.1.3-definite-assignment-pass-1  V is DA after a || b when
        false iff V is DA after b when false  FAILED
==== Contents of test case:

    empty_main T1613dap1 {
        boolean x, y = false;
        if (y || true);
        else y = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-assignment-pass-1 FAILED


==== 16.1.3-definite-assignment-pass-2  V is DA after a || b when
        false iff V is DA after b when false  FAILED
==== Contents of test case:

    empty_main T1613dap2 {
        boolean x, y = false;
        if (true || y);
        else y = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-assignment-pass-2 FAILED


==== 16.1.3-definite-assignment-pass-3  V is DA after a || b when
        true iff V is DA after a when true and V is DA after b when true  FAILED
==== Contents of test case:

    empty_main T1613dap3 {
        boolean x, y = false;
        if (false || (false ? y : false))
            y = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-assignment-pass-3 FAILED


==== 16.1.3-definite-assignment-pass-4  V is DA before a iff V is
        DA before a || b  FAILED
==== Contents of test case:

    empty_main T1613dap4 {
        boolean x = true;
        boolean y = x || false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-assignment-pass-4 FAILED


==== 16.1.3-definite-assignment-pass-5  V is DA before b iff V is
        DA after a when false  FAILED
==== Contents of test case:

    empty_main T1613dap5 {
        boolean x;
        boolean y = true || x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-assignment-pass-5 FAILED


==== 16.1.3-definite-assignment-pass-6  V is DA after a || b iff
        V is DA after a || b when true and when false  FAILED
==== Contents of test case:

    empty_main T1613dap6 {
        boolean x, y = false;
        y = (x = false) || y;
        y = x;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-assignment-pass-6 FAILED


==== 16.1.3-definite-unassignment-pass-1  V is DU after a || b when
        false iff V is DU after b when false  FAILED
==== Contents of test case:

    empty_main T1613dup1 {
        final boolean x;
        if ((x = false) || true);
        else x = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-unassignment-pass-1 FAILED


==== 16.1.3-definite-unassignment-pass-2  V is DU after a || b when
        true iff V is DU after a when true and V is DU after b when true  FAILED
==== Contents of test case:

    empty_main T1613dup2 {
        final boolean x;
        if (false || ((x = true) && false))
            x = true;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-unassignment-pass-2 FAILED


==== 16.1.3-definite-unassignment-pass-3  V is DU before a iff V is
        DU before a || b  FAILED
==== Contents of test case:

    empty_main T1613dup3 {
        final boolean x;
        boolean y = (x = false) || false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-unassignment-pass-3 FAILED


==== 16.1.3-definite-unassignment-pass-4  V is DU before b iff V is
        DU after a when false  FAILED
==== Contents of test case:

    empty_main T1613dup4 {
        final boolean x;
        x = false;
        boolean y = true || (x = true);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-unassignment-pass-4 FAILED


==== 16.1.3-definite-unassignment-pass-5  V is DU after a || b iff
        V is DU after a || b when true and when false  FAILED
==== Contents of test case:

    empty_main T1613dup5 {
        final boolean x;
        boolean y = true;
        y = false || y;
        x = y;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.3-definite-unassignment-pass-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/expressions/operators-increment-and-decrement

==== 16.1.8-definite-assign-pass-2  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap2 {
	int i;
	if (false) {
            i--;
	    int j = i;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-2 FAILED


==== 16.1.8-definite-assign-pass-4  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap4 {
	int i;
	if (false) {
            --i;
	    int j = i;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-4 FAILED


==== 16.1.8-definite-assign-pass-5  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap5 {
	int i, j[] = {0};
	j[i = 0]++;
	int k = i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-5 FAILED


==== 16.1.8-definite-assign-pass-6  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap6 {
	int i, j[] = {0};
	j[i = 0]--;
	int k = i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-6 FAILED


==== 16.1.8-definite-assign-pass-7  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap7 {
	int i, j[] = {0};
	++j[i = 0];
	int k = i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-7 FAILED


==== 16.1.8-definite-assign-pass-8  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap8 {
	int i, j[] = {0};
	--j[i = 0];
	int k = i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-8 FAILED


==== 16.1.8-definite-assign-pass-9  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap9 {
	int[] j;
	(j = new int[] {0})[0]++;
	Object o = j;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-9 FAILED


==== 16.1.8-definite-assign-pass-10  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap10 {
	int[] j;
	(j = new int[] {0})[0]--;
	Object o = j;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-10 FAILED


==== 16.1.8-definite-assign-pass-11  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap11 {
	int[] j;
	++(j = new int[] {0})[0];
	Object o = j;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-11 FAILED


==== 16.1.8-definite-assign-pass-12  v is DA after a++ iff a is v
        or v is DA after a  FAILED
==== Contents of test case:

    empty_main T1618dap12 {
	int[] j;
	--(j = new int[] {0})[0];
	Object o = j;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.1.8-definite-assign-pass-12 FAILED


==== 16.1.8-definite-assign-fail-1  v is DA before a iff v is DA
        before a++  FAILED
==== Contents of test case:

    empty_main T1618daf1 {
	int i;
	i++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.8-definite-assign-fail-1 FAILED


==== 16.1.8-definite-assign-fail-3  v is DA before a iff v is DA
        before a++  FAILED
==== Contents of test case:

    empty_main T1618daf3 {
	int i;
	++i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.1.8-definite-assign-fail-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/statements/do-statements

==== 16.2.10-definite-unassign-pass-1  v is DU after the do if it
        is DU before every break which exits the do  FAILED
==== Contents of test case:

    empty_main T16210dup1 {
	final int i;
	boolean b = true;
	do {
	    if (b)
                break;
	    try {
		i = 1;
		break; // doesn't exit do
	    } finally {
		return;
	    }
	} while (true);
	i = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-1 FAILED


==== 16.2.10-definite-unassign-pass-2  v is DU before the condition
        if it is DU before every continue which exits the statement  FAILED
==== Contents of test case:

    empty_main T16210dup2 {
	final int i;
	do {
	    try {
		i = 2;
		continue; // doesn't continue loop
	    } finally {
		return;
	    }
	} while (true);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-2 FAILED


==== 16.2.10-definite-unassign-pass-3  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16210dup3 {
	final int i;
	do
	    if (false)
	        i = 1; // assignment not reachable
	while (true);
	// the fact that i is not DU before the loop doesn't matter
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-3 FAILED


==== 16.2.10-definite-unassign-pass-4  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16210dup4 {
	final int i;
	do
	    i = 1;
	while (false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-4 FAILED


==== 16.2.10-definite-unassign-pass-5  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16210dup5 {
	final int i;
	do {
	    i = 1;
	    break;
	} while (true);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-5 FAILED


==== 16.2.10-definite-unassign-pass-6  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16210dup6 {
	final boolean b;
	do;
	while ((b = true) && false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-6 FAILED


==== 16.2.10-definite-unassign-pass-7  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16210dup7 {
	final boolean b;
	do
	    continue;
	while ((b = true) && false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-7 FAILED


==== 16.2.10-definite-unassign-pass-8  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16210dup8 {
	final int i;
	boolean b = true;
	do
	    i = 1;
	while (b && false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-8 FAILED


==== 16.2.10-definite-unassign-pass-9  v is DU after do S while(e);
        iff v is DU after e when false and v is DU before every exiting
        break  FAILED
==== Contents of test case:

    empty_main T16210dup9 {
	final boolean b;
	b = true;
	do;
	while (b || true);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-9 FAILED


==== 16.2.10-definite-unassign-pass-10  variables declared in a
        loop may be assigned in the loop  FAILED
==== Contents of test case:

    empty_main T16210dup10 {
        do {
            final int i;
            i = 1;
            continue;
        } while (true);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-10 FAILED


==== 16.2.10-definite-unassign-pass-11  variables declared in a
        loop may be assigned in the loop  FAILED
==== Contents of test case:

    empty_main T16210dup11 {
        do {
            final int i;
            i = 1;
        } while (true);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-unassign-pass-11 FAILED


==== 16.2.10-definite-assign-pass-1  v is DA after do S while(e);
        iff v is DA after e when false and v is DA before every exiting
        break  FAILED
==== Contents of test case:

    empty_main T16210dap1 {
	int i;
	boolean b = true;
	do;
	while (b || true);
	int j = i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.10-definite-assign-pass-1 FAILED


==== 16.2.10-definite-assign-fail-1  v is DA after do S while(e);
        iff v is DA after e when false and v is DA before every exiting
        break  FAILED
==== Contents of test case:

    empty_main T16210daf1 {
	int i;
	do
	    break;
	while (true);
	int j = i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.10-definite-assign-fail-1 FAILED


==== 16.2.10-definite-assign-fail-2  v is DA after do S while(e);
        iff v is DA after e when false and v is DA before every exiting
        break  FAILED
==== Contents of test case:

    empty_main T16210daf2 {
	int i;
	boolean b;
	do
	    if (false)
	        break;
	while (b = true);
	int j = i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.10-definite-assign-fail-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/statements/for-statements

==== 16.2.11-definite-unassign-pass-1  v is DU after the for if it
        is DU before every break which exits the for  FAILED
==== Contents of test case:

    empty_main T16211dup1 {
	final int i;
	boolean b = true;
	for ( ; ; ) {
	    if (b)
	        break;
	    try {
		i = 1;
		break; // doesn't exit for
	    } finally {
		return;
	    }
	}
	i = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-1 FAILED


==== 16.2.11-definite-unassign-pass-2  v is DU before the condition
        if it is DU before every continue which exits the statement  FAILED
==== Contents of test case:

    empty_main T16211dup2 {
	final int i;
	for ( ; ; ) {
	    try {
		i = 2;
		continue; // doesn't continue loop
	    } finally {
		return;
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-2 FAILED


==== 16.2.11-definite-unassign-pass-3  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16211dup3 {
	final int i;
	for ( ; ; )
	    if (false)
	        i = 1; // assignment not reachable
	// the fact that i is not DU before the loop doesn't matter
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-3 FAILED


==== 16.2.11-definite-unassign-pass-4  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16211dup4 {
	for (final int i; ; ) {
	    i = 1;
	    break;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-4 FAILED


==== 16.2.11-definite-unassign-pass-5  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16211dup5 {
	for (final boolean b; (b = true) && false; );
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-5 FAILED


==== 16.2.11-definite-unassign-pass-6  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16211dup6 {
	for (final boolean b; b = true; )
	    break;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-6 FAILED


==== 16.2.11-definite-unassign-pass-7  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16211dup7 {
	for (final boolean b; true; b = true)
	    break;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-7 FAILED


==== 16.2.11-definite-unassign-pass-8  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T16211dup8 {
	boolean b = true;
	for (final int i; b && false; )
	    i = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-8 FAILED


==== 16.2.11-definite-unassign-pass-9  v is DU after a for statement
        iff v is DU after the (possibly implicit) condition when false and v
        is DU before every exiting break  FAILED
==== Contents of test case:

    empty_main T16211dup9 {
	final boolean b;
	for (b = true; b || true; );
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-9 FAILED


==== 16.2.11-definite-unassign-pass-10  variables declared in a
        loop may be assigned in the loop  FAILED
==== Contents of test case:

    empty_main T16211dup10 {
        for ( ; ; ) {
            final int i;
            i = 1;
            continue;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-10 FAILED


==== 16.2.11-definite-unassign-pass-11  variables declared in a
        loop may be assigned in the loop  FAILED
==== Contents of test case:

    empty_main T16211dup11 {
        for ( ; ; ) {
            final int i;
            i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-unassign-pass-11 FAILED


==== 16.2.11-definite-assign-pass-1  v is DA after a for statement
        iff v is DA after the (possibly implicit) condition when false and v
        is DA before every exiting break  FAILED
==== Contents of test case:

    empty_main T16211dap1 {
	int i;
	for (boolean b = true; b || true; );
	int j = i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.11-definite-assign-pass-1 FAILED


==== 16.2.11-definite-assign-fail-2  v is DA after a for statement
        iff v is DA after the (possibly implicit) condition when false and v
        is DA before every exiting break  FAILED
==== Contents of test case:

    empty_main T16211daf2 {
	int i;
	for ( ; ; )
	    break;
	int j = i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.11-definite-assign-fail-2 FAILED


==== 16.2.11-definite-assign-fail-3  v is DA after a for statement
        iff v is DA after the (possibly implicit) condition when false and v
        is DA before every exiting break  FAILED
==== Contents of test case:

    empty_main T16211daf3 {
	int i;
	for (boolean b; b = true; )
	    if (false)
	        break;
	int j = i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.11-definite-assign-fail-3 FAILED


==== 16.2.11-definite-assign-fail-4  v is DA after a for statement
        iff v is DA after the (possibly implicit) condition when false and v
        is DA before every exiting break  FAILED
==== Contents of test case:

    empty_main T16211daf4 {
	int i;
	for ( ; ; i = 1)
	    break;
	int j = i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.11-definite-assign-fail-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/statements/if-statements

==== 16.2.7-final-2  A blank final
        initialized inside an if (false) block is
        not definitely assigned.  FAILED
==== Contents of test case:


    compile [saveas T1627f2.java {
public class T1627f2 {
    final int val;

    T1627f2() {
        if (false) {
            val = 0;
        }
    }
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.7-final-2 FAILED


==== 16.2.7-final-3  A final variable
        must be definitely unassigned if it
        is to be assigned inside an if (true) block.  FAILED
==== Contents of test case:


    compile [saveas T1627f3.java {

public class T1627f3 {
    final int val = 0;

    T1627f3() {
        if (true) {
            val = 1;
        }
    }
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.7-final-3 FAILED


==== 16.2.7-final-4  A final variable
        must be definitely unassigned if it
        is to be assigned inside an if (false) block.  FAILED
==== Contents of test case:


    compile [saveas T1627f4.java {
public class T1627f4 {
    final int val = 0;

    T1627f4() {
        if (false) {
            val = 1;
        }
    }
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.7-final-4 FAILED


==== 16.2.7-final-5  A final variable
        must be definitely unassigned when an
        assignment to it occurs. A blank
        final assigned inside an if (true)
        block is definitely assigned, so
        a second assignment fails.  FAILED
==== Contents of test case:


    compile [saveas T1627f5.java {
public class T1627f5 {
    final int val;

    T1627f5() {
        if (true) {
            val = 1;
        }

        val = 0;
    }
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.7-final-5 FAILED


==== 16.2.7-final-6  A final variable
        must be definitely unassigned when an
        assignment to it occurs. A blank
        final assigned inside an if (false)
        block is not definitely assigned but
        it is also not definitely unassigned.  FAILED
==== Contents of test case:


    compile [saveas T1627f6.java {
public class T1627f6 {
    final int val;

    T1627f6() {
        if (false) {
            val = 1;
        }

        val = 0;
    }
}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.7-final-6 FAILED


==== 16.2.7-scope-1  A final variable in
        one scope should not effect a final variable
        in the enclosing scope  FAILED
==== Contents of test case:


    empty_main T1627s1 {
        if (true) {
          final int i = 1;
        }
        final int j;
        j = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.7-scope-1 FAILED


==== 16.2.7-scope-2  A final variable in
        one scope should not effect a final variable
        in the enclosing scope  FAILED
==== Contents of test case:


    empty_main T1627s2 {
        if (true) {
          final int i = 1;
        }
        final int i;
        i = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.7-scope-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/statements/labeled-statements

==== 16.2.5-definite-unassign-pass-1  V is DU after L:S iff V is DU
        after S and before all breaks in S that exit L  FAILED
==== Contents of test case:

    empty_main T1625dup1 {
	final int i;
	l: {
	    if (true)
	        break l;
	    try {
		i = 1;
		break l; // cannot exit l
	    } finally {
		return;
	    }
	}
	i = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.5-definite-unassign-pass-1 FAILED


==== 16.2.5-definite-unassign-pass-2  V is DU after L:S iff V is DU
        after S and before all breaks in S that exit L  FAILED
==== Contents of test case:

    empty_main T1625dup2 {
	final int i;
	l: {
	    if (false)
	        break l;
	    try {
		i = 1;
		break l; // cannot exit l
	    } finally {
		return;
	    }
	}
	i = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.5-definite-unassign-pass-2 FAILED


==== 16.2.5-definite-unassign-pass-3  V is DU after L:S iff V is DU
        after S and before all breaks in S that exit L  FAILED
==== Contents of test case:

    empty_main T1625dup3 {
	final int i;
	boolean b = true;
	l: {
	    if (b)
	        break l;
	    try {
		i = 1;
		break l; // cannot exit l
	    } finally {
		return;
	    }
	}
	i = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.5-definite-unassign-pass-3 FAILED


==== 16.2.5-definite-unassign-pass-4  V is DU after L:S iff V is DU
        after S and before all breaks in S that exit L  FAILED
==== Contents of test case:

    empty_main T1625dup4 {
	final int i;
	l: {}
	i = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.5-definite-unassign-pass-4 FAILED


==== 16.2.5-definite-assign-fail-1  V is DA after L:S iff V is DA
        after S and before all breaks in S that exit L  FAILED
==== Contents of test case:

    empty_main T1625daf1 {
	int i;
	l: break l;
	i++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.5-definite-assign-fail-1 FAILED


==== 16.2.5-definite-assign-fail-2  V is DA after L:S iff V is DA
        after S and before all breaks in S that exit L  FAILED
==== Contents of test case:

    empty_main T1625daf2 {
	int i;
	boolean b = true;
	l: {
	    if (b)
	        break l;
	    i = 1;
	}
	i++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.5-definite-assign-fail-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/statements/local-class-declaration-statements

==== 16.2.3-local-class-1  Combined with 16.6-8, v is DA before
        members of a local class if v is DA before the local class
        declaration  FAILED
==== Contents of test case:

    empty_main T1623lc1 {
        final int i = 1;
        class Local {
            int j = i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.3-local-class-1 FAILED


==== 16.2.3-local-class-2  Combined with 16.6-8, v is DA before
        members of a local class if v is DA before the local class
        declaration  FAILED
==== Contents of test case:

    empty_main T1623lc2 {
        final int i = "".length();
        class Local {
            int j = i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.3-local-class-2 FAILED


==== 16.2.3-local-class-3  Combined with 16.6-8, v is DA before
        members of a local class if v is DA before the local class
        declaration  FAILED
==== Contents of test case:

    empty_main T1623lc3 {
        final int i;
        i = 1;
        class Local {
            int j = i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.3-local-class-3 FAILED


==== 16.2.3-local-class-6  Combined with 16.6-8, v is DA before
        members of a local class if v is DA before the local class
        declaration  FAILED
==== Contents of test case:

    empty_main T1623lc6 {
        final int i = 1;
        class Local {
            int j = i;
        }
        new Local();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.3-local-class-6 FAILED


==== 16.2.3-local-class-7  Combined with 16.6-8, v is DA before
        members of a local class if v is DA before the local class
        declaration  FAILED
==== Contents of test case:

    empty_main T1623lc7 {
        final int i = "".length();
        class Local {
            int j = i;
        }
        new Local();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.3-local-class-7 FAILED


==== 16.2.3-local-class-8  Combined with 16.6-8, v is DA before
        members of a local class if v is DA before the local class
        declaration  FAILED
==== Contents of test case:

    empty_main T1623lc8 {
        final int i;
        i = 1;
        class Local {
            int j = i;
        }
        new Local();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.3-local-class-8 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/statements/switch-statements

==== 16.2.8-final-1  A blank final may be assigned in different block
        statement groups, provided it not assigned twice. Even with a
        non-constant initializer, the variable declaration is treated as
        a blank final  FAILED
==== Contents of test case:

    switch_labels T1628f1 int {
            case 0:
                final int j = "".length();
                break;
            case 1:
                j = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.8-final-1 FAILED


==== 16.2.8-final-2  A blank final may be assigned in different block
        statement groups, provided it not assigned twice  FAILED
==== Contents of test case:

    switch_labels T1628f2 int {
            case 0:
                final int b;
                b = 0;
                break;
            case 1:
                b = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.8-final-2 FAILED


==== 16.2.8-final-4  A blank final may not be referenced unless
        it is definitely assigned. However, a variable initialized with a
        constant is inlined, and is not a blank final.  FAILED
==== Contents of test case:

    switch_labels T1628f4 int {
            case 0:
                final byte b = 0;
                break;
            case 1:
                byte c = b;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.8-final-4 FAILED


==== 16.2.8-final-5  A final variable declared with a constant
        initializer qualifies as a constant, and may be used as a label  FAILED
==== Contents of test case:

    switch_labels T1628f5 int {
        case 0:
            final byte b = 1;
        case b:
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.8-final-5 FAILED


==== 16.2.8-unassigned-3  A variable that is not definitely assigned
        before entering the switch must be definitely assigned in each switch
        block if it is to be definitely assigned after the switch block  FAILED
==== Contents of test case:


    compile [saveas T1628u3.java {
class T1628u3 {
    void foo(int i) {
        int j;
        switch (i) {
            case 0: j = 0; break;
            case 1: break;
            default: j = 2; break;
        }
        j++;
    }
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.8-unassigned-3 FAILED


==== 16.2.8-unassigned-4  A variable that is not definitely assigned
        before entering the switch must be definitely assigned in each switch
        block (including the default block) if it is to be definitely assigned
        after the switch block  FAILED
==== Contents of test case:


    compile [saveas T1628u4.java {
class T1628u4 {
    void foo(int i) {
        int j;
        switch (i) {
            case 0: j = 0; break;
            case 1: j = 0; break;
        }
        j++;
    }
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.8-unassigned-4 FAILED


==== 16.2.8-unassigned-8  v is DU if it is DU before breaks which
        exit the switch  FAILED
==== Contents of test case:

    empty_main T1628u8 {
	int i = 1;
	final int j;
	switch (i) {
	    case 0:
	    try {
		j = 1;
		break; // doesn't exit switch
	    } finally {
		return;
	    }
	}
	j = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.8-unassigned-8 FAILED


==== 16.2.8-unassigned-9  v is DU if it is DU before breaks which
        exit the switch  FAILED
==== Contents of test case:

    empty_main T1628u9 {
	int i = 1;
	final int j;
	label: switch (i) {
	    case 0:
	    try {
		j = 1;
		break label; // doesn't exit switch
	    } finally {
		return;
	    }
	}
	j = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.8-unassigned-9 FAILED


==== 16.2.8-unassigned-11  v is DU after switch depends on default
       label or DU after switch expression  FAILED
==== Contents of test case:

   empty_main T1628u11 {
       final int i;
       switch (args.length) {}
       i = 2;
   }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.8-unassigned-11 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/statements/try-statements
leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/definite-assignment/statements/while-statements

==== 16.2.9-definite-unassign-pass-1  v is DU after the while if it
        is DU before every break which exits the while  FAILED
==== Contents of test case:

    empty_main T1629dup1 {
	final int i;
	boolean b = true;
	while (true) {
	    if (b)
	        break;
	    try {
		i = 1;
		break; // doesn't exit while
	    } finally {
		return;
	    }
	}
	i = 2;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-1 FAILED


==== 16.2.9-definite-unassign-pass-2  v is DU before the condition
        if it is DU before every continue which exits the statement  FAILED
==== Contents of test case:

    empty_main T1629dup2 {
	final int i;
	while (true) {
	    try {
		i = 2;
		continue; // doesn't continue loop
	    } finally {
		return;
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-2 FAILED


==== 16.2.9-definite-unassign-pass-3  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T1629dup3 {
	final int i;
	while (true)
	    if (false)
	        i = 1;
	// the fact that i is not DU before the loop doesn't matter
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-3 FAILED


==== 16.2.9-definite-unassign-pass-4  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T1629dup4 {
	final int i;
	while (true) {
	    i = 1;
	    break;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-4 FAILED


==== 16.2.9-definite-unassign-pass-5  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T1629dup5 {
	final boolean b;
	while ((b = true) && false);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-5 FAILED


==== 16.2.9-definite-unassign-pass-6  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T1629dup6 {
	final boolean b;
	while (b = true)
	    break;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-6 FAILED


==== 16.2.9-definite-unassign-pass-7  v may be reachably assigned
        in loop only once unless loop can't repeat  FAILED
==== Contents of test case:

    empty_main T1629dup7 {
	final int i;
	boolean b = true;
	while (b && false)
	    i = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-7 FAILED


==== 16.2.9-definite-unassign-pass-8  v is DU after while(e)S; iff
        v is DU after e when false and v is DU before every exiting break  FAILED
==== Contents of test case:

    empty_main T1629dup8 {
	final boolean b;
	b = true;
	while (b || true);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-8 FAILED


==== 16.2.9-definite-unassign-pass-9  variables declared in a
        loop may be assigned in the loop  FAILED
==== Contents of test case:

    empty_main T1629dup9 {
        while (true) {
            final int i;
            i = 1;
            continue;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-9 FAILED


==== 16.2.9-definite-unassign-pass-10  variables declared in a
        loop may be assigned in the loop  FAILED
==== Contents of test case:

    empty_main T1629dup10 {
        while (true) {
            final int i;
            i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-unassign-pass-10 FAILED


==== 16.2.9-definite-assign-pass-1  v is DA after while(e)S; iff
        v is DA after e when false and v is DA before every exiting break  FAILED
==== Contents of test case:

    empty_main T1629dap1 {
	int i;
	boolean b = true;
	while (b || true);
	int j = i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 16.2.9-definite-assign-pass-1 FAILED


==== 16.2.9-definite-assign-fail-2  v is DA after while(e)S; iff
        v is DA after e when false and v is DA before every exiting break  FAILED
==== Contents of test case:

    empty_main T1629daf2 {
	int i;
	while (true)
	    break;
	int j = i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.9-definite-assign-fail-2 FAILED


==== 16.2.9-definite-assign-fail-3  v is DA after while(e)S; iff
        v is DA after e when false and v is DA before every exiting break  FAILED
==== Contents of test case:

    empty_main T1629daf3 {
	int i;
	boolean b;
	while (b = true)
	    if (false)
	        break;
	int j = i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 16.2.9-definite-assign-fail-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/additive-operators

==== 15.18-null-1  at least one argument of + should be String,
        or else both must be primitive numeric type  FAILED
==== Contents of test case:

    # Sun seems to have relaxed this so that null is used as type String
    is_assignable_to T1518n1 String {null + null}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.18-null-1 FAILED


==== 15.18-null-2  both arguments to - must be of a
        primitive numeric type  FAILED
==== Contents of test case:

    is_assignable_to T1518n2 String {null - null}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.18-null-2 FAILED


==== 15.18-boolean-1  at least one argument of + should be String,
        or else both must be primitive numeric type  FAILED
==== Contents of test case:

    is_assignable_to T1518b1 boolean {true + false}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.18-boolean-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/additive-operators/numeric-types

==== 15.18.2-commute-1  side-effect-free addition is commutative  FAILED
==== Contents of test case:

    constant_expression T15182commute1 {1 + 2 == 2 + 1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-commute-1 FAILED


==== 15.18.2-commute-2  side-effect-free addition is commutative  FAILED
==== Contents of test case:

    constant_expression T15182commute2 {1L + 2L == 2L + 1L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-commute-2 FAILED


==== 15.18.2-commute-3  side-effect-free addition is commutative  FAILED
==== Contents of test case:

    constant_expression T15182commute3 {1f + 2f == 2f + 1f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-commute-3 FAILED


==== 15.18.2-commute-4  side-effect-free addition is commutative  FAILED
==== Contents of test case:

    constant_expression T15182commute4 {1d + 2d == 2d + 1d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-commute-4 FAILED


==== 15.18.2-assoc-1  integer addition is associative when
        all arguments are of the same type  FAILED
==== Contents of test case:

    constant_expression T15182assoc1 {(1 + 2) + 3 == 1 + (2 + 3)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-assoc-1 FAILED


==== 15.18.2-assoc-4  addition is left-associative  FAILED
==== Contents of test case:

    constant_expression T15182assoc3  {1e10f + 256f + 256f == (1e10f + 256f) + 256f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-assoc-4 FAILED


==== 15.18.2-int-1  overflow in integer addition simply 
        selects low-order bits, changing sign  FAILED
==== Contents of test case:

    constant_expression T15182i1 {1073741824 + 1073741824 == -2147483648}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-int-1 FAILED


==== 15.18.2-float-1  NaN + NaN is NaN  FAILED
==== Contents of test case:

    constant_expression T15182f1  {Float.NaN + Float.NaN != Float.NaN + Float.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-1 FAILED


==== 15.18.2-float-2  NaN + anything is NaN  FAILED
==== Contents of test case:

    constant_expression T15182f2 {Float.NaN + 1f != Float.NaN + 1f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-2 FAILED


==== 15.18.2-float-3  the result of floating-point addition follows
        arithmetic sign rules  FAILED
==== Contents of test case:

    constant_expression T15182f3 {-1f + -2f < 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-3 FAILED


==== 15.18.2-float-4  the result of floating-point addition follows
        arithmetic sign rules  FAILED
==== Contents of test case:

    constant_expression T15182f4 {-1.0f + 2.0f > 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-4 FAILED


==== 15.18.2-float-5  Infinity + 0 = Infinity  FAILED
==== Contents of test case:

    constant_expression T15182f5  {Float.POSITIVE_INFINITY + -0.0f == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-5 FAILED


==== 15.18.2-float-6  Infinity + finite = Same sign Infinity  FAILED
==== Contents of test case:

    constant_expression T15182f6  {Float.NEGATIVE_INFINITY + -1f == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-6 FAILED


==== 15.18.2-float-7  Sum of Infinities of same sign is Infinity  FAILED
==== Contents of test case:

    constant_expression T15182f7  {Float.NEGATIVE_INFINITY + Float.NEGATIVE_INFINITY ==
	    Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-7 FAILED


==== 15.18.2-float-8  Sum of Infinities of opposite sign is NaN  FAILED
==== Contents of test case:

    constant_expression T15182f8  {Float.NEGATIVE_INFINITY + Float.POSITIVE_INFINITY !=
	    Float.NEGATIVE_INFINITY + Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-8 FAILED


==== 15.18.2-float-9  Sum of zeroes of same sign is same zero  FAILED
==== Contents of test case:

    constant_expression T15182f9 {1.0f / (-0.0f + -0.0f) == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-9 FAILED


==== 15.18.2-float-10  Sum of zeroes of opposite sign is +0  FAILED
==== Contents of test case:

    constant_expression T15182f10 {1.0f / (-0.0f + 0.0f) == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-10 FAILED


==== 15.18.2-float-11  Sum of oppositely signed floating-point is +0  FAILED
==== Contents of test case:

    constant_expression T15182f11 {1.0f / (1.0f + -1.0f) == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-11 FAILED


==== 15.18.2-float-12  0.0 - x is not negation, for x = 0.0  FAILED
==== Contents of test case:

    constant_expression T15182f12 {1.0f / (0.0f - 0.0f) != Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-12 FAILED


==== 15.18.2-float-13  a - b == a + (-b)  FAILED
==== Contents of test case:

    constant_expression T15182f13 {1.0f - 2.0f == 1.0f + -2.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-13 FAILED


==== 15.18.2-float-14  Floating-point addition takes place with
        infinite accuracy, then rounds to nearest  FAILED
==== Contents of test case:

    constant_expression T15182f14 {0xfffff00 + 8.03125f == 0xfffff10}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-14 FAILED


==== 15.18.2-float-15  Floating-point addition takes place with
        infinite accuracy, then rounds to nearest  FAILED
==== Contents of test case:

    constant_expression T15182f15 {-0xfffff00 - -8.03125f == -0xffffef0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-15 FAILED


==== 15.18.2-float-16  Floating-point addition takes place with
        infinite accuracy, then rounds to nearest  FAILED
==== Contents of test case:

    constant_expression T15182f16 {5.960465e-8f + 1 == 1.0000001f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-float-16 FAILED


==== 15.18.2-double-1  NaN + NaN is NaN  FAILED
==== Contents of test case:

    constant_expression T15182d1  {Double.NaN + Double.NaN != Double.NaN + Double.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-1 FAILED


==== 15.18.2-double-2  NaN + anything is NaN  FAILED
==== Contents of test case:

    constant_expression T15182d2 {Double.NaN + 1d != Double.NaN + 1d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-2 FAILED


==== 15.18.2-double-3  the result of floating-point addition follows
        arithmetic sign rules  FAILED
==== Contents of test case:

    constant_expression T15182d3 {-1d + -2d < 0d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-3 FAILED


==== 15.18.2-double-4  the result of floating-point addition follows
        arithmetic sign rules  FAILED
==== Contents of test case:

    constant_expression T15182d4 {-1.0 + 2.0 > 0.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-4 FAILED


==== 15.18.2-double-5  Infinity + 0 = Infinity  FAILED
==== Contents of test case:

    constant_expression T15182d5  {Double.POSITIVE_INFINITY + 0d == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-5 FAILED


==== 15.18.2-double-6  Infinity + finite = Same sign Infinity  FAILED
==== Contents of test case:

    constant_expression T15182d6  {Double.NEGATIVE_INFINITY + -1d == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-6 FAILED


==== 15.18.2-double-7  Sum of Infinities of same sign is Infinity  FAILED
==== Contents of test case:

    constant_expression T15182d7  {Double.NEGATIVE_INFINITY + Double.NEGATIVE_INFINITY ==
	    Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-7 FAILED


==== 15.18.2-double-8  Sum of Infinities of opposite sign is NaN  FAILED
==== Contents of test case:

    constant_expression T15182d8  {Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY !=
	    Double.NEGATIVE_INFINITY + Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-8 FAILED


==== 15.18.2-double-9  Sum of zeroes of same sign is same zero  FAILED
==== Contents of test case:

    constant_expression T15182d9 {1.0 / (-0.0 + -0.0) == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-9 FAILED


==== 15.18.2-double-10  Sum of zeroes of opposite sign is +0  FAILED
==== Contents of test case:

    constant_expression T15182d10 {1.0 / (-0.0 + 0.0) == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-10 FAILED


==== 15.18.2-double-11  Sum of oppositely signed floating-point is +0  FAILED
==== Contents of test case:

    constant_expression T15182d11 {1.0 / (1.0 + -1.0) == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-11 FAILED


==== 15.18.2-double-12  0.0 - x is not negation, for x = 0.0  FAILED
==== Contents of test case:

    constant_expression T15182d12 {1.0 / (0.0 - 0.0) != Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-12 FAILED


==== 15.18.2-double-13  a - b == a + (-b)  FAILED
==== Contents of test case:

    constant_expression T15182d13 {1.0 - 2.0 == 1.0 + -2.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-13 FAILED


==== 15.18.2-double-14  Floating-point addition takes place with
        infinite accuracy, then rounds to nearest  FAILED
==== Contents of test case:

    constant_expression T15182d14 {0x1ffffffffffff00L + 8.03125 ==
        0x1ffffffffffff10L }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-14 FAILED


==== 15.18.2-double-15  Floating-point addition takes place with
        infinite accuracy, then rounds to nearest  FAILED
==== Contents of test case:

    constant_expression T15182d15 {-0x1ffffffffffff00L - -8.03125 ==
        -0x1fffffffffffef0L }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-15 FAILED


==== 15.18.2-double-16  Floating-point addition takes place with
        infinite accuracy, then rounds to nearest, use of 80-bit
        extended precision instead of 64-bit double precision will fail
        for this test case  FAILED
==== Contents of test case:

    constant_expression T15182d16 {1.1107651257113993e-16 + 1 ==
        1.0000000000000002}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-double-16 FAILED


==== 15.18.2-mixed-1  Test mixed type addition to 0 for proper
        optimization - jikes bug 3078  FAILED
==== Contents of test case:

    empty_class T15182m1 {
	void m(int i, long l, float f, double d) {
	    l = 0L + i;
	    l = i + 0L;
	    l = 0L - i;
	    l = i - 0L;

	    f = 0f + i;
	    f = i + 0f;
	    f = 0f - i;
	    f = i - 0f;
	    f = -0f + i;
	    f = i + -0f;
	    f = -0f - i;
	    f = i - -0f;

	    f = 0f + l;
	    f = l + 0f;
	    f = 0f - l;
	    f = l - 0f;
	    f = -0f + l;
	    f = l + -0f;
	    f = -0f - l;
	    f = l - -0f;

	    d = 0. + i;
	    d = i + 0.;
	    d = 0. - i;
	    d = i - 0.;
	    d = -0. + i;
	    d = i + -0.;
	    d = -0. - i;
	    d = i - -0.;

	    d = 0. + l;
	    d = l + 0.;
	    d = 0. - l;
	    d = l - 0.;
	    d = -0. + l;
	    d = l + -0.;
	    d = -0. - l;
	    d = l - -0.;

	    d = 0. + f;
	    d = f + 0.;
	    d = 0. - f;
	    d = f - 0.;
	    d = -0. + f;
	    d = f + -0.;
	    d = -0. - f;
	    d = f - -0.;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.2-mixed-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/additive-operators/string-concatenation-operator

==== 15.18.1-2  (String)null denotes String concatenation  FAILED
==== Contents of test case:

    is_assignable_to T151812 String {(String)null + 1} String {1 + (String)null}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-2 FAILED


==== 15.18.1-3  (String)null + null denotes String concatenation  FAILED
==== Contents of test case:

    is_assignable_to T151813  String {null + (String)null}  String {(String)null + null}  String {(String)null + (String)null}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-3 FAILED


==== 15.18.1-4  void + String is invalid  FAILED
==== Contents of test case:

    is_assignable_to T151814  String {System.out.println() + ""}  String {"" + System.out.println()}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.18.1-4 FAILED


==== 15.18.1-5  + operator should be left-associative  FAILED
==== Contents of test case:

    constant_expression T151815  {1 + 2 + " fiddlers" == "3 fiddlers"}  {"fiddlers " + 1 + 2 == "fiddlers 12"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-5 FAILED


==== 15.18.1-6  + operator and integer constants  FAILED
==== Contents of test case:

    constant_expression T151816  {"-12300000" == "" + -12300000}  {"-12300000" == -12300000 + ""}  {"-12300000,-50000000" ==
            -12300000 + "," + -50000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-6 FAILED


==== 15.18.1-7  + operator and long constants  FAILED
==== Contents of test case:

    constant_expression T151817  {"-12192592592745" == "" + -12192592592745L}  {"-12192592592745" == -12192592592745L + ""}  {"-12192592592745,-12192592592745" ==
            -12192592592745L + "," + -12192592592745L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-7 FAILED


==== 15.18.1-char-1  + operator and '\0' (2-byte UTF-8).  FAILED
==== Contents of test case:

    constant_expression T15181c1  {"\0" == "" + '\0'}  {"\0" == '\0' + ""}  {"\0,\0" == '\0' + "," + '\0'}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-char-1 FAILED


==== 15.18.1-char-2  + operator and 'a' (1-byte UTF-8).  FAILED
==== Contents of test case:

    constant_expression T15181c2  {"a" == "" + 'a'}  {"a" == 'a' + ""}  {"a,a" == 'a' + "," + 'a'}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-char-2 FAILED


==== 15.18.1-char-3  + operator and '\u0080' (2-byte UTF-8).  FAILED
==== Contents of test case:

    constant_expression T15181c3  {"\u0080" == "" + '\u0080'}  {"\u0080" == '\u0080' + ""}  {"\u0080,\u0080" == '\u0080' + "," + '\u0080'}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-char-3 FAILED


==== 15.18.1-char-4  + operator and '\uffff' (3-byte UTF-8).  FAILED
==== Contents of test case:

    constant_expression T15181c4  {"\uffff" == "" + '\uffff'}  {"\uffff" == '\uffff' + ""}  {"\uffff,\uffff" == '\uffff' + "," + '\uffff'}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-char-4 FAILED


==== 15.18.1-int-1  + operator and 0 constant  FAILED
==== Contents of test case:

    constant_expression T15181i1  {"0" == "" + 0}  {"0" == 0 + ""}  {"0,0" == 0 + "," + 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-int-1 FAILED


==== 15.18.1-long-1  + operator and 0L constant  FAILED
==== Contents of test case:

    constant_expression T15181l1  {"0" == "" + 0L}  {"0" == 0L + ""}  {"0,0" == 0L + "," + 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-long-1 FAILED


==== 15.18.1-float-1  convert denormalized float to String  FAILED
==== Contents of test case:

    constant_expression T15181f1 {"" + 1e-44f == "9.8E-45"}  {1e-44f + "" == "9.8E-45"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-1 FAILED


==== 15.18.1-float-2  convert NaN float to String  FAILED
==== Contents of test case:

    constant_expression T15181f2  {"" + Float.NaN == "NaN"} {"" + (-Float.NaN) == "NaN"}  {Float.NaN + "" == "NaN"} {(-Float.NaN) + "" == "NaN"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-2 FAILED


==== 15.18.1-float-3  convert Infinity float to String  FAILED
==== Contents of test case:

    constant_expression T15181f3  {"" + Float.NEGATIVE_INFINITY == "-Infinity"}  {"" + Float.POSITIVE_INFINITY == "Infinity"}  {Float.NEGATIVE_INFINITY + "" == "-Infinity"}  {Float.POSITIVE_INFINITY + "" == "Infinity"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-3 FAILED


==== 15.18.1-float-4  convert min float to String  FAILED
==== Contents of test case:

    constant_expression T15181f4  {"" +  Float.MIN_VALUE == "1.4E-45"}  {Float.MIN_VALUE + "" == "1.4E-45"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-4 FAILED


==== 15.18.1-float-5  convert max float to String  FAILED
==== Contents of test case:

    constant_expression T15181f5  {"" +  Float.MAX_VALUE == "3.4028235E38"}  {Float.MAX_VALUE + "" == "3.4028235E38"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-5 FAILED


==== 15.18.1-float-6  conversion of float to String must use as few
        digits after decimal as produce the same float again by rounding  FAILED
==== Contents of test case:

    constant_expression T15181f6  {"" + 123456768f == "1.2345677E8"}  {"" + 123456776f == "1.23456776E8"}  {"" + 123456784f == "1.2345678E8"}  {"" + 123456792f == "1.2345679E8"}  {"" + 123456800f == "1.234568E8"}  {123456768f + "" == "1.2345677E8"}  {123456776f + "" == "1.23456776E8"}  {123456784f + "" == "1.2345678E8"}  {123456792f + "" == "1.2345679E8"}  {123456800f + "" == "1.234568E8"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-6 FAILED


==== 15.18.1-float-7  conversion of float to String switches from
        plain to exponent at 1e7  FAILED
==== Contents of test case:

    constant_expression T15181f7  {"" + 9999999f == "9999999.0"}  {"" + 10000000f == "1.0E7"}  {9999999f + "" == "9999999.0"}  {10000000f + "" == "1.0E7"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-7 FAILED


==== 15.18.1-float-8  conversion of float to String switches from
        plain to exponent at 1e-3. Trailing 0's are not permitted.  FAILED
==== Contents of test case:

    constant_expression T15181f8  {"" + .001f == "0.001"}  {"" + .000999998f == "9.99998E-4"}  {.001f + "" == "0.001"}  {.000999998f + "" == "9.99998E-4"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-8 FAILED


==== 15.18.1-float-9  conversion of float to String produces the
        shortest string that parses back to the same float  FAILED
==== Contents of test case:

    constant_expression T15181f9  {"" + 9.9999998e22f == "1.0E23"}  {9.9999998e22f + "" == "1.0E23"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-9 FAILED


==== 15.18.1-float-10  One of the longest possible Strings
        possible when converting floats  FAILED
==== Contents of test case:

    constant_expression T15181f10  {"" + -1.00000126e-10f == "-1.00000126E-10"}  {-1.00000126e-10f + "" == "-1.00000126E-10"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-10 FAILED


==== 15.18.1-float-11  conversion of float to String prints the
        closest decimal string to the exact value, even on denorms  FAILED
==== Contents of test case:

    constant_expression T15181f11  {"" + 1e-43f == "9.9E-44"}  {1e-43f + "" == "9.9E-44"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-11 FAILED


==== 15.18.1-float-12  conversion of float to String must use as few
        digits after decimal as produce the same float again by rounding  FAILED
==== Contents of test case:

    constant_expression T15181f12  {"" + 4294967808f == "4.294968E9"}  {4294967808f + "" == "4.294968E9"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-float-12 FAILED


==== 15.18.1-double-1  convert denormalized double to String  FAILED
==== Contents of test case:

    constant_expression T15181d1  {"" + 1e-315 == "1.0E-315"}  {1e-315 + "" == "1.0E-315"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-1 FAILED


==== 15.18.1-double-2  convert Nan double to String  FAILED
==== Contents of test case:

    constant_expression T15181d2  {"" + Double.NaN == "NaN"} {"" + (-Double.NaN) == "NaN"}  {Double.NaN + "" == "NaN"} {(-Double.NaN) + "" == "NaN"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-2 FAILED


==== 15.18.1-double-3  convert Infinity double to String  FAILED
==== Contents of test case:

    constant_expression T15181d3  {"" + Double.NEGATIVE_INFINITY == "-Infinity"}  {"" + Double.POSITIVE_INFINITY == "Infinity"}  {Double.NEGATIVE_INFINITY + "" == "-Infinity"}  {Double.POSITIVE_INFINITY + "" == "Infinity"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-3 FAILED


==== 15.18.1-double-4  convert min double to String  FAILED
==== Contents of test case:

    constant_expression T15181d4  {"" + Double.MIN_VALUE == "4.9E-324"}  {Double.MIN_VALUE + "" == "4.9E-324"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-4 FAILED


==== 15.18.1-double-5  convert max double to String  FAILED
==== Contents of test case:

    constant_expression T15181d5  {"" + Double.MAX_VALUE == "1.7976931348623157E308"}  {Double.MAX_VALUE + "" == "1.7976931348623157E308"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-5 FAILED


==== 15.18.1-double-6  NaN != 12.0  FAILED
==== Contents of test case:

    constant_expression T15181d6  {"" + Double.NaN == "NaN"}  {"" + 12.0 == "12.0"}  {Double.NaN + "" == "NaN"}  {12.0 + "" == "12.0"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-6 FAILED


==== 15.18.1-double-7  NaN != 12.0  FAILED
==== Contents of test case:

    constant_expression T15181d7  {"" + 12.0 == "12.0"}  {"" + Double.NaN == "NaN"}  {12.0 + "" == "12.0"}  {Double.NaN + "" == "NaN"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-7 FAILED


==== 15.18.1-double-8  conversion of double to String must use as few
        digits after decimal as produce the same double again by rounding  FAILED
==== Contents of test case:

    constant_expression T15181d8  {"" + 40000000000000000. == "4.0E16"}  {"" + 40000000000000008. == "4.000000000000001E16"}  {"" + 40000000000000016. == "4.000000000000002E16"}  {"" + 40000000000000024. == "4.0000000000000024E16"}  {"" + 40000000000000032. == "4.000000000000003E16"}  {"" + 40000000000000040. == "4.000000000000004E16"}  {40000000000000000. + "" == "4.0E16"}  {40000000000000008. + "" == "4.000000000000001E16"}  {40000000000000016. + "" == "4.000000000000002E16"}  {40000000000000024. + "" == "4.0000000000000024E16"}  {40000000000000032. + "" == "4.000000000000003E16"}  {40000000000000040. + "" == "4.000000000000004E16"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-8 FAILED


==== 15.18.1-double-9  conversion of double to String switches from
        plain to exponent at 1e7  FAILED
==== Contents of test case:

    constant_expression T15181d9  {"" + 9999999.999999998 == "9999999.999999998"}  {"" + 10000000.0 == "1.0E7"}  {9999999.999999998 + "" == "9999999.999999998"}  {10000000.0 + "" == "1.0E7"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-9 FAILED


==== 15.18.1-double-10  conversion of double to String switches from
        plain to exponent at 1e-3. Trailing 0's are not permitted.  FAILED
==== Contents of test case:

    constant_expression T15181d10  {"" + .001 == "0.001"}  {"" + .0009999999999999998 == "9.999999999999998E-4"}  {.001 + "" == "0.001"}  {.0009999999999999998 + "" == "9.999999999999998E-4"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-10 FAILED


==== 15.18.1-double-11  conversion of double to String produces the
        shortest string that parses back to the same double  FAILED
==== Contents of test case:

    constant_expression T15181d11  {"" + 9.999999999999999e22 == "1.0E23"}  {9.999999999999999e22 + "" == "1.0E23"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-11 FAILED


==== 15.18.1-double-12  One of the longest possible Strings
        possible when converting doubles  FAILED
==== Contents of test case:

    constant_expression T15181d12  {"" + -1.2345678912345678e-200 == "-1.2345678912345678E-200"}  {-1.2345678912345678e-200 + "" == "-1.2345678912345678E-200"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-12 FAILED


==== 15.18.1-double-13  conversion of double to String prints the
        closest decimal string to the exact value, even on denorms  FAILED
==== Contents of test case:

    constant_expression T15181d13  {"" + 1e-323 == "9.9E-324"}  {"" + 1e-322 == "9.9E-323"}  {1e-323 + "" == "9.9E-324"}  {1e-322 + "" == "9.9E-323"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-double-13 FAILED


==== 15.18.1-boolean-1  conversion of boolean to String  FAILED
==== Contents of test case:

    constant_expression T15181b1  {"" + true == "true"}  {"" + false == "false"}  {true + "" == "true"}  {false + "" == "false"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-boolean-1 FAILED


==== 15.18.1-boolean-2  conversion of boolean to String  FAILED
==== Contents of test case:

    empty_main T15181b2 {
        String s1 = "" + true;
        String s2 = "" + false;
	s1 = true + "";
	s2 = false + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-boolean-2 FAILED


==== 15.18.1-string-1  string appends from .class files  FAILED
==== Contents of test case:

    empty_class T15181s1a {
        T15181s1a(){}
        static final String QUOTE = "\"";
    }
    delete T15181s1a.java
    compile -classpath . [saveas T15181s1b.java {
class T15181s1b {
    void m(int i) {
        switch (i) {
            case 0:
            case (T15181s1a.QUOTE + "\"" == "\"\"") ? 1 : 0:
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-string-1 FAILED


==== 15.18.1-string-2  string appends from .class files  FAILED
==== Contents of test case:

    empty_class T15181s2a {
        T15181s2a(){}
        static final String UTF8 = "\u0000\u5555";
    }
    delete T15181s2a.java
    compile -classpath . [saveas T15181s2b.java {
class T15181s2b {
    void m(int i) {
        switch (i) {
            case 0:
            case (T15181s2a.UTF8 + ' ' == "\0\u5555 ") ? 1 : 0:
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-string-2 FAILED


==== 15.18.1-valid-1  String + null type is valid  FAILED
==== Contents of test case:

    empty_main T15181v1 {
        boolean b = true;
        String s = "" + (b ? null : null);
	s = (b ? null : null) + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-valid-1 FAILED


==== 15.18.1-valid-2  String + primitive is valid  FAILED
==== Contents of test case:

    empty_main T15181v2 {
        boolean b = true;
        String s1 = "" + b;
        String s2 = b + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-valid-2 FAILED


==== 15.18.1-valid-3  String + primitive is valid  FAILED
==== Contents of test case:

    empty_main T15181v3 {
        byte b = 1;
        String s1 = "" + b;
        String s2 = b + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-valid-3 FAILED


==== 15.18.1-valid-4  String + primitive is valid  FAILED
==== Contents of test case:

    empty_main T15181v4 {
        short s = 1;
        String s1 = "" + s;
        String s2 = s + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-valid-4 FAILED


==== 15.18.1-valid-5  String + primitive is valid  FAILED
==== Contents of test case:

    empty_main T15181v5 {
        char c = 1;
        String s1 = "" + c;
        String s2 = c + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-valid-5 FAILED


==== 15.18.1-valid-6  String + primitive is valid  FAILED
==== Contents of test case:

    empty_main T15181v6 {
        int i = 1;
        String s1 = "" + i;
        String s2 = i + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-valid-6 FAILED


==== 15.18.1-valid-7  String + primitive is valid  FAILED
==== Contents of test case:

    empty_main T15181v7 {
        long l = 1;
        String s1 = "" + l;
        String s2 = l + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-valid-7 FAILED


==== 15.18.1-valid-8  String + primitive is valid  FAILED
==== Contents of test case:

    empty_main T15181v8 {
        float f = 1;
        String s1 = "" + f;
        String s2 = f + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-valid-8 FAILED


==== 15.18.1-valid-9  String + primitive is valid  FAILED
==== Contents of test case:

    empty_main T15181v9 {
        double d = 1;
        String s1 = "" + d;
        String s2 = d + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-valid-9 FAILED


==== 15.18.1-non-const-1  runtime concatenation  FAILED
==== Contents of test case:

    empty_main T15181nc1 {
	byte n = 0;
	String s = "s" + n;
	s = n + "s";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-1 FAILED


==== 15.18.1-non-const-4  runtime concatenation  FAILED
==== Contents of test case:

    empty_main T15181nc4 {
        String s1 = "C";
        int n = 10;
        String s2 = "A" + n + s1;
	s2 = s1 + n + "A";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-4 FAILED


==== 15.18.1-non-const-5  runtime concatenation  FAILED
==== Contents of test case:

    empty_main T15181nc5 {
        String s1 = "C";
        int n = 10;
        String s2 = "A" + (n + s1);
	s2 = (n + s1) + "A";
	s2 = (s1 + n) + "A";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-5 FAILED


==== 15.18.1-non-const-6  runtime concatenation  FAILED
==== Contents of test case:

    empty_main T15181nc6 {
        String s1 = "C";
        int n = 10;
        String s2 = n + ("B" + s1);
	s2 = ("B" + s1) + n;
	s2 = (s1 + "B") + n;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-6 FAILED


==== 15.18.1-non-const-8  concatenation of empty string  FAILED
==== Contents of test case:

    empty_main T15181nc8 {
        int i = 10;
        String s2 = "" + i;
	s2 = i + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-8 FAILED


==== 15.18.1-non-const-9  concatenation of empty string  FAILED
==== Contents of test case:

    empty_main T15181nc9 {
        int i = 10;
        String s2 = "" + i + "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-9 FAILED


==== 15.18.1-non-const-10  jikes had an optimization of string
        appends which resulted in an assertion failure. Bug id 2919.  FAILED
==== Contents of test case:

    empty_class T15181nc10 {
	private final static String s = val() + 'a' + "bcde";
	static String val () { return null; }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-10 FAILED


==== 15.18.1-non-const-11  jikes had some failures compiling string
        concatenation within a package when primitive types were involved  FAILED
==== Contents of test case:

    compile [saveas p1/T15181nc11.java {
package p1;
class T15181nc11 {
    int i = 1;
    String s = "" + i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-11 FAILED


==== 15.18.1-non-const-12  jikes had some failures compiling string
        concatenation within a package when primitive types were involved  FAILED
==== Contents of test case:

    compile [saveas p1/T15181nc12.java {
package p1;
class T15181nc12 {
    int[] i = {1};
    String s = "" + i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-12 FAILED


==== 15.18.1-non-const-13  jikes had some failures compiling string
        concatenation within a package when primitive types were involved  FAILED
==== Contents of test case:

    compile [saveas p1/T15181nc13.java {
package p1;
class T15181nc13 {
    String s = "" + null;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.18.1-non-const-13 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/array-access-expressions

==== 15.13-anon-1  According to the grammar in Chapter 18, it
        is also legal to acess the element of an anonymous array  FAILED
==== Contents of test case:

    empty_main T1513a1 {
        int i = new int[]{1}[0];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.13-anon-1 FAILED


==== 15.13-index-1  negative constant index is stupid, but legal  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_main T1513i1 {
	int[] i = {};
	i[-1] = 0;
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.13-index-1 FAILED


==== 15.13-index-2  out-of-bound index is legal, even when size
        and index are constant  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_main T1513i2 {
	final int[] i = {};
	i[0] = 0;
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.13-index-2 FAILED


==== 15.13-index-10  index is unary promoted to int  FAILED
==== Contents of test case:

    empty_main T1513i10 {
	int[] i = { 1 };
	short s = 0;
	byte b = 0;
	i[s] = i[b] = i['\0'] = i[0];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.13-index-10 FAILED


==== 15.13-reference-11  reference must be array type  FAILED
==== Contents of test case:

    empty_class T1513r11 {
	int[] m() { return null; }
	void n() {
	    m()[0]++;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.13-reference-11 FAILED


==== 15.13-reference-12  reference must be array type  FAILED
==== Contents of test case:

    empty_main T1513r12 {
	(new int[1])[0]++;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.13-reference-12 FAILED


==== 15.13-reference-13  reference must be array type  FAILED
==== Contents of test case:

    empty_class T1513r13 {
	static int[] i;
	void m() { 
	    i[0]++;
	    this.i[0]++;
	    T1513r13.i[0]++;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.13-reference-13 FAILED


==== 15.13-reference-14  reference must be array type  FAILED
==== Contents of test case:

    empty_main T1513r14 {
	int[][] i = { { 1 } };
	i[0][0]++;
	(i[0])[0]--;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.13-reference-14 FAILED


==== 15.13-final-1  in a final array, array members aren't final  FAILED
==== Contents of test case:

    empty_main T1513f1 {
	final int[] i = {0};
	i[0]++;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.13-final-1 FAILED


==== 15.13-type-1  the type of an array access expression is the
        underlying type of the array  FAILED
==== Contents of test case:

    empty_main T1513t1 {
	String[] s = {""};
	s[0].length();
	s[0].valueOf(1);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.13-type-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/array-creation-expressions

==== 15.10-initializer-syntax-1  array initializer may be empty  FAILED
==== Contents of test case:

    empty_main T1510is1 {
        int[] ia = new int[] {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-syntax-1 FAILED


==== 15.10-initializer-syntax-2  array initializer may contain
        initializers  FAILED
==== Contents of test case:

    empty_main T1510is2 {
        int[] ia = new int[] { 1 };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-syntax-2 FAILED


==== 15.10-initializer-syntax-3  array initializer may contain
        initializers  FAILED
==== Contents of test case:

    empty_main T1510is3 {
        int[] ia = new int[] { 1, 2 };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-syntax-3 FAILED


==== 15.10-initializer-syntax-4  array initializer may contain
        concluding comma  FAILED
==== Contents of test case:

    empty_main T1510is4 {
        int[] ia = new int[] { , };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-syntax-4 FAILED


==== 15.10-initializer-syntax-5  array initializer may contain
        concluding comma  FAILED
==== Contents of test case:

    empty_main T1510is5 {
        int[] ia = new int[] { 1, };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-syntax-5 FAILED


==== 15.10-initializer-syntax-6  array initializers may nest  FAILED
==== Contents of test case:

    empty_main T1510is6 {
        int[][] iaa = new int[][] { {1}, {2} };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-syntax-6 FAILED


==== 15.10-initializer-type-1  expressions in array initializer
        must be assignment compatible with array type  FAILED
==== Contents of test case:

    empty_main T1510it1 {
        short s = 1;
        int[] ia = new int[] { s, '1' };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-type-1 FAILED


==== 15.10-initializer-type-7  expressions in array initializer
        must be assignment compatible with array type  FAILED
==== Contents of test case:

    empty_main T1510it7 {
        Object[] oa = new Object[] { new Object() };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-type-7 FAILED


==== 15.10-initializer-type-8  expressions in array initializer
        must be assignment compatible with array type  FAILED
==== Contents of test case:

    empty_main T1510it8 {
        Object[] oa = new Object[] { null };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-type-8 FAILED


==== 15.10-initializer-type-10  expressions in array initializer
        must be assignment compatible with array type  FAILED
==== Contents of test case:

    empty_main T1510it10 {
        int[][] iaa = new int[][] { {1} };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-type-10 FAILED


==== 15.10-initializer-type-13  expressions in array initializer
        must be assignment compatible with array type  FAILED
==== Contents of test case:

    empty_main T1510it13 {
        int[][] iaa = new int[][] { {1, 2}, null };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-initializer-type-13 FAILED


==== 15.10-uninitialized-2  Some dimensions may be specified  FAILED
==== Contents of test case:

    empty_main T1510u2 {
	Object o = new int[1][];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-uninitialized-2 FAILED


==== 15.10-uninitialized-3  All dimensions may be specified  FAILED
==== Contents of test case:

    empty_main T1510u3 {
	Object o = new int[1][2];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.10-uninitialized-3 FAILED


==== 15.10-uninitialized-5  negative constant dimensions are
        stupid, but legal  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_main T1510u5 {
	Object o = new int[-1];
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.10-uninitialized-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/assignment-operators/compound-assignment-operators

==== 15.26.2-string-1  String += null is valid  FAILED
==== Contents of test case:

    compile [saveas T15262s1.java {
class T15262s1 {
    void foo() {
	String s = "";
	s += null;
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-string-1 FAILED


==== 15.26.2-string-2  String += void method is invalid  FAILED
==== Contents of test case:

  compile [saveas T15262s2.java {
class T15262s2 {
    void foo() {
	String s = "";
	s += System.out.println();
    }
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-string-2 FAILED


==== 15.26.2-string-5  test String += when right side is not String,
        jikes bug 3066  FAILED
==== Contents of test case:

    empty_main T15262s5 {
	String s = "";
	s += true;
	s += 1;
	s += '1';
	s += 1L;
	s += 1.0f;
	s += 1.0;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-string-5 FAILED


==== 15.26.2-string-6  test String += when right side is not String,
        jikes bug 3066  FAILED
==== Contents of test case:

    empty_main T15262s5 {
	String s = "";
	s += true + s;
	s += 1 + s;
	s += '1' + s;
	s += 1L + s;
	s += 1.0f + s;
	s += 1.0 + s;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-string-6 FAILED


==== 15.26.2-mult-1  test legal identity *= assignments  FAILED
==== Contents of test case:

    empty_main T15262mult1 {
	byte b = 1;
	b *= 1;
	short s = 1;
	s *= 1;
	char c = 1;
	c *= 1;
	int i = 1;
	i *= 1;
	long l = 1;
	l *= 1;
	float f = 1;
	f *= 1;
	double d = 1;
	d *= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-mult-1 FAILED


==== 15.26.2-mult-10  test illegal *= assignments: boolean variable  FAILED
==== Contents of test case:

    empty_main T15262mult10 {
	boolean b = true;
	b *= true;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-mult-10 FAILED


==== 15.26.2-mult-11  test illegal *= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262mult11 {
	1 *= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-mult-11 FAILED


==== 15.26.2-mult-13  test widening *= assignments  FAILED
==== Contents of test case:

    empty_main T15262mult13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	s *= b;
	i *= b;
	i *= s;
	i *= c;
	l *= b;
	l *= s;
	l *= c;
	l *= i;
	f *= b;
	f *= s;
	f *= c;
	f *= i;
	f *= l;
	d *= b;
	d *= s;
	d *= c;
	d *= i;
	d *= l;
	d *= f;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-mult-13 FAILED


==== 15.26.2-mult-14  test narrowing *= assignments  FAILED
==== Contents of test case:

    empty_main T15262mult14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	b *= s;
	b *= c;
	b *= i;
	b *= l;
	b *= f;
	b *= d;
	s *= c;
	s *= i;
	s *= l;
	s *= f;
	s *= d;
	c *= b;
	c *= s;
	c *= i;
	c *= l;
	c *= f;
	c *= d;
	i *= l;
	i *= f;
	i *= d;
	l *= f;
	l *= d;
	f *= d;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-mult-14 FAILED


==== 15.26.2-div-1  test legal identity /= assignments  FAILED
==== Contents of test case:

    empty_main T15262div1 {
	byte b = 1;
	b /= 1;
	short s = 1;
	s /= 1;
	char c = 1;
	c /= 1;
	int i = 1;
	i /= 1;
	long l = 1;
	l /= 1;
	float f = 1;
	f /= 1;
	double d = 1;
	d /= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-div-1 FAILED


==== 15.26.2-div-10  test illegal /= assignments: boolean variable  FAILED
==== Contents of test case:

    empty_main T15262div10 {
	boolean b = true;
	b /= true;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-div-10 FAILED


==== 15.26.2-div-11  test illegal /= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262div11 {
	1 /= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-div-11 FAILED


==== 15.26.2-div-13  test widening /= assignments  FAILED
==== Contents of test case:

    empty_main T15262div13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	s /= b;
	i /= b;
	i /= s;
	i /= c;
	l /= b;
	l /= s;
	l /= c;
	l /= i;
	f /= b;
	f /= s;
	f /= c;
	f /= i;
	f /= l;
	d /= b;
	d /= s;
	d /= c;
	d /= i;
	d /= l;
	d /= f;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-div-13 FAILED


==== 15.26.2-div-14  test narrowing /= assignments  FAILED
==== Contents of test case:

    empty_main T15262div14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	b /= s;
	b /= c;
	b /= i;
	b /= l;
	b /= f;
	b /= d;
	s /= c;
	s /= i;
	s /= l;
	s /= f;
	s /= d;
	c /= b;
	c /= s;
	c /= i;
	c /= l;
	c /= f;
	c /= d;
	i /= l;
	i /= f;
	i /= d;
	l /= f;
	l /= d;
	f /= d;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-div-14 FAILED


==== 15.26.2-div-zero-2  test integer /= by integer 0
        (warning recommended)  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T15262dz2 {
        long l = 1;
        void foo() {
            l /= 0;
            l /= 0L;
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.26.2-div-zero-2 FAILED


==== 15.26.2-div-zero-3  test integer /= by floating 0
       (no warning needed)  FAILED
==== Contents of test case:

    empty_main T15262dz3 {
	int i = 1;
	long l = 1;
	i /= 0.0f;
	i /= 0.0d;
	l /= 0.0f;
	l /= 0.0d;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-div-zero-3 FAILED


==== 15.26.2-div-zero-4  test floating /= by integer 0
        (no warning needed)  FAILED
==== Contents of test case:

    empty_main T15262dz4 {
	float f = 1;
	double d = 1;
	f /= 0;
	f /= 0L;
	d /= 0;
	d /= 0L;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-div-zero-4 FAILED


==== 15.26.2-div-zero-5  test floating /= by floating 0
        (no warning needed)  FAILED
==== Contents of test case:

    empty_main T15262dz5 {
	float f = 1;
	double d = 1;
	f /= 0.0f;
	d /= 0.0d;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-div-zero-5 FAILED


==== 15.26.2-mod-1  test legal identity %= assignments  FAILED
==== Contents of test case:

    empty_main T15262mod1 {
	byte b = 1;
	b %= 1;
	short s = 1;
	s %= 1;
	char c = 1;
	c %= 1;
	int i = 1;
	i %= 1;
	long l = 1;
	l %= 1;
	float f = 1;
	f %= 1;
	double d = 1;
	d %= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-mod-1 FAILED


==== 15.26.2-mod-10  test illegal %= assignments: boolean variable  FAILED
==== Contents of test case:

    empty_main T15262mod10 {
	boolean b = true;
	b %= true;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-mod-10 FAILED


==== 15.26.2-mod-11  test illegal %= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262mod11 {
	1 %= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-mod-11 FAILED


==== 15.26.2-mod-13  test widening %= assignments  FAILED
==== Contents of test case:

    empty_main T15262mod13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	s %= b;
	i %= b;
	i %= s;
	i %= c;
	l %= b;
	l %= s;
	l %= c;
	l %= i;
	f %= b;
	f %= s;
	f %= c;
	f %= i;
	f %= l;
	d %= b;
	d %= s;
	d %= c;
	d %= i;
	d %= l;
	d %= f;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-mod-13 FAILED


==== 15.26.2-mod-14  test narrowing %= assignments  FAILED
==== Contents of test case:

    empty_main T15262mod14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	b %= s;
	b %= c;
	b %= i;
	b %= l;
	b %= f;
	b %= d;
	s %= c;
	s %= i;
	s %= l;
	s %= f;
	s %= d;
	c %= b;
	c %= s;
	c %= i;
	c %= l;
	c %= f;
	c %= d;
	i %= l;
	i %= f;
	i %= d;
	l %= f;
	l %= d;
	f %= d;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-mod-14 FAILED


==== 15.26.2-mod-zero-2  test integer %= by integer 0
        (warning recommended)  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T15262dz2 {
        long l = 1;
        void foo() {
            l %= 0;
            l %= 0L;
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.26.2-mod-zero-2 FAILED


==== 15.26.2-mod-zero-3  test integer %= by floating 0
       (no warning needed)  FAILED
==== Contents of test case:

    empty_main T15262dz3 {
	int i = 1;
	long l = 1;
	i %= 0.0f;
	i %= 0.0d;
	l %= 0.0f;
	l %= 0.0d;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-mod-zero-3 FAILED


==== 15.26.2-mod-zero-4  test floating %= by integer 0
        (no warning needed)  FAILED
==== Contents of test case:

    empty_main T15262dz4 {
	float f = 1;
	double d = 1;
	f %= 0;
	f %= 0L;
	d %= 0;
	d %= 0L;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-mod-zero-4 FAILED


==== 15.26.2-mod-zero-5  test floating %= by floating 0
        (no warning needed)  FAILED
==== Contents of test case:

    empty_main T15262dz5 {
	float f = 1;
	double d = 1;
	f %= 0.0f;
	d %= 0.0d;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-mod-zero-5 FAILED


==== 15.26.2-add-1  test legal identity += assignments  FAILED
==== Contents of test case:

    empty_main T15262add1 {
	byte b = 1;
	b += 1;
	short s = 1;
	s += 1;
	char c = 1;
	c += 1;
	int i = 1;
	i += 1;
	long l = 1;
	l += 1;
	float f = 1;
	f += 1;
	double d = 1;
	d += 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-add-1 FAILED


==== 15.26.2-add-8  special case: test legal += assignments:
        String variable  FAILED
==== Contents of test case:

    empty_main T15262add8 {
	String s = "";
	s += 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-add-8 FAILED


==== 15.26.2-add-10  test illegal += assignments: boolean variable  FAILED
==== Contents of test case:

    empty_main T15262add10 {
	boolean b = true;
	b += true;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-add-10 FAILED


==== 15.26.2-add-11  test illegal += assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262add11 {
	1 += 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-add-11 FAILED


==== 15.26.2-add-13  test widening += assignments  FAILED
==== Contents of test case:

    empty_main T15262add13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	s += b;
	i += b;
	i += s;
	i += c;
	l += b;
	l += s;
	l += c;
	l += i;
	f += b;
	f += s;
	f += c;
	f += i;
	f += l;
	d += b;
	d += s;
	d += c;
	d += i;
	d += l;
	d += f;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-add-13 FAILED


==== 15.26.2-add-14  test narrowing += assignments  FAILED
==== Contents of test case:

    empty_main T15262add14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	b += s;
	b += c;
	b += i;
	b += l;
	b += f;
	b += d;
	s += c;
	s += i;
	s += l;
	s += f;
	s += d;
	c += b;
	c += s;
	c += i;
	c += l;
	c += f;
	c += d;
	i += l;
	i += f;
	i += d;
	l += f;
	l += d;
	f += d;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-add-14 FAILED


==== 15.26.2-sub-1  test legal identity -= assignments  FAILED
==== Contents of test case:

    empty_main T15262sub1 {
	byte b = 1;
	b -= 1;
	short s = 1;
	s -= 1;
	char c = 1;
	c -= 1;
	int i = 1;
	i -= 1;
	long l = 1;
	l -= 1;
	float f = 1;
	f -= 1;
	double d = 1;
	d -= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-sub-1 FAILED


==== 15.26.2-sub-10  test illegal -= assignments: boolean variable  FAILED
==== Contents of test case:

    empty_main T15262sub10 {
	boolean b = true;
	b -= true;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-sub-10 FAILED


==== 15.26.2-sub-11  test illegal -= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262sub11 {
	1 -= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-sub-11 FAILED


==== 15.26.2-sub-13  test widening -= assignments  FAILED
==== Contents of test case:

    empty_main T15262sub13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	s -= b;
	i -= b;
	i -= s;
	i -= c;
	l -= b;
	l -= s;
	l -= c;
	l -= i;
	f -= b;
	f -= s;
	f -= c;
	f -= i;
	f -= l;
	d -= b;
	d -= s;
	d -= c;
	d -= i;
	d -= l;
	d -= f;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-sub-13 FAILED


==== 15.26.2-sub-14  test narrowing -= assignments  FAILED
==== Contents of test case:

    empty_main T15262sub14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	float f = 1;
	double d = 1;
	b -= s;
	b -= c;
	b -= i;
	b -= l;
	b -= f;
	b -= d;
	s -= c;
	s -= i;
	s -= l;
	s -= f;
	s -= d;
	c -= b;
	c -= s;
	c -= i;
	c -= l;
	c -= f;
	c -= d;
	i -= l;
	i -= f;
	i -= d;
	l -= f;
	l -= d;
	f -= d;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-sub-14 FAILED


==== 15.26.2-left-shift-1  test legal identity <<= assignments  FAILED
==== Contents of test case:

    empty_main T15262ls1 {
	byte b = 1;
	b <<= 1;
	short s = 1;
	s <<= 1;
	char c = 1;
	c <<= 1;
	int i = 1;
	i <<= 1;
	long l = 1;
	l <<= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-left-shift-1 FAILED


==== 15.26.2-left-shift-10  test illegal <<= assignments: boolean variable  FAILED
==== Contents of test case:

    empty_main T15262ls10 {
	boolean b = true;
	b <<= true;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-left-shift-10 FAILED


==== 15.26.2-left-shift-11  test illegal <<= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262ls11 {
	1 <<= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-left-shift-11 FAILED


==== 15.26.2-left-shift-13  test widening <<= assignments  FAILED
==== Contents of test case:

    empty_main T15262ls13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	s <<= b;
	i <<= b;
	i <<= s;
	i <<= c;
	l <<= b;
	l <<= s;
	l <<= c;
	l <<= i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-left-shift-13 FAILED


==== 15.26.2-left-shift-14  test narrowing <<= assignments  FAILED
==== Contents of test case:

    empty_main T15262ls14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	b <<= s;
	b <<= c;
	b <<= i;
	b <<= l;
	s <<= c;
	s <<= i;
	s <<= l;
	c <<= b;
	c <<= s;
	c <<= i;
	c <<= l;
	i <<= l;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-left-shift-14 FAILED


==== 15.26.2-signed-right-shift-1  test legal identity >>= assignments  FAILED
==== Contents of test case:

    empty_main T15262srs1 {
	byte b = 1;
	b >>= 1;
	short s = 1;
	s >>= 1;
	char c = 1;
	c >>= 1;
	int i = 1;
	i >>= 1;
	long l = 1;
	l >>= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-signed-right-shift-1 FAILED


==== 15.26.2-signed-right-shift-10  test illegal >>= assignments: boolean variable  FAILED
==== Contents of test case:

    empty_main T15262srs10 {
	boolean b = true;
	b >>= true;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-signed-right-shift-10 FAILED


==== 15.26.2-signed-right-shift-11  test illegal >>= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262srs11 {
	1 >>= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-signed-right-shift-11 FAILED


==== 15.26.2-signed-right-shift-13  test widening >>= assignments  FAILED
==== Contents of test case:

    empty_main T15262srs13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	s >>= b;
	i >>= b;
	i >>= s;
	i >>= c;
	l >>= b;
	l >>= s;
	l >>= c;
	l >>= i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-signed-right-shift-13 FAILED


==== 15.26.2-signed-right-shift-14  test narrowing >>= assignments  FAILED
==== Contents of test case:

    empty_main T15262srs14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	b >>= s;
	b >>= c;
	b >>= i;
	b >>= l;
	s >>= c;
	s >>= i;
	s >>= l;
	c >>= b;
	c >>= s;
	c >>= i;
	c >>= l;
	i >>= l;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-signed-right-shift-14 FAILED


==== 15.26.2-unsigned-right-shift-1  test legal identity >>>= assignments  FAILED
==== Contents of test case:

    empty_main T15262urs1 {
	byte b = 1;
	b >>>= 1;
	short s = 1;
	s >>>= 1;
	char c = 1;
	c >>>= 1;
	int i = 1;
	i >>>= 1;
	long l = 1;
	l >>>= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-unsigned-right-shift-1 FAILED


==== 15.26.2-unsigned-right-shift-10  test illegal >>>= assignments: boolean variable  FAILED
==== Contents of test case:

    empty_main T15262urs10 {
	boolean b = true;
	b >>>= true;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-unsigned-right-shift-10 FAILED


==== 15.26.2-unsigned-right-shift-11  test illegal >>>= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262urs11 {
	1 >>>= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-unsigned-right-shift-11 FAILED


==== 15.26.2-unsigned-right-shift-13  test widening >>>= assignments  FAILED
==== Contents of test case:

    empty_main T15262urs13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	s >>>= b;
	i >>>= b;
	i >>>= s;
	i >>>= c;
	l >>>= b;
	l >>>= s;
	l >>>= c;
	l >>>= i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-unsigned-right-shift-13 FAILED


==== 15.26.2-unsigned-right-shift-14  test narrowing >>>= assignments  FAILED
==== Contents of test case:

    empty_main T15262urs14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	b >>>= s;
	b >>>= c;
	b >>>= i;
	b >>>= l;
	s >>>= c;
	s >>>= i;
	s >>>= l;
	c >>>= b;
	c >>>= s;
	c >>>= i;
	c >>>= l;
	i >>>= l;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-unsigned-right-shift-14 FAILED


==== 15.26.2-and-1  test legal identity &= assignments  FAILED
==== Contents of test case:

    empty_main T15262and1 {
	boolean z = true;
	z &= true;
	byte b = 1;
	b &= 1;
	short s = 1;
	s &= 1;
	char c = 1;
	c &= 1;
	int i = 1;
	i &= 1;
	long l = 1;
	l &= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-and-1 FAILED


==== 15.26.2-and-11  test illegal &= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262and11 {
	1 &= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-and-11 FAILED


==== 15.26.2-and-13  test widening &= assignments  FAILED
==== Contents of test case:

    empty_main T15262and13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	s &= b;
	i &= b;
	i &= s;
	i &= c;
	l &= b;
	l &= s;
	l &= c;
	l &= i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-and-13 FAILED


==== 15.26.2-and-14  test narrowing &= assignments  FAILED
==== Contents of test case:

    empty_main T15262and14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	b &= s;
	b &= c;
	b &= i;
	b &= l;
	s &= c;
	s &= i;
	s &= l;
	c &= b;
	c &= s;
	c &= i;
	c &= l;
	i &= l;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-and-14 FAILED


==== 15.26.2-xor-1  test legal identity ^= assignments  FAILED
==== Contents of test case:

    empty_main T15262xor1 {
	boolean z = true;
	z ^= true;
	byte b = 1;
	b ^= 1;
	short s = 1;
	s ^= 1;
	char c = 1;
	c ^= 1;
	int i = 1;
	i ^= 1;
	long l = 1;
	l ^= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-xor-1 FAILED


==== 15.26.2-xor-11  test illegal ^= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262xor11 {
	1 ^= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-xor-11 FAILED


==== 15.26.2-xor-13  test widening ^= assignments  FAILED
==== Contents of test case:

    empty_main T15262xor13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	s ^= b;
	i ^= b;
	i ^= s;
	i ^= c;
	l ^= b;
	l ^= s;
	l ^= c;
	l ^= i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-xor-13 FAILED


==== 15.26.2-xor-14  test narrowing ^= assignments  FAILED
==== Contents of test case:

    empty_main T15262xor14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	b ^= s;
	b ^= c;
	b ^= i;
	b ^= l;
	s ^= c;
	s ^= i;
	s ^= l;
	c ^= b;
	c ^= s;
	c ^= i;
	c ^= l;
	i ^= l;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-xor-14 FAILED


==== 15.26.2-or-1  test legal identity |= assignments  FAILED
==== Contents of test case:

    empty_main T15262or1 {
	boolean z = true;
	z |= true;
	byte b = 1;
	b |= 1;
	short s = 1;
	s |= 1;
	char c = 1;
	c |= 1;
	int i = 1;
	i |= 1;
	long l = 1;
	l |= 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-or-1 FAILED


==== 15.26.2-or-11  test illegal |= assignments: non-variable  FAILED
==== Contents of test case:

    empty_main T15262or11 {
	1 |= 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-or-11 FAILED


==== 15.26.2-or-13  test widening |= assignments  FAILED
==== Contents of test case:

    empty_main T15262or13 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	s |= b;
	i |= b;
	i |= s;
	i |= c;
	l |= b;
	l |= s;
	l |= c;
	l |= i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-or-13 FAILED


==== 15.26.2-or-14  test narrowing |= assignments  FAILED
==== Contents of test case:

    empty_main T15262or14 {
	byte b = 1;
	short s = 1;
	char c = 1;
	int i = 1;
	long l = 1;
	b |= s;
	b |= c;
	b |= i;
	b |= l;
	s |= c;
	s |= i;
	s |= l;
	c |= b;
	c |= s;
	c |= i;
	c |= l;
	i |= l;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.26.2-or-14 FAILED


==== 15.26.2-variable-5  the left-hand side must be a variable  FAILED
==== Contents of test case:

    empty_main T15262var5 {
        new String() += "oops";
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-variable-5 FAILED


==== 15.26.2-variable-6  the left-hand side must be a variable  FAILED
==== Contents of test case:

    empty_main T15262var6 {
        (new String()) += "oops";
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-variable-6 FAILED


==== 15.26.2-variable-14  the left-hand side must be a variable  FAILED
==== Contents of test case:

    empty_main T15262var14 {
        int i = 1;
        (i++) += 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-variable-14 FAILED


==== 15.26.2-variable-20  the left-hand side must be a variable  FAILED
==== Contents of test case:

    empty_main T15262var20 {
        int i = 1;
        (i + i) += 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-variable-20 FAILED


==== 15.26.2-variable-21  the left-hand side must be a variable  FAILED
==== Contents of test case:

    empty_main T15262var21 {
        int i = 1;
        (i += 1) += 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-variable-21 FAILED


==== 15.26.2-variable-22  the left-hand side must be a variable  FAILED
==== Contents of test case:

    empty_main T15262var22 {
        1 += 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-variable-22 FAILED


==== 15.26.2-variable-23  the left-hand side must be a variable  FAILED
==== Contents of test case:

    empty_main T15262var23 {
        (1) += 1;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-variable-23 FAILED


==== 15.26.2-variable-28  the left-hand side must be a variable  FAILED
==== Contents of test case:

    empty_main T15262var28 {
        "" += "oops";
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-variable-28 FAILED


==== 15.26.2-variable-29  the left-hand side must be a variable  FAILED
==== Contents of test case:

    empty_main T15262var29 {
        ("") += "oops";
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.26.2-variable-29 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/cast-expressions

==== 15.16-array-2  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_main T1516a2 {
	int[] i = {};
	int[] l = (int[]) i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-2 FAILED


==== 15.16-array-3  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_main T1516a3 {
	int[] i = {};
	Object o = (Object) i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-3 FAILED


==== 15.16-array-4  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_main T1516a4 {
	int[][] i = {};
	Cloneable c = (Cloneable) i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-4 FAILED


==== 15.16-array-5  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_main T1516a5 {
	int[][][] i = {};
	java.io.Serializable[] s = (java.io.Serializable[]) i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-5 FAILED


==== 15.16-array-6  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_main T1516a6 {
	Object[][][] o = {};
	java.io.Serializable[] s = (java.io.Serializable[]) o;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-6 FAILED


==== 15.16-array-7  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_main T1516a7 {
	Object o = null;
	Cloneable[] s = (Cloneable[]) o;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-7 FAILED


==== 15.16-array-9  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_main T1516a9 {
	Cloneable[][] s = (Cloneable[][]) (Object) (Integer[]) (Cloneable)
	                  (int[]) null;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-9 FAILED


==== 15.16-array-12  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_class T1516a12 {
	interface I {}
	class C {}
	I[] i = (I[]) new C[0];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-12 FAILED


==== 15.16-array-13  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_class T1516a13 {
	interface I { int m(); }
	class C { void m() {} }
	I[] i = (I[]) new C[0];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-13 FAILED


==== 15.16-array-14  array type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_class T1516a14 {
	interface I {}
	interface J {}
	I[] i = (I[]) new J[0];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-array-14 FAILED


==== 15.16-ref-6  reference type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_class T1516r6 {
	interface I {}
	class C {}
	I i = (I) new C();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-ref-6 FAILED


==== 15.16-ref-7  reference type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_class T1516r7 {
	interface I { int m(); }
	class C { void m() {} }
	I i = (I) new C();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-ref-7 FAILED


==== 15.16-ref-8  reference type casting is legal if a widening or
        narrowing conversion can be made  FAILED
==== Contents of test case:

    empty_class T1516r8 {
	interface I {}
	interface J {}
	void m(J j) {
	    I i = (I) j;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-ref-8 FAILED


==== 15.16-semantic-5  To avoid grammar ambiguities, this syntax is
        accepted  FAILED
==== Contents of test case:

    empty_main T1516s5 {
	// Because (String) is followed by +, it is an expression not a cast
	final int String = 1;
	switch (String) {
	    case 0:
	    case ((String) + 1 + "") == "2" ? 1 : 0:
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.16-semantic-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/class-instance-creation

==== 15.9-unqualified-1  a
        ClassInstanceCreationExpression
        that starts with the keyword new
        is known as an unqualified class
        instance creation expression  FAILED
==== Contents of test case:


    empty_class T159u1 {
        Object o = new T159u1();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9-unqualified-1 FAILED


==== 15.9-unqualified-2  an
        unqualified class instance
        creation expression can create
        instances of a toplevel, member,
        local, or anonymous class  FAILED
==== Contents of test case:


    empty_class T159u2 {
        class Inner {}
        static class Sinner {}
        void foo() {
            new T159u2(); // toplevel
            new Inner(); // member
            new Sinner(); // static member

            class Local {}
            new Local(); // local

            new T159u2() {}; // anonymous
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9-unqualified-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/class-instance-creation/anonymous-class-declarations/anonymous-constructors

==== 15.9.5.1-superconstructor-4  Accessibility disambiguates
        the superconstructor of an anonymous class  FAILED
==== Contents of test case:

    compile [saveas T15951s4.java {
class T15951s4 {
    private T15951s4(int i, byte b) {}
    T15951s4(byte b, int i) {}
}
class Other4 {
    byte b;
    Object o = new T15951s4(b, b) {};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-superconstructor-4 FAILED


==== 15.9.5.1-superconstructor-5  An anonymous class may access
        a private superconstructor within the same enclosing class  FAILED
==== Contents of test case:

    empty_class T15951s5 {
        private T15951s5() {}
        Object o = new T15951s5() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-superconstructor-5 FAILED


==== 15.9.5.1-superconstructor-6  An anonymous class may access
        the protected constructor of a class from another package  FAILED
==== Contents of test case:

    saveas p1/T15951s6_1.java {
package p1;
public class T15951s6_1 {
    protected T15951s6_1() {}
}
    }
    saveas p2/T15951s6_2.java {
package p2;
import p1.T15951s6_1;
class T15951s6_2 {
    Object o = new T15951s6_1() {};
}
    }
    compile p1/T15951s6_1.java p2/T15951s6_2.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-superconstructor-6 FAILED


==== 15.9.5.1-superconstructor-7  An anonymous class may refer to
        an inaccessible type mentioned as a superconstructor parameter  FAILED
==== Contents of test case:

    compile [saveas p1/T15951s7_2.java {
package p1;
class T15951s7_1 {}
public class T15951s7_2 {
    public static T15951s7_1 get() { return new T15951s7_1(); }
    public static class Inner extends T15951s7_1 {}
    public T15951s7_2(T15951s7_1 s) {}
}
    }] [saveas T15951s7_3.java {
import p1.T15951s7_2;
class T15951s7_3 {
    {
	new T15951s7_2(null);
	new T15951s7_2(null) {};
	new T15951s7_2(T15951s7_2.get());
	new T15951s7_2(T15951s7_2.get()) {};
	new T15951s7_2(new T15951s7_2.Inner());
	new T15951s7_2(new T15951s7_2.Inner()) {};
	new T15951s7_2(new T15951s7_2.Inner() {});
	new T15951s7_2(new T15951s7_2.Inner() {}) {};
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-superconstructor-7 FAILED


==== 15.9.5.1-superconstructor-8  A unique most-specific accessible
        constructor must exist  FAILED
==== Contents of test case:

    empty_class T15951s8 {
	A a = new A();
	static class A {
	    private A() {}
	    // compiler creates A(T15951s8$1 dummy) { this(); }
	    A(String s) {}
	}
	// no ambiguity between real A(String), synthetic A(dummy)
	{ new A(null) {}; }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-superconstructor-8 FAILED


==== 15.9.5.1-superconstructor-9  A unique most-specific accessible
        constructor must exist  FAILED
==== Contents of test case:

    compile [saveas T15951s9a.java {
class T15951s9a {
    A a = new A();
    static class A {
	private A() {}
	// compiler creates A(T15951s9a$1 dummy) { this(); }
	A(String s) {}
    }
}
    }]
    delete T15951s9a.java
    compile -classpath . [saveas T15951s9b.java {
class T15951s9b {
    // no ambiguity between real A(String), synthetic A(dummy)
    { new T15951s9a.A(null); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-superconstructor-9 FAILED


==== 15.9.5.1-exception-1  An anonymous class constructor legally
        throws whatever exception the superconstructor does  FAILED
==== Contents of test case:

    empty_class T15951e1 {
        T15951e1() throws InterruptedException {}
        void foo() {
            try {
                new T15951e1() {};
            } catch (InterruptedException e) {
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-exception-1 FAILED


==== 15.9.5.1-exception-2  An anonymous class constructor legally
        throws whatever exception the superconstructor does  FAILED
==== Contents of test case:

    empty_class T15951e2 {
        T15951e2() throws RuntimeException, Error {}
        void foo() {
            try {
                new T15951e2() {};
            } catch (RuntimeException re) {
            } catch (Error e) {
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-exception-2 FAILED


==== 15.9.5.1-exception-3  An anonymous class constructor legally
        throws whatever exception an instance initializer throws  FAILED
==== Contents of test case:

    empty_main T15951e3 {
        try {
            new Object() {
                int i = foo();
                int foo() throws InterruptedException { return 0; }
            };
        } catch (InterruptedException e) {
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-exception-3 FAILED


==== 15.9.5.1-exception-4  An anonymous class constructor legally
        throws whatever exception an instance initializer throws  FAILED
==== Contents of test case:

    empty_main T15951e4 {
        try {
            new Object() {
                {
                    if (true) // initializer must be able to complete normally
                        throw new InterruptedException();
                }
            };
        } catch (InterruptedException e) {
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.5.1-exception-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/class-instance-creation/choosing-the-constructor

==== 15.9.3-anonymous-1  If the anonymous class extends an inner
        class, the parameters may need to include the enclosing instance for
        the superclass  FAILED
==== Contents of test case:

    empty_class T1593a1 {
	class A {}
	Object o = new A() {}; // needs enclosing instance
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.3-anonymous-1 FAILED


==== 15.9.3-anonymous-2  If the anonymous class extends an inner
        class, the parameters may need to include the enclosing instance for
        the superclass  FAILED
==== Contents of test case:

    empty_class T1593a2 {
	static class A {}
	Object o = new A() {}; // does not need enclosing instance
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.3-anonymous-2 FAILED


==== 15.9.3-anonymous-3  If the anonymous class extends an inner
        class, the parameters may need to include the enclosing instance for
        the superclass  FAILED
==== Contents of test case:

    empty_class T1593a3 {
	static {
	    class A {}
	    Object o = new A() {}; // does not need enclosing instance
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.3-anonymous-3 FAILED


==== 15.9.3-choosing-1  A unique most-specific accessible constructor
        must exist  FAILED
==== Contents of test case:

    empty_class T1593c1 {
	Object o = new Object(1); // Object(int) does not exist
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.9.3-choosing-1 FAILED


==== 15.9.3-choosing-4  A unique most-specific accessible constructor
        must exist  FAILED
==== Contents of test case:

    compile [saveas T1593c4a.java {
class T1593c4a {
    private T1593c4a(int i, byte b) {}
    T1593c4a(byte b, int i) {}
}
class T1593c4b {
    byte b;
    Object o = new T1593c4a(b, b) {};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.3-choosing-4 FAILED


==== 15.9.3-choosing-5  A unique most-specific accessible constructor
        must exist  FAILED
==== Contents of test case:

    empty_class T1593c5 {
        private T1593c5() {}
        Object o = new T1593c5();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.3-choosing-5 FAILED


==== 15.9.3-choosing-6  A unique most-specific accessible constructor
        must exist  FAILED
==== Contents of test case:

    compile [saveas p1/T1593c6a.java {
package p1;
public class T1593c6a {
    protected T1593c6a(String s) {}
    public T1593c6a(Integer i) {}
}
    }] [saveas T1593c6b.java {
class T1593c6b {
    Object o = new p1.T1593c6a(null); // only T1593c6a(Integer) is accessible
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.3-choosing-6 FAILED


==== 15.9.3-choosing-7  A unique most-specific accessible constructor
        must exist  FAILED
==== Contents of test case:

    empty_class T1593c7 {
	A a = new A();
	static class A {
	    private A() {}
	    // compiler creates A(T1593c7$1 dummy) { this(); }
	    A(String s) {}
	}
	// no ambiguity between real A(String), synthetic A(dummy)
	{ new A(null); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.3-choosing-7 FAILED


==== 15.9.3-choosing-8  A unique most-specific accessible constructor
        must exist  FAILED
==== Contents of test case:

    compile [saveas T1593c8a.java {
class T1593c8a {
    A a = new A();
    static class A {
	private A() {}
	// compiler creates A(T1593c8a$1 dummy) { this(); }
	A(String s) {}
    }
}
    }]
    delete T1593c8a.java
    compile -classpath . [saveas T1593c8b.java {
class T1593c8b {
    // no ambiguity between real A(String), synthetic A(dummy)
    { new T1593c8a.A(null); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.3-choosing-8 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/class-instance-creation/determining-enclosing-instances

==== 15.9.2-inner-member-1  if C is an inner member, and the
        creation expression is unqualified, the enclosing instance is the
        innermost enclosing instance of the correct type at the point
        of creation  FAILED
==== Contents of test case:

    compile [saveas T1592im1.java {
interface T1592im1 {
    class O {
        class C {} 
	O() {
            new C();
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.2-inner-member-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/class-instance-creation/determining-the-class

==== 15.9.1-unqualified-anonymous-1  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    empty_main T1591ua1 {
        new java.lang.Object(){};
        new T1591ua1(){};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-1 FAILED


==== 15.9.1-unqualified-anonymous-2  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T1591ua2_1.java {
package p1;
public class T1591ua2_1 {}
    }] [saveas p2/T1591ua2_2.java {
package p2;
import p1.*;
class T1591ua2_2 extends p1.T1591ua2_1 {
    Object o1 = new p1.T1591ua2_1(){};
    Object o2 = new T1591ua2_1(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-2 FAILED


==== 15.9.1-unqualified-anonymous-4  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T1591ua4_1.java {
package p1;
public class T1591ua4_1 {
    public class Inner{}
}
    }] [saveas p2/T1591ua4_2.java {
package p2;
import p1.*;
class T1591ua4_2 extends p1.T1591ua4_1 {
    Object o1 = new p1.T1591ua4_1.Inner(){};
    Object o2 = new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-4 FAILED


==== 15.9.1-unqualified-anonymous-5  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T1591ua5_1.java {
package p1;
public class T1591ua5_1 {
    protected class Inner{}
}
    }] [saveas p2/T1591ua5_2.java {
package p2;
import p1.*;
class T1591ua5_2 extends p1.T1591ua5_1 {
    Object o1 = new p1.T1591ua5_1.Inner(){};
    Object o2 = new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-5 FAILED


==== 15.9.1-unqualified-anonymous-8  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas T1591ua8_1.java {
class T1591ua8_1 {
    protected class Inner{}
}
class T1591ua8_2 extends T1591ua8_1 {
    Object o1 = new T1591ua8_1.Inner(){};
    Object o2 = new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-8 FAILED


==== 15.9.1-unqualified-anonymous-9  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas T1591ua9_1.java {
class T1591ua9_1 {
    class Inner{}
}
class T1591ua9_2 extends T1591ua9_1 {
    Object o1 = new T1591ua9_1.Inner(){};
    Object o2 = new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-9 FAILED


==== 15.9.1-unqualified-anonymous-11  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas T1591ua11.java {
interface I1591ua11 {}
class T1591ua11 {
    Object o1 = new java.lang.Cloneable(){};
    Object o2 = new I1591ua11(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-11 FAILED


==== 15.9.1-unqualified-anonymous-12  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T1591ua12_1.java {
package p1;
public interface T1591ua12_1 {}
    }] [saveas p2/T1591ua12_2.java {
package p2;
import p1.*;
class T1591ua12_2 implements p1.T1591ua12_1 {
    Object o1 = new p1.T1591ua12_1(){};
    Object o2 = new T1591ua12_1(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-12 FAILED


==== 15.9.1-unqualified-anonymous-14  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T1591ua14_1.java {
package p1;
public class T1591ua14_1 {
    public interface Inner{}
}
    }] [saveas p2/T1591ua14_2.java {
package p2;
import p1.*;
class T1591ua14_2 extends p1.T1591ua14_1 {
    Object o1 = new p1.T1591ua14_1.Inner(){};
    Object o2 = new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-14 FAILED


==== 15.9.1-unqualified-anonymous-15  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T1591ua15_1.java {
package p1;
public class T1591ua15_1 {
    protected interface Inner{}
}
    }] [saveas p2/T1591ua15_2.java {
package p2;
import p1.*;
class T1591ua15_2 extends p1.T1591ua15_1 {
    Object o1 = new p1.T1591ua15_1.Inner(){};
    Object o2 = new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-15 FAILED


==== 15.9.1-unqualified-anonymous-18  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas T1591ua18_1.java {
class T1591ua18_1 {
    protected interface Inner{}
}
class T1591ua18_2 extends T1591ua18_1 {
    Object o1 = new T1591ua18_1.Inner(){};
    Object o2 = new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-18 FAILED


==== 15.9.1-unqualified-anonymous-19  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas T1591ua19_1.java {
class T1591ua19_1 {
    interface Inner{}
}
class T1591ua19_2 extends T1591ua19_1 {
    Object o1 = new T1591ua19_1.Inner(){};
    Object o2 = new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-19 FAILED


==== 15.9.1-unqualified-anonymous-22  Anonymous classes may
        extend abstract class  FAILED
==== Contents of test case:

    empty_class T1591ua22 {
        abstract class Inner{}
        Object o1 = new T1591ua22.Inner(){};
        Object o2 = new Inner(){};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-22 FAILED


==== 15.9.1-unqualified-anonymous-24  The name may not be ambiguous,
        accessibility means that only one Inner is inherited  FAILED
==== Contents of test case:

    compile [saveas p1/T1591ua24_1.java {
package p1;
public class T1591ua24_1 {
    static class Inner{}
}
    }] [saveas p2/T1591ua24_2.java {
package p2;
import p1.*;
interface T1591ua24_2 {
    class Inner{}
}
class T1591ua24_3 extends T1591ua24_1 implements T1591ua24_2 {
    static Object o = new T1591ua24_3.Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-24 FAILED


==== 15.9.1-unqualified-anonymous-25  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    empty_class T1591ua25 {
	private class One {}
	class Two {
	    Two() {
		new One() {};
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-anonymous-25 FAILED


==== 15.9.1-qualified-anonymous-1  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    empty_class T1591qa1 {
        class Inner{}
        Object o = new T1591qa1().new Inner(){};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-1 FAILED


==== 15.9.1-qualified-anonymous-3  Anonymous classes may
        extend abstract class  FAILED
==== Contents of test case:

    empty_class T1591qa3 {
        abstract class Inner{}
        Object o = new T1591qa3().new Inner(){};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-3 FAILED


==== 15.9.1-qualified-anonymous-4  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T1591qa4_1.java {
package p1;
public class T1591qa4_1 {
    public class Inner{}
}
    }] [saveas p2/T1591qa4_2.java {
package p2;
import p1.*;
class T1591qa4_2 extends p1.T1591qa4_1 {
    Object o = new p1.T1591qa4_1().new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-4 FAILED


==== 15.9.1-qualified-anonymous-5  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T1591qa5_1.java {
package p1;
public class T1591qa5_1 {
    protected class Inner{}
}
    }] [saveas p2/T1591qa5_2.java {
package p2;
import p1.*;
class T1591qa5_2 extends p1.T1591qa5_1 {
    Object o = new p1.T1591qa5_1().new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-5 FAILED


==== 15.9.1-qualified-anonymous-8  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    compile [saveas T1591qa8_1.java {
class T1591qa8_1 {
    protected class Inner{}
}
class T1591qa8_2 extends T1591qa8_1 {
    Object o = new T1591qa8_1().new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-8 FAILED


==== 15.9.1-qualified-anonymous-9  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    compile [saveas T1591qa9_1.java {
class T1591qa9_1 {
    class Inner{}
}
class T1591qa9_2 extends T1591qa9_1 {
    Object o = new T1591qa9_1().new Inner(){};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-9 FAILED


==== 15.9.1-qualified-anonymous-15  The anonymous class extends
        the inner class of the type of the qualifier  FAILED
==== Contents of test case:

    empty_class T1591qa15 {
        class Inner{}
        Object o = new T1591qa15(){}.new Inner(){};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-15 FAILED


==== 15.9.1-qualified-anonymous-16  The anonymous class extends
        the inner class of the type of the qualifier  FAILED
==== Contents of test case:

    empty_class T1591qa16 {
        Object o = new T1591qa16(){
            class Inner{}
        }.new Inner(){};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-16 FAILED


==== 15.9.1-qualified-anonymous-17  The anonymous class extends
        the inner class of the type of the qualifier  FAILED
==== Contents of test case:

    empty_class T1591qa17 {
        class Inner {
            static final int foo = 1;
        }
        Object o = new T1591qa17(){
            class Inner {
                static final int foo = 2;
            }
        }.new Inner(){
            {
                switch (1) {
                    case 0:
                    case ((foo == 2) ? 1 : 0):
                }
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-17 FAILED


==== 15.9.1-qualified-anonymous-23  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    empty_class T1591qa23 {
	private class One {}
	class Two {
	    Two() {
		T1591qa23.this.new One() {};
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-23 FAILED


==== 15.9.1-qualified-anonymous-25  The qualifier must be a primary,
        not a typename  FAILED
==== Contents of test case:

    empty_class T1591qa25 {
	class A {}
	{
	    T1591qa25 t = this;
	    t.new A() {}; // this is legal in spite of the chapter 15 grammar
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-25 FAILED


==== 15.9.1-qualified-anonymous-27  The identifier is a typename  FAILED
==== Contents of test case:

    empty_class T1591qa27 {
	class A {}
	int A;
	int A() { return 0; }
	{ new T1591qa27().new A() {}; }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-anonymous-27 FAILED


==== 15.9.1-unqualified-concrete-1  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    empty_main T1591uc1 {
        new java.lang.Object();
        new T1591uc1();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-concrete-1 FAILED


==== 15.9.1-unqualified-concrete-2  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T1591uc2_1.java {
package p1;
public class T1591uc2_1 {}
    }] [saveas p2/T1591uc2_2.java {
package p2;
import p1.*;
class T1591uc2_2 extends p1.T1591uc2_1 {
    Object o1 = new p1.T1591uc2_1();
    Object o2 = new T1591uc2_1();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-concrete-2 FAILED


==== 15.9.1-unqualified-concrete-4  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T1591uc4_1.java {
package p1;
public class T1591uc4_1 {
    public class Inner{}
}
    }] [saveas p2/T1591uc4_2.java {
package p2;
import p1.*;
class T1591uc4_2 extends p1.T1591uc4_1 {
    Object o1 = new p1.T1591uc4_1.Inner();
    Object o2 = new Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-concrete-4 FAILED


==== 15.9.1-unqualified-concrete-5  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T1591uc5_1.java {
package p1;
public class T1591uc5_1 {
    protected class Inner{
        public Inner(){}
    }
}
    }] [saveas p2/T1591uc5_2.java {
package p2;
import p1.*;
class T1591uc5_2 extends p1.T1591uc5_1 {
    Object o1 = new p1.T1591uc5_1.Inner();
    Object o2 = new Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-concrete-5 FAILED


==== 15.9.1-unqualified-concrete-8  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas T1591uc8_1.java {
class T1591uc8_1 {
    protected class Inner{}
}
class T1591uc8_2 extends T1591uc8_1 {
    Object o1 = new T1591uc8_1.Inner();
    Object o2 = new Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-concrete-8 FAILED


==== 15.9.1-unqualified-concrete-9  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas T1591uc9_1.java {
class T1591uc9_1 {
    class Inner{}
}
class T1591uc9_2 extends T1591uc9_1 {
    Object o1 = new T1591uc9_1.Inner();
    Object o2 = new Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-concrete-9 FAILED


==== 15.9.1-unqualified-concrete-12  Concrete classes may be final  FAILED
==== Contents of test case:

    empty_class T1591uc12 {
        final class Inner{}
        Object o1 = new T1591uc12.Inner();
        Object o2 = new Inner();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-concrete-12 FAILED


==== 15.9.1-unqualified-concrete-15  The name may not be ambiguous,
        accessibility means that only one Inner is inherited  FAILED
==== Contents of test case:

    compile [saveas p1/T1591uc15_1.java {
package p1;
public class T1591uc15_1 {
    static class Inner{}
}
    }] [saveas p2/T1591uc15_2.java {
package p2;
import p1.*;
interface T1591uc15_2 {
    class Inner{}
}
class T1591uc15_3 extends T1591uc15_1 implements T1591uc15_2 {
    static Object o = new T1591uc15_3.Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-concrete-15 FAILED


==== 15.9.1-unqualified-concrete-16  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    empty_class T1591uc16 {
	private class One {}
	class Two {
	    Two() {
		new One();
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-unqualified-concrete-16 FAILED


==== 15.9.1-qualified-concrete-1  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    empty_class T1591qc1 {
        class Inner{}
        Object o = new T1591qc1().new Inner();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-1 FAILED


==== 15.9.1-qualified-concrete-2  Concrete classes may be final  FAILED
==== Contents of test case:

    empty_class T1591qc2 {
        final class Inner{}
        Object o = new T1591qc2().new Inner();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-2 FAILED


==== 15.9.1-qualified-concrete-4  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T1591qc4_1.java {
package p1;
public class T1591qc4_1 {
    public class Inner{}
}
    }] [saveas p2/T1591qc4_2.java {
package p2;
import p1.*;
class T1591qc4_2 extends p1.T1591qc4_1 {
    Object o = new p1.T1591qc4_1().new Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-4 FAILED


==== 15.9.1-qualified-concrete-5  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T1591qc5_1.java {
package p1;
public class T1591qc5_1 {
    protected class Inner{
        public Inner(){}
    }
}
    }] [saveas p2/T1591qc5_2.java {
package p2;
import p1.*;
class T1591qc5_2 extends p1.T1591qc5_1 {
    Object o = new p1.T1591qc5_1().new Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-5 FAILED


==== 15.9.1-qualified-concrete-8  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    compile [saveas T1591qc8_1.java {
class T1591qc8_1 {
    protected class Inner{}
}
class T1591qc8_2 extends T1591qc8_1 {
    Object o = new T1591qc8_1().new Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-8 FAILED


==== 15.9.1-qualified-concrete-9  The simple name must be an
        accessible inner class of the qualifier  FAILED
==== Contents of test case:

    compile [saveas T1591qc9_1.java {
class T1591qc9_1 {
    class Inner{}
}
class T1591qc9_2 extends T1591qc9_1 {
    Object o = new T1591qc9_1().new Inner();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-9 FAILED


==== 15.9.1-qualified-concrete-15  The concrete class extends
        the inner class of the type of the qualifier  FAILED
==== Contents of test case:

    empty_class T1591qc15 {
        Object o = new T1591qc15(){
            class Inner{}
        }.new Inner();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-15 FAILED


==== 15.9.1-qualified-concrete-21  The ClassOrInterfaceType must
        be accessible  FAILED
==== Contents of test case:

    empty_class T1591qc21 {
	private class One {}
	class Two {
	    Two() {
		T1591qc21.this.new One();
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-21 FAILED


==== 15.9.1-qualified-concrete-23  The qualifier must be a primary,
        not a typename  FAILED
==== Contents of test case:

    empty_class T1591qc23 {
	class A {}
	{
	    T1591qc23 t = this;
	    t.new A(); // this is legal in spite of the chapter 15 grammar
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-23 FAILED


==== 15.9.1-qualified-concrete-25  The identifier is a typename  FAILED
==== Contents of test case:

    empty_class T1591qc25 {
	class A {}
	int A;
	int A() { return 0; }
	{ new T1591qc25().new A(); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.9.1-qualified-concrete-25 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/conditional-and-operator

==== 15.23-optimize-1  Test that a compiler that optimizes && does
        so correctly  FAILED
==== Contents of test case:

    empty_main T1523o1 {
	boolean b = true;
	if (b && true);
	if (!b && true);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.23-optimize-1 FAILED


==== 15.23-optimize-2  Test that a compiler that optimizes && does
        so correctly  FAILED
==== Contents of test case:

    empty_main T1523o2 {
	boolean b = true;
	if (true && b);
	if (true && !b);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.23-optimize-2 FAILED


==== 15.23-optimize-3  Test that a compiler that optimizes && does
        so correctly  FAILED
==== Contents of test case:

    empty_main T1523o3 {
	boolean b = true;
	if (b && false);
	if (!b && false);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.23-optimize-3 FAILED


==== 15.23-optimize-4  Test that a compiler that optimizes && does
        so correctly  FAILED
==== Contents of test case:

    empty_main T1523o4 {
	boolean b = true;
	if (false && b);
	if (false && !b);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.23-optimize-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/conditional-operator

==== 15.25-basic-1  ?: uses a boolean value to decide which
        of two other expressions should be evaluated  FAILED
==== Contents of test case:

    empty_main T1525b1 {String s = true ? "1" : "2";}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-basic-1 FAILED


==== 15.25-basic-2  ?: uses a boolean value to decide which
        of two other expressions should be evaluated  FAILED
==== Contents of test case:

    empty_main T1525b2 {String s = false ? "1" : "2";}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-basic-2 FAILED


==== 15.25-operand-type-1  second and third operands may
        be boolean  FAILED
==== Contents of test case:

    empty_main T1525ot1 {boolean b = true ? true : false;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-operand-type-1 FAILED


==== 15.25-operand-type-2  second and third operands may be null  FAILED
==== Contents of test case:

    empty_main T1525ot2 {String s = true ? null : null;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-operand-type-2 FAILED


==== 15.25-operand-type-3  second or third operands may be null  FAILED
==== Contents of test case:

    empty_main T1525ot3 {String s = true ? "" : null;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-operand-type-3 FAILED


==== 15.25-operand-type-4  second or third operands may be null  FAILED
==== Contents of test case:

    empty_main T1525ot4 {String s = true ? null : "";}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-operand-type-4 FAILED


==== 15.25-operand-type-mismatch-1  binary numeric promotion
        is applied to mismatched primitive operand types if no
        special cases apply  FAILED
==== Contents of test case:

    empty_main T1525otm1 {float f = true ? 0 : 0F;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-operand-type-mismatch-1 FAILED


==== 15.25-operand-type-mismatch-2  binary numeric promotion
        is applied to mismatched primitive operand types if no
        special cases apply  FAILED
==== Contents of test case:

    empty_main T1525otm2 {double d = false ? 'c' : 0D;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-operand-type-mismatch-2 FAILED


==== 15.25-operand-type-mismatch-3  binary numeric promotion
        is applied to mismatched primitive operand types if no
        special cases apply  FAILED
==== Contents of test case:

    empty_main T1525otm3 {long l = true ? (byte) 0 : 0L;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-operand-type-mismatch-3 FAILED


==== 15.25-operand-type-mismatch-5  reference operand types
        must match or they must support assignment conversion  FAILED
==== Contents of test case:

    empty_class T1525otm5 {
        class C1 {}
        class C2 extends C1 {}
        void foo() {
            Object o = true ? new C1() : new C2();
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-operand-type-mismatch-5 FAILED


==== 15.25-operand-type-mismatch-8  primitive and reference
        types don't mix, even in a method invocation  FAILED
==== Contents of test case:

    empty_class T1525otm8 {
        void foo(String s) {}
        void foo(int i) {}
        void bar() {
            foo(true ? "" : 42);
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.25-operand-type-mismatch-8 FAILED


==== 15.25-operand-type-mismatch-11  reference array types mix iff the
        component types are assignable  FAILED
==== Contents of test case:

    empty_main T1525otm11 {
	Object o = true ? new Integer[1] : new Number[1];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-operand-type-mismatch-11 FAILED


==== 15.25-error-1  Check for compiler error optimizing the
        following conditional operator  FAILED
==== Contents of test case:

    empty_class T1525e1 {
        boolean isNeg(int i) {
            return (i < 0) ? true : false;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.25-error-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/conditional-or-operator

==== 15.24-optimize-1  Test that a compiler that optimizes || does
        so correctly  FAILED
==== Contents of test case:

    empty_main T1524o1 {
	boolean b = true;
	if (b || true);
	if (!b || true);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.24-optimize-1 FAILED


==== 15.24-optimize-2  Test that a compiler that optimizes || does
        so correctly  FAILED
==== Contents of test case:

    empty_main T1524o2 {
	boolean b = true;
	if (true || b);
	if (true || !b);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.24-optimize-2 FAILED


==== 15.24-optimize-3  Test that a compiler that optimizes || does
        so correctly  FAILED
==== Contents of test case:

    empty_main T1524o3 {
	boolean b = true;
	if (b || false);
	if (!b || false);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.24-optimize-3 FAILED


==== 15.24-optimize-4  Test that a compiler that optimizes || does
        so correctly  FAILED
==== Contents of test case:

    empty_main T1524o4 {
	boolean b = true;
	if (false || b);
	if (false || !b);
	b = false;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.24-optimize-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/constant-expression

==== 15.28-primitive-2  literals are constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p2 {1L == 1L} {1f == 1f} {1.0 == 1.0} {true}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-2 FAILED


==== 15.28-primitive-3  casts can form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p3 {(boolean) true}  {(int) 1L == (float) 1.0}  {(char) 0x61 == 'a'}  {(char) 97.0D == 'a'}  {(double) 'a' == 97.0D}  {(int) 97L == (int) 'a'}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-3 FAILED


==== 15.28-primitive-4  Unary +, -, ~, ! form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p4 {+2 == 2} {-0x80000000 == 0x80000000}  {~0 == 0xffffffff} {!false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-4 FAILED


==== 15.28-primitive-5  ++ and -- are not constant expressions  FAILED
==== Contents of test case:

    empty_class T1528p5 {
        void foo(int i) {
            switch (i) {
                case i++:
            }
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.28-primitive-5 FAILED


==== 15.28-primitive-7  *, /, and % form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p7 {5 * 3 == 15} {5 / 3 == 1} {5 % 3 == 2}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-7 FAILED


==== 15.28-primitive-8  + and - form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p8 {1 + 2 == 3} {1 - 2 == -1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-8 FAILED


==== 15.28-primitive-9  <<, >>, and >>> form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p9 {2 << 1 == 4} {2 >> 1 == 1} {-2 >>> 1 == 0x7fffffff}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-9 FAILED


==== 15.28-primitive-10  <, <=, >, and >= form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p10 {1 < 2} {2 <= 2} {2 > 1} {1 >= 1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-10 FAILED


==== 15.28-primitive-11  == and != form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p11 {1 == 1} {1 != 2}  {true == true} {true != false}  {'a' == 'a'} {'a' != 'b'}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-11 FAILED


==== 15.28-primitive-12  bitwise &, ^, and | form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p12 {(0xaa & 0xa5) == 0xa0}  {(0xaa ^ 0xa5) == 0x0f}  {(0xaa | 0xa5) == 0xaf}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-12 FAILED


==== 15.28-primitive-13  logical &, ^, and | form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p13 {true & true} {true ^ false} {false | true}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-13 FAILED


==== 15.28-primitive-14  && and || form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528p14 {true && true} {true || false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-14 FAILED


==== 15.28-primitive-16  ?: forms a constant expression  FAILED
==== Contents of test case:

    constant_expression T1528p16 {true ? true : false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-primitive-16 FAILED


==== 15.28-simple-name-3  a final variable initialized
        by a constant expression is a constant expression  FAILED
==== Contents of test case:

    empty_class T1528sn3 {
        void foo (int j) {
            final int i = 1;
            switch (j) {
                case i:
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-simple-name-3 FAILED


==== 15.28-simple-name-6  a final variable initialized
        by a constant expression is a constant expression  FAILED
==== Contents of test case:

    empty_class T1528sn6 {
        void foo (int j) {
            final int i = true ? 1 : 0;
            switch (j) {
                case i:
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-simple-name-6 FAILED


==== 15.28-simple-name-9  a final variable initialized
        by a final variable that is initialized by constant expression
        is a constant expression  FAILED
==== Contents of test case:

    empty_class T1528sn9 {
        void foo (int j) {
            final int i1 = 2 * 2;
            final int i2 = i1;
            switch (j) {
                case i2:
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-simple-name-9 FAILED


==== 15.28-nonconst-simple-name-1  a non-final variable initialized
        by a constant expression is not a constant expression  FAILED
==== Contents of test case:

    empty_class T1528nsn1 {
        int i = 1;
        void foo (int j) {
            switch (j) {
                case i:
            }
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.28-nonconst-simple-name-1 FAILED


==== 15.28-nonconst-simple-name-2  a final variable initialized
        by a non-final variable is not a constant expression  FAILED
==== Contents of test case:

    empty_class T1528nsn2 {
        int i1 = 1;
        final int i2 = i1;
        void foo (int j) {
            switch (j) {
                case i2:
            }
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.28-nonconst-simple-name-2 FAILED


==== 15.28-nonconst-simple-name-3  a final variable initialized
        by a non-constant expression is not a constant expression  FAILED
==== Contents of test case:

    empty_class T1528nsn3 {
        int i1 = 0;
        final int i2 = i1++;
        void foo (int j) {
            switch (j) {
                case i2:
            }
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.28-nonconst-simple-name-3 FAILED


==== 15.28-cast-simple-name-1  a final variable initialized
        by a constant expression and then cast to a primitive is a
        constant expression  FAILED
==== Contents of test case:

    empty_class T1528csn1 {
        final long l1 = 1L;
        final long l2 = Long.MAX_VALUE;
        void foo (int j) {
            switch (j) {
                case (int) l1:
                case (int) l2:
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-cast-simple-name-1 FAILED


==== 15.28-cast-simple-name-2  a final variable initialized
        by a constant expression and then cast to a primitive is a
        constant expression  FAILED
==== Contents of test case:

    empty_class T1528csn2 {
        final boolean t = true;
        void foo (int j) {
            switch (j) {
                case 0:
                case ((boolean) t ? 1 : 0):
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-cast-simple-name-2 FAILED


==== 15.28-cast-simple-name-3  any number of casts
        can be applied to a constant expression  FAILED
==== Contents of test case:

    empty_class T1528csn3 {
        final byte b = (byte) (float) 1.0D;
        final char c = (char) b;
        final short s = (short) c;
        final int i = (int) s;
        final long l = (long) i;
        void foo (int j) {
            switch (j) {
                case 0:
                case (((double) l == 1.0D) ? (int) l : 0):
                case 2:
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-cast-simple-name-3 FAILED


==== 15.28-qualified-name-1  qualified references
        of final constant fields are constant  FAILED
==== Contents of test case:

    empty_class T1528qn1 {
        static final int i = 1;
        void foo(int j) {
            switch (j) {
                case T1528qn1.i:
                case Integer.MAX_VALUE:
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-qualified-name-1 FAILED


==== 15.28-string-1  literals are constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s1 {"" == ""} {"hello, world" == "hello, world"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-1 FAILED


==== 15.28-string-2  literals are constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s2 {"" + 1 == "1"}  {"" + 1L == "1"}  {"" + 1f == "1.0"}  {"" + 1.0 == "1.0"}  {"" + '1' == "1"}  {"" + true == "true"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-2 FAILED


==== 15.28-string-3  casts to type String are
        constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s3 {(String) "" == ""}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-3 FAILED


==== 15.28-string-4  casts to primitive types are
        constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s3 {"" + (boolean) true == "true"}  {"" + (int) 1.5 == "1"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-4 FAILED


==== 15.28-string-5  Unary +, -, ~, ! form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s5 {"" + +2 == "2"} {"" + -0x80000000 == "-2147483648"}  {"" + ~0 == "-1"}  {"" + !false == "true"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-5 FAILED


==== 15.28-string-6  *, /, and % form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s6 {"" + 5 * 3 == "15"}  {"" + 5 / 3 == "1"}  {"" + 5 % 3 == "2"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-6 FAILED


==== 15.28-string-7  String + forms constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s7 {"" + "test" + "ing" == "testing"}  {"a" + "b" == "\u0061b"}  {"" + ("1" + '2' + 3 +4L) == "1234"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-7 FAILED


==== 15.28-string-8  + and - form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s8 {"" + (1 + 2) == "3"}  {"" + (1 - 2) == "-1"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-8 FAILED


==== 15.28-string-9  <<, >>, and >>> form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s9 {"" + (2 << 1) == "4"}  {"" + (2 >> 1) == "1"}  {"" + (-2 >>> 1) == "2147483647"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-9 FAILED


==== 15.28-string-10  <, <=, >, and >= form constant expressions FAILED
==== Contents of test case:

    constant_expression T1528s10 {"" + (1 < 2) == "true"}  {"" + (2 <= 2) == "true"}  {"" + (2 > 1) == "true"}  {"" + (1 >= 1) == "true"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-10 FAILED


==== 15.28-string-11  == and != form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s11 {"1" == "1"} {"1" != "2"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-11 FAILED


==== 15.28-string-12  bitwise &, ^, and | form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s12 {"" + (0xaa & 0xa5) == "160"}  {"" + (0xaa ^ 0xa5) == "15"}  {"" + (0xaa | 0xa5) == "175"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-12 FAILED


==== 15.28-string-13  logical &, ^, and | form constant expressions FAILED
==== Contents of test case:

    constant_expression T1528s13 {"" + (true & true) == "true"}  {"" + (true ^ false) == "true"}  {"" + (false | true) == "true"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-13 FAILED


==== 15.28-string-14  && and || form constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s14 {"" + (true && true) == "true"}  {"" + (true || false) == "true"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-14 FAILED


==== 15.28-string-15  ?: forms constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s15 {"" + (true ? 1 : 2) == "1"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-15 FAILED


==== 15.28-string-16  ?: forms constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s16 {(true ? "1" : "") == "1"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-16 FAILED


==== 15.28-string-17  ?: forms constant expressions  FAILED
==== Contents of test case:

    constant_expression T1528s17 {"" + (true ? "foo" : "bar") == "foo"}  {"" + (false ? "foo" : "bar") == "bar"}  
---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-17 FAILED


==== 15.28-string-18  String concatenation form constants  FAILED
==== Contents of test case:

    empty_class T1528s18 {
        static final String a = "a";
        static final String b = "b";
        void foo(int i) {
            final String s = a + b;
            switch (i) {
                case 0:
                case ((s == "ab") ? 1 : 0):
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-18 FAILED


==== 15.28-string-19  test various uses of a constant String
        expression  FAILED
==== Contents of test case:

    empty_class T1528s19 {
	void m() {
	    ("1" + 2).toString();
	    ("1" + 2).valueOf(1);
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-string-19 FAILED


==== 15.28-simple-namestr-1  a final variable initialized
        by a constant expression is a constant expression  FAILED
==== Contents of test case:

    empty_class T1528sns1 {
        void foo (int j) {
            final String s = "1";
            switch (j) {
                case 0:
                case ((s == "1") ? 1 : 0):
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-simple-namestr-1 FAILED


==== 15.28-simple-namestr-2  a final variable initialized
        by a constant expression is a constant expression  FAILED
==== Contents of test case:

    empty_class T1528sns2 {
        void foo (int j) {
            final String s = "1" + "2";
            switch (j) {
                case 0:
                case ((s == "12") ? 1 : 0):
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-simple-namestr-2 FAILED


==== 15.28-simple-namestr-3  a final variable initialized
        by a constant expression is a constant expression  FAILED
==== Contents of test case:

    empty_class T1528sns3 {
        void foo (int j) {
            final String s = "1" + (int) 2.0D;
            switch (j) {
                case 0:
                case ((s == "12") ? 1 : 0):
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-simple-namestr-3 FAILED


==== 15.28-simple-namestr-4  a final variable initialized
        by a final variable that is initialized by constant expression
        is a constant expression  FAILED
==== Contents of test case:

    empty_class T1528sns4 {
        void foo (int j) {
            final String s1 = "1";
            final String s2 = s1;
            switch (j) {
                case 0:
                case ((s2 == "1") ? 1 : 0):
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-simple-namestr-4 FAILED


==== 15.28-simple-namestr-5  test various uses of a constant
        String  FAILED
==== Contents of test case:

    compile [saveas T1528sn5a.java {
class T1528sn5a {
    static final String s = "a";
}
class T1528sn5b {
    void m() {
	class Local extends T1528sn5a {
	    void m() {
		s.toString();
		s.valueOf(1);
	    }
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-simple-namestr-5 FAILED


==== 15.28-qualified-namestr-1  qualified
        references of final constant fields are constant  FAILED
==== Contents of test case:

    empty_class T1528qns1 {
        static final String s = "1";
        void foo(int j) {
            switch (j) {
                case 0:
                case ((T1528qns1.s == "1") ? 1 : 0):
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-qualified-namestr-1 FAILED


==== 15.28-example-1  Example constants  FAILED
==== Contents of test case:

    constant_expression T1528e1 {true} {(short)(1*2*3*4*5*6) == 720}  {Integer.MAX_VALUE / 2 == 0x3fffffff}  {2.0 * Math.PI == 6.283185307179586}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-example-1 FAILED


==== 15.28-example-2  Example constant  FAILED
==== Contents of test case:

    constant_expression T1528e2 {"The integer " + Long.MAX_VALUE +
    " is mighty big." == "The integer 9223372036854775807 is mighty big."}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-example-2 FAILED


==== 15.28-instanceof-5  use of a constant with instanceof  FAILED
==== Contents of test case:

    compile [saveas T1528i5a.java {
class T1528i5a {
    static final String s = "a";
}
class T1528i5b {
    void m() {
	class Local extends T1528i5a {
	    void m() {
		boolean b = s instanceof String;
	    }
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-instanceof-5 FAILED


==== 15.28-paren-1  A parenthesized constant expression is
        constant  FAILED
==== Contents of test case:

    constant_expression T1528paren1 { ((((1)+2)+3)+4 == 10) }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.28-paren-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/equality-operators

==== 15.21-assoc-3  a==b==c is (a==b)==c, and hence c must be
        boolean  FAILED
==== Contents of test case:

    constant_expression T1521a3 {1 == 2 == false} {1 != 2 == true}  {1 == 2 != true} {1 != 2 != false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-assoc-3 FAILED


==== 15.21-assoc-4  a==b==c is (a==b)==c, and hence c must be
        boolean  FAILED
==== Contents of test case:

    constant_expression T1521a4 {(1 == 2) == false} {(1 != 2) == true}  {(1 == 2) != true} {(1 != 2) != false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-assoc-4 FAILED


==== 15.21-assoc-5  a==b==c is (a==b)==c, and hence c must be
        boolean  FAILED
==== Contents of test case:

    constant_expression T1521a5 {true == false == false}  {true != false == true}  {true == false != true}  {true != false != false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-assoc-5 FAILED


==== 15.21-assoc-6  a==b==c is (a==b)==c, and hence c must be
        boolean  FAILED
==== Contents of test case:

    constant_expression T1521a6 {(true == false) == false}  {(true != false) == true}  {(true == false) != true}  {(true != false) != false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-assoc-6 FAILED


==== 15.21-assoc-7  a==b==c is (a==b)==c, and hence c must be
        boolean  FAILED
==== Contents of test case:

    constant_expression T1521a7 {"1" == "2" == false} {"1" != "2" == true}  {"1" == "2" != true} {"1" != "2" != false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-assoc-7 FAILED


==== 15.21-assoc-8  a==b==c is (a==b)==c, and hence c must be
        boolean  FAILED
==== Contents of test case:

    constant_expression T1521a8 {("1" == "2") == false} {("1" != "2") == true}  {("1" == "2") != true} {("1" != "2") != false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-assoc-8 FAILED


==== 15.21-precedence-1  == is lower than <  FAILED
==== Contents of test case:

    constant_expression T1521p1 {1 < 2 == 2 < 3} {(1 < 2) == (2 < 3)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-precedence-1 FAILED


==== 15.21-equal-1  a!=b is !(a==b)  FAILED
==== Contents of test case:

    constant_expression T1521e1 {(1!=2) == (!(1==2))} {(1!=1) == (!(1==1))}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-equal-1 FAILED


==== 15.21-equal-2  a!=b is !(a==b)  FAILED
==== Contents of test case:

    constant_expression T1521e2 {(true!=true) == (!(true==true))}  {(true!=false) == (!(true==false))}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-equal-2 FAILED


==== 15.21-equal-3  a!=b is !(a==b)  FAILED
==== Contents of test case:

    constant_expression T1521e3 {("1"!="1") == (!("1"=="1"))}  {("1"!="2") == (!("1"=="2"))}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-equal-3 FAILED


==== 15.21-type-8  in a==b, if a is boolean, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t8 {
	boolean b = true == System.out.println();
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.21-type-8 FAILED


==== 15.21-type-13  in a==b, if a is numeric, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t13 {
	boolean b = 1 == '1';
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-type-13 FAILED


==== 15.21-type-14  in a==b, if a is numeric, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t14 {
	boolean b = 1 == 1f;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-type-14 FAILED


==== 15.21-type-15  in a==b, if a is numeric, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t15 {
	boolean b = 1 == 1.;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-type-15 FAILED


==== 15.21-type-18  in a==b, if a is numeric, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t18 {
	boolean b = 1 == System.out.println();
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.21-type-18 FAILED


==== 15.21-type-26  in a==b, if a is a reference, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t26 {
	boolean b = null == "1";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-type-26 FAILED


==== 15.21-type-28  in a==b, if a is a reference, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t28 {
	boolean b = null == System.out.println();
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.21-type-28 FAILED


==== 15.21-type-29  in a==b, if a is a reference, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t29 {
	boolean b = null == new Boolean(true);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-type-29 FAILED


==== 15.21-type-37  in a==b, if a is a reference, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t37 {
	boolean b = "null" == null;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-type-37 FAILED


==== 15.21-type-38  in a==b, if a is a reference, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t38 {
	boolean b = "" == System.out.println();
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.21-type-38 FAILED


==== 15.21-type-39  in a==b, if a is a reference, b must be too  FAILED
==== Contents of test case:

    empty_main T1521t39 {
	boolean b = new Object() == new Integer(1);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21-type-39 FAILED


==== 15.21-type-41  void==void is not valid  FAILED
==== Contents of test case:

    empty_main T1521t41 {
	boolean b = System.out.println() == System.out.println();
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.21-type-41 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/equality-operators/numerical-equality

==== 15.21.1-promote-1  Binary promotion is done for numeric ==  FAILED
==== Contents of test case:

    # Note the same bit patterns
    constant_expression T15211p1 {(char)0xffff != (short)0xffff}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-promote-1 FAILED


==== 15.21.1-promote-2  Binary promotion is done for numeric ==  FAILED
==== Contents of test case:

    # Note the different bit patterns
    constant_expression T15211p2 {(short)0xffff == (byte)0xff}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-promote-2 FAILED


==== 15.21.1-promote-3  Binary promotion is done for numeric ==  FAILED
==== Contents of test case:

    # Note the same decimal starting point
    constant_expression T15211p3 {.1f != .1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-promote-3 FAILED


==== 15.21.1-floating-1  In floating point, -0 == 0  FAILED
==== Contents of test case:

    constant_expression T15211f1 {0. == -0.} {!(0. != -0.)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-floating-1 FAILED


==== 15.21.1-floating-2  In floating point, -0 == 0  FAILED
==== Contents of test case:

    constant_expression T15211f2 {0f == -0f} {!(0f != -0f)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-floating-2 FAILED


==== 15.21.1-floating-3  In floating point, NaN is never ==  FAILED
==== Contents of test case:

    constant_expression T15211f3 {Double.NaN != Double.NaN}  {!(Double.NaN == Double.NaN)}  {Float.NaN != Float.NaN}  {!(Float.NaN == Float.NaN)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-floating-3 FAILED


==== 15.21.1-floating-4  In floating point, NaN is never ==  FAILED
==== Contents of test case:

    constant_expression T15211f4 {Double.NaN != 0}  {!(Double.NaN == 0)}  {Double.NaN != -0.}  {!(Double.NaN == -0.)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-floating-4 FAILED


==== 15.21.1-floating-5  In floating point, NaN is never ==  FAILED
==== Contents of test case:

    constant_expression T15211f5 {Float.NaN != 0}  {!(Float.NaN == 0)}  {Float.NaN != -0f}  {!(Float.NaN == -0f)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-floating-5 FAILED


==== 15.21.1-floating-6  In floating point, NaN is never ==  FAILED
==== Contents of test case:

    constant_expression T15211f6 {Double.NaN != Double.POSITIVE_INFINITY}  {!(Double.NaN == Double.POSITIVE_INFINITY)}  {Double.NaN != Double.NEGATIVE_INFINITY}  {!(Double.NaN == Double.NEGATIVE_INFINITY)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-floating-6 FAILED


==== 15.21.1-floating-7  In floating point, NaN is never ==  FAILED
==== Contents of test case:

    constant_expression T15211f7 {Float.NaN != Float.POSITIVE_INFINITY}  {!(Float.NaN == Float.POSITIVE_INFINITY)}  {Float.NaN != Float.NEGATIVE_INFINITY}  {!(Float.NaN == Float.NEGATIVE_INFINITY)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-floating-7 FAILED


==== 15.21.1-floating-8  In floating point, infinities compare only
        to themselves  FAILED
==== Contents of test case:

    constant_expression T15211f8  {Double.POSITIVE_INFINITY == Double.POSITIVE_INFINITY}  {Double.POSITIVE_INFINITY != Double.NEGATIVE_INFINITY}  {Double.NEGATIVE_INFINITY == Double.NEGATIVE_INFINITY}  {Double.POSITIVE_INFINITY != 0}  {Double.NEGATIVE_INFINITY != -0.}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-floating-8 FAILED


==== 15.21.1-floating-9  In floating point, infinities compare only
        to themselves  FAILED
==== Contents of test case:

    constant_expression T15211f9  {Float.POSITIVE_INFINITY == Float.POSITIVE_INFINITY}  {Float.POSITIVE_INFINITY != Float.NEGATIVE_INFINITY}  {Float.NEGATIVE_INFINITY == Float.NEGATIVE_INFINITY}  {Float.POSITIVE_INFINITY != 0}  {Float.NEGATIVE_INFINITY != -0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.1-floating-9 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/equality-operators/reference-equality

==== 15.21.3-type-2  In reference equality, the two types must be
        cast convertible  FAILED
==== Contents of test case:

    empty_main T15213t2 {
	boolean b = new Integer(1) == (Object) "";
	b = (Object) new Integer(1) == "";
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.3-type-2 FAILED


==== 15.21.3-type-3  In reference equality, the two types must be
        cast convertible  FAILED
==== Contents of test case:

    empty_class T15213t3 {
	interface I {}
	class C {}
	boolean m(I i, C c) {
	    return i == c;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.3-type-3 FAILED


==== 15.21.3-type-5  In reference equality, the two types must be
        cast convertible  FAILED
==== Contents of test case:

    empty_class T15213t5 {
	interface I {}
	final class C {}
	boolean m(I i, C c) {
	    return (i == (Object) c) || ((Object) i == c);
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.3-type-5 FAILED


==== 15.21.3-type-7  In reference equality, the two types must be
        cast convertible  FAILED
==== Contents of test case:

    empty_class T15213t7 {
	interface I1 {
	    void m();
	}
	interface I2 {
	    int m();
	}
	boolean m(I1 i1, I2 i2) {
	    return ((Object) i1 == i2) || (i1 == (Object) i2);
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.3-type-7 FAILED


==== 15.21.3-type-8  In reference equality, the two types must be
        cast convertible  FAILED
==== Contents of test case:

    empty_class T15213t8 {
	interface I {
	    void m();
	}
	class C {
	    int m() { return 1; }
	}
	boolean m(I i, C c) {
	    // Note that no subclass of C can implement i!
	    return i == c;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.3-type-8 FAILED


==== 15.21.3-type-9  In reference equality, the two types must be
        cast convertible  FAILED
==== Contents of test case:

    empty_class T15213t9 {
	boolean m(Cloneable c, int[] i) {
	    return c == i;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.3-type-9 FAILED


==== 15.21.3-type-11  In reference equality, the two types must be
        cast convertible  FAILED
==== Contents of test case:

    empty_class T15213t11 {
	interface I {}
	boolean m(I i, int[] a) {
	    return ((Object)i == a) || (i == (Object) a);
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.21.3-type-11 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/field-access-expressions/accessing-superclass-members-using-super

==== 15.11.2-syntax-1  The type in the qualified super is not
        obscured  FAILED
==== Contents of test case:

    compile [saveas T15112s1a.java {
class T15112s1a {
    int i;
}
class T15112s1b extends T15112s1a {
    int T15112s1b; // obscure the class name from normal expressions
    int j = T15112s1b.super.i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-syntax-1 FAILED


==== 15.11.2-explicit-constructor-2  Cannot access instance fields
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T15112ec2 {
	class One {
	    int i;
	}
	class Two extends One {
	    class Inner {
		Inner(int i) {}
		Inner() {
		    // calling super field of enclosing class is legal
		    this(Two.super.i);
		}
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-explicit-constructor-2 FAILED


==== 15.11.2-use-11  super.field must refer to a single accessible
        field in the superclass  FAILED
==== Contents of test case:

    empty_class T15112u11 {
	class A {
	    int i;
	}
	interface B {
	    Object i = null;
	}
	class C extends A implements B {
	    int j = super.i; // refers to A.i, not B.i
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-use-11 FAILED


==== 15.11.2-meaning-1  super.field is (almost) ((S)this).field  FAILED
==== Contents of test case:

    empty_class T15112m1 {
	class A {
	    int i;
	}
	class B extends A {
	    Object i;
	    int j = super.i;
	    int k = ((A) this).i;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-1 FAILED


==== 15.11.2-meaning-2  super.field is (almost) ((S)this).field  FAILED
==== Contents of test case:

    compile [saveas p1/T15112m2a.java {
package p1;
public class T15112m2a {
    protected int i;
}
    }] [saveas T15112m2b.java {
class T15112m2b extends p1.T15112m2a {
    Object i;
    int j = super.i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-2 FAILED


==== 15.11.2-meaning-4  super.field is (almost) ((S)this).field  FAILED
==== Contents of test case:

    compile [saveas p1/T15112m4a.java {
package p1;
public class T15112m4a {
    protected static int i;
}
    }] [saveas T15112m4b.java {
class T15112m4b extends p1.T15112m4a {
    Object i;
    int j = super.i;
    int k = ((p1.T15112m4a) this).i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-4 FAILED


==== 15.11.2-meaning-6  super.field is (almost) ((S)this).field  FAILED
==== Contents of test case:

    compile [saveas p1/T15112m6c.java {
package p1;
class T15112m6a {
    protected int i;
}
interface T15112m6b {
    int i = 1;
}
public class T15112m6c extends T15112m6a implements T15112m6b {}
    }] [saveas T15112m6d.java {
class T15112m6d extends p1.T15112m6c {
    int j = ((p1.T15112m6c) this).i; // a.i not accessible, so this is b.i
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-6 FAILED


==== 15.11.2-meaning-7  super.field is (almost) ((S)this).field  FAILED
==== Contents of test case:

    empty_class T15112m7 {
	class A {
	    private int i;
	}
	class B extends A {
	    Object i;
	    int j = super.i;
	    int k = ((A) this).i;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-7 FAILED


==== 15.11.2-meaning-8  T.super.field is (almost)
        ((S)T.this).field  FAILED
==== Contents of test case:

    empty_class T15112m8 {
	class A {
	    int i;
	}
	class B extends A {
	    Object i;
	    int j = B.super.i;
	    int k = ((A) B.this).i;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-8 FAILED


==== 15.11.2-meaning-9  T.super.field is (almost)
        ((S)T.this).field  FAILED
==== Contents of test case:

    compile [saveas p1/T15112m9a.java {
package p1;
public class T15112m9a {
    protected int i;
}
    }] [saveas T15112m9b.java {
class T15112m9b extends p1.T15112m9a {
    Object i;
    int j = T15112m9b.super.i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-9 FAILED


==== 15.11.2-meaning-11  T.super.field is (almost)
        ((S)T.this).field  FAILED
==== Contents of test case:

    compile [saveas p1/T15112m11a.java {
package p1;
public class T15112m11a {
    protected static int i;
}
    }] [saveas T15112m11b.java {
class T15112m11b extends p1.T15112m11a {
    Object i;
    int j = T15112m11b.super.i;
    int k = ((p1.T15112m11a) T15112m11b.this).i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-11 FAILED


==== 15.11.2-meaning-13  T.super.field is (almost)
        ((S)T.this).field  FAILED
==== Contents of test case:

    compile [saveas p1/T15112m13c.java {
package p1;
class T15112m13a {
    protected int i;
}
interface T15112m13b {
    int i = 1;
}
public class T15112m13c extends T15112m13a implements T15112m13b {}
    }] [saveas T15112m13d.java {
class T15112m13d extends p1.T15112m13c {
    // a.i not accessible, so this is b.i
    int j = ((p1.T15112m13c) T15112m13d.this).i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-13 FAILED


==== 15.11.2-meaning-14  T.super.field is (almost)
        ((S)T.this).field  FAILED
==== Contents of test case:

    empty_class T15112m14 {
	class A {
	    private int i;
	}
	class B extends A {
	    Object i;
	    int j = B.super.i;
	    int k = ((A) B.this).i;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-14 FAILED


==== 15.11.2-meaning-17  T.super.field is (almost)
        ((S)T.this).field  FAILED
==== Contents of test case:

    empty_class T15112m17 {
	class A {
	    int i;
	}
	class S {
	    Object i;
	}
	class B extends A {
	    Object i;
	    class Inner extends S {
		Object i;
		int j = B.super.i;
		int k = ((A) B.this).i;
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.2-meaning-17 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/field-access-expressions/using-a-primary

==== 15.11.1-ambiguous-2  There is no ambiguity if one field
        is not accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T15111a2a.java {
package p1;
public class T15111a2a {
    int i = 1;
}
}] [saveas T15111a2b.java {
interface T15111a2b {
    int i = 2;
}
class T15111a2c extends p1.T15111a2a implements T15111a2b {
    static int j = new T15111a2c().i; // only b.i is accessible
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.1-ambiguous-2 FAILED


==== 15.11.1-ambiguous-3  There is no ambiguity if one field
        is not accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T15111a3a.java {
package p1;
public class T15111a3a {
    protected int i = 1;
}
}] [saveas T15111a3b.java {
interface T15111a3b {
    int i = 2;
}
class T15111a3c extends p1.T15111a3a implements T15111a3b {}
class T15111a3d extends T15111a3c {
    // Even though d inherits two versions of i, the protected a.i
    // is only accessible if the qualifying expression is type d or lower
    static int j = new T15111a3c().i; // only b.i is accessible
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.1-ambiguous-3 FAILED


==== 15.11.1-explicit-constructor-1  Cannot access instance fields
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T15111ec1 {
	int i;
	T15111ec1(int i) {}
	class Sub extends T15111ec1 {
	    Sub() {
		// using the enclosing i, not the inherited i, is legal
		super(T15111ec1.this.i);
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.1-explicit-constructor-1 FAILED


==== 15.11.1-explicit-constructor-2  Cannot access instance fields
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T15111ec2 {
	int i;
	class Inner {
	    Inner(int i) {}
	    Inner() {
		// explicit mention of the only version of i
		this(T15111ec2.this.i);
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.11.1-explicit-constructor-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/method-invocation-expressions/chosen-method-appropriate

==== 15.12.3-explicit-constructor-3  Cannot access instance methods
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T15123ec3 {
	int m() { return 1; }
	class Inner {
	    Inner(int i) {}
	    Inner() {
		this(m()); // m is not inherited, and this$0.m is available
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.3-explicit-constructor-3 FAILED


==== 15.12.3-explicit-constructor-4  Cannot access instance methods
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T15123ec4 {
	int m() { return 1; }
	T15123ec4(int i) {}
	class Sub extends T15123ec4 {
	    Sub() {
		// calling the enclosing m, not the inherited m, is legal
		super(T15123ec4.this.m());
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.3-explicit-constructor-4 FAILED


==== 15.12.3-explicit-constructor-5  Cannot access instance methods
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T15123ec5 {
	int m() { return 1; }
	class Inner {
	    Inner(int i) {}
	    Inner() {
		// explicit mention of the only version of m
		this(T15123ec5.this.m());
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.3-explicit-constructor-5 FAILED


==== 15.12.3-explicit-constructor-7  Cannot access instance methods
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T15123ec7 {
	class One {
	    int m() { return 1; }
	}
	class Two extends One {
	    class Inner {
		Inner(int i) {}
		Inner() {
		    // calling super method of enclosing class is legal
		    this(Two.super.m());
		}
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.3-explicit-constructor-7 FAILED


==== 15.12.3-explicit-constructor-9  Cannot access instance methods
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T15123ec9 {
	private int m() { return 1; }
	T15123ec9(int i) {}
	class Sub extends T15123ec9 {
	    Sub() {
		super(m()); // m is not inherited, so it is the enclosing m
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.3-explicit-constructor-9 FAILED


==== 15.12.3-explicit-constructor-10  Cannot access instance methods
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    compile [saveas p1/T15123ec10a.java {
package p1;
public class T15123ec10a {
    int m() { return 1; }
    class C extends p2.T15123ec10b {
	C(int j) {}
	C() {
	    // c does not inherit m(), so use the enclosing version
	    this(m());
	}
    }
}
    }] [saveas p2/T15123ec10b.java {
package p2;
public class T15123ec10b extends p1.T15123ec10a {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.3-explicit-constructor-10 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/method-invocation-expressions/determine-class-or-interface

==== 15.12.1-syntax-1  The type in the qualified super is not
        obscured  FAILED
==== Contents of test case:

    empty_class T15121s1 {
        int T15121s1; // obscure the class name from normal expressions
        String s = T15121s1.super.toString();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.1-syntax-1 FAILED


==== 15.12.1-type-2  The type to search for plain MethodName is the
        innermost enclosing type which contains a method by that name  FAILED
==== Contents of test case:

    empty_class T15121t2 {
	void m() {}
	class A {
	    void m(int i) {}
	    { m(1); } // A is searched, not T15121t1; and A.m(int) exists
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.1-type-2 FAILED


==== 15.12.1-type-10  The type to search for super.MethodName is
        the superclass, which must exist  FAILED
==== Contents of test case:

    empty_class T15121t10 {
	class A {
	    void m() {}
	}
	class B extends A {
	    { super.m(); }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.1-type-10 FAILED


==== 15.12.1-type-14  The type to search for
        ClassName.super.MethodName is the superclass of ClassName  FAILED
==== Contents of test case:

    empty_class T15121t14 {
	class A {
	    void m() {}
	}
	class B extends A {
	    { B.super.m(); }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.1-type-14 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/method-invocation-expressions/determine-method-signature/applicable-and-accessible

==== 15.12.2.1-accessibility-constructor-1 
        A constructor must be applicable and accessible,
        in this case the constructor is private so it
        is not accessible even though it is applicable  FAILED
==== Contents of test case:

    compile [saveas T151221ac1.java {
class T151221ac1 {
    public T151221ac1(String s) {}
    private T151221ac1(Integer i) {}
}
class T151221ac1_Test {
    Object o = new T151221ac1(null);
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.1-accessibility-constructor-1 FAILED


==== 15.12.2.1-accessibility-constructor-2 
        A private constructor is not accessible  FAILED
==== Contents of test case:

    compile [saveas T151221ac2.java {
class T151221ac2 {
    public T151221ac2(String x, String y) {}
    private T151221ac2(String x, char[] y) {}
}
class T151221ac2_Test {
    Object o = new T151221ac2("hi", null);
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.1-accessibility-constructor-2 FAILED


==== 15.12.2.1-accessibility-method-1 
        A method must be applicable and accessible,
        in this case the method is private so it
        is not accessible even though it is applicable  FAILED
==== Contents of test case:

    compile [saveas T151221am1.java {
class T151221am1 {
    public int foo(String s) { return 0; }
    private int foo(Integer i) { return 0; }
}
class T151221am1_Test {
    int i = new T151221am1().foo(null);
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.1-accessibility-method-1 FAILED


==== 15.12.2.1-accessibility-method-3  A method must be applicable
        and accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T151221am3c.java {
package p1;
abstract class T151221am3a {
    abstract void m(); // note non-public accessibility
}
interface T151221am3b {
    void m() throws Exception;
}
public abstract class T151221am3c extends T151221am3a implements T151221am3b {
    // inherits 2 versions of m()
}
    }] [saveas T151221am3d.java {
abstract class T151221am3d extends p1.T151221am3c {
    // a concrete subclass of c will necessarily have an implementation of m
    // that does not throw, in order to implement a.m; but only b.m was
    // inherited here because of accessibility. Since b.m throws, the catch
    // clause is reachable
    {
	try {
	    m();
	} catch (Exception e) {
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.1-accessibility-method-3 FAILED


==== 15.12.2.1-accessibility-method-5  A method must be applicable
        and accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T151221am5c.java {
package p1;
abstract class T151221am5a {
    abstract void m(); // note non-public accessibility
}
interface T151221am5b {
    void m() throws Exception;
}
public abstract class T151221am5c extends T151221am5a implements T151221am5b {
    // inherits 2 versions of m()
}
    }] [saveas T151221am5d.java {
class T151221am5d {
    // a concrete subclass of c will necessarily have an implementation of m
    // that does not throw, in order to implement a.m; but since only b.m is
    // accessible here, the catch clause is reachable
    void m(p1.T151221am5c t) {
	try {
	    t.m();
	} catch (Exception e) {
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.1-accessibility-method-5 FAILED


==== 15.12.2.1-accessibility-method-6  A method must be applicable
        and accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T151221am6a.java {
package p1;
public class T151221am6a {
    public static class E1 extends Exception {}
    public static class E2 extends Exception {}
    public static abstract class A {
	protected abstract void m() throws E1; // note non-public accessibility
    }
}
    }] [saveas T151221am6b.java {
class T151221am6b extends p1.T151221am6a {
    interface B {
	void m() throws E2;
    }
    static abstract class C extends A implements B {
	// c inherits two versions of m
    }
    static abstract class D extends C {
	// likewise, d inherits two versions of m, but protected accessibility
	// rules state that access to a.m is only possible when the qualifier
	// is d or below. When both methods are accessible, the method cannot
	// throw either exception; but alone, b.m may throw.
	{
	    m(); // merged throws clause
	    try {
		((C) this).m(); // only b.m accessible
	    } catch (E2 e) {
	    }
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.1-accessibility-method-6 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/method-invocation-expressions/determine-method-signature/choose-most-specific

==== 15.12.2.2-ambiguous-1  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so A.foo(String) is more specific than
        T151222a1.foo(Object).  FAILED
==== Contents of test case:

    compile [saveas T151222a1.java {
interface A {
    void foo(String s);
}
abstract class T151222a1 implements A {
    void foo(Object o) {}
    {
	foo("");
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-1 FAILED


==== 15.12.2.2-ambiguous-2  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so A.foo(String) is more specific than
        B.foo(Object).  FAILED
==== Contents of test case:

    compile [saveas T151222a2.java {
interface A {
    void foo(String s);
}
interface B {
    void foo(Object o);
}
abstract class T151222a2 implements A, B {
    {
	foo("");
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-2 FAILED


==== 15.12.2.2-ambiguous-3  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so A.foo(String) is more specific than
        T151222a3.foo(Object).  FAILED
==== Contents of test case:

    compile [saveas T151222a3.java {
class A {
    void foo(String s) {}
}
abstract class T151222a3 extends A {
    void foo(Object o) {}
    {
	foo("");
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-3 FAILED


==== 15.12.2.2-ambiguous-4  When multiple maximally specific methods
        have the same signature, any non-abstract version is chosen  FAILED
==== Contents of test case:

    compile [saveas T151222a4a.java {
class T151222a4a {
    public void m() {}
}
interface T151222a4b {
    void m();
}
class T151222a4c extends T151222a4a implements T151222a4b {
    { m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-4 FAILED


==== 15.12.2.2-ambiguous-5  When multiple maximally specific methods
        have the same signature, and all are abstract, it is arbitrary which
        is chosen, although the throws clauses are merged  FAILED
==== Contents of test case:

    compile [saveas T151222a4a.java {
abstract class T151222a5a {
    public abstract void m();
}
interface T151222a5b {
    void m();
}
abstract class T151222a5c extends T151222a5a implements T151222a5b {
    { m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-5 FAILED


==== 15.12.2.2-ambiguous-6  When multiple maximally specific methods
        have the same signature, and all are abstract, it is arbitrary which
        is chosen, although the throws clauses are merged  FAILED
==== Contents of test case:

    compile [saveas T151222a6a.java {
class E1 extends Exception {}
class E2 extends Exception {}
class E3 extends Exception {}
abstract class T151222a6a {
    public abstract void m() throws E1, E2;
}
interface T151222a6b {
    void m() throws E2, E3;
}
abstract class T151222a6c extends T151222a6a implements T151222a6b {
    {
        try {
            m(); // whether a.m() or b.m() is chosen, it cannot throw E1 or E3
        } catch (E2 e2) {
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-6 FAILED


==== 15.12.2.2-ambiguous-7  Example where accessibility makes
        what would otherwise be ambiguous maximally specific methods with
        conflicting signatures have a single resolution  FAILED
==== Contents of test case:

    compile [saveas p1/T151222a7a.java {
package p1;
public class T151222a7a {
    void m(Object o, String s) {}
}
    }] [saveas T151222a7b.java {
interface T151222a7b {
    void m(String s, Object o);
}
abstract class T151222a7c extends p1.T151222a7a implements T151222a7b {
    { m("", ""); } // only b.m(String, Object) is accessible
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-7 FAILED


==== 15.12.2.2-ambiguous-8  Example where accessibility makes
        what would otherwise be ambiguous maximally specific methods with
        conflicting signatures have a single resolution  FAILED
==== Contents of test case:

    compile [saveas p1/T151222a8a.java {
package p1;
public class T151222a8a {
    protected void m(Object o, String s) {}
}
    }] [saveas T151222a8b.java {
interface T151222a8b {
    void m(String s, Object o);
}
abstract class T151222a8c extends p1.T151222a8a implements T151222a8b {}
abstract class T151222a8d extends T151222a8c {
    // Even though d inherits two versions of m, the protected a.m
    // is only accessible if the qualifying expression is type d or lower
    void foo(T151222a8c c) {
        c.m("", "");
    } // only b.m(String, Object) is accessible
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-8 FAILED


==== 15.12.2.2-ambiguous-12  When multiple maximally specific methods
        have the same signature, and all are abstract, it is arbitrary which
        is chosen, although the throws clauses are merged  FAILED
==== Contents of test case:

    compile [saveas T151222a12a.java {
class E1 extends Exception {}
class E2 extends E1 {}
class E3 extends Exception {}
class E4 extends E3 {}
abstract class T151222a12a {
    public abstract void m() throws E1, E4;
}
interface T151222a12b {
    void m() throws E2, E3;
}
abstract class T151222a12c extends T151222a12a implements T151222a12b {
    {
        try {
            m();
	    // whether a.m() or b.m() is chosen, it cannot throw E1 or E3
	    // directly; but can throw something assignable to E1 or E3
        } catch (E2 e2) {
        } catch (E4 e4) {
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-12 FAILED


==== 15.12.2.2-ambiguous-13  When multiple maximally specific methods
        have the same signature, and all are abstract, it is arbitrary which
        is chosen, although the throws clauses are merged  FAILED
==== Contents of test case:

    compile [saveas T151222a13a.java {
class E1 extends Exception {}
class E2 extends E1 {}
class E3 extends Exception {}
class E4 extends E3 {}
abstract class T151222a13a {
    public abstract void m() throws E1, E4;
}
interface T151222a13b {
    void m() throws E2, E3;
}
abstract class T151222a13c extends T151222a13a implements T151222a13b {
    {
        try {
            m();
	    // whether a.m() or b.m() is chosen, it cannot throw E1 or E3
	    // directly; but can throw something assignable to E1 or E3
        } catch (E1 e1) {
        } catch (E3 e3) {
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-13 FAILED


==== 15.12.2.2-ambiguous-14  When multiple maximally specific methods
        have the same signature, and all are abstract, it is arbitrary which
        is chosen, although the throws clauses are merged  FAILED
==== Contents of test case:

    empty_class T151222a14 {
	class E1 extends Exception {}
	class E2 extends Exception {}
	abstract class C1 {
	    abstract void m() throws E1; // note non-public accessibility
	}
	interface I {
	    void m() throws E2;
	}
	abstract class C2 extends C1 implements I {
	    { m(); }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-14 FAILED


==== 15.12.2.2-ambiguous-17  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so T151222a17a.foo(int) is more specific than
        T151222a17b.foo(long).  FAILED
==== Contents of test case:

    compile [saveas T151222a17a.java {
class T151222a17a {
    static void foo(int i) {}
}
class T151222a17b extends T151222a17a {
    static void foo(long l) {}
    { foo(0); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-17 FAILED


==== 15.12.2.2-ambiguous-21  Example where accessibility makes
        what would otherwise be ambiguous maximally specific methods with
        conflicting signatures have a single resolution  FAILED
==== Contents of test case:

    compile [saveas p1/T151222a21a.java {
package p1;
public class T151222a21a {
    protected void m(Object o, String s) {}
    public void m(String s, Object o) {}
}
    }] [saveas T151222a21b.java {
class T151222a21b extends p1.T151222a21a {
    // Even though b inherits two versions of m, the protected a.m
    // is only accessible if the qualifying expression is type b or lower
    void foo(p1.T151222a21a t) {
        t.m("", "");
    } // only a.m(String, Object) is accessible
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-21 FAILED


==== 15.12.2.2-ambiguous-25  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so T151222a25a.foo(int) is more specific than
        T151222a25b.foo(long).  FAILED
==== Contents of test case:

    compile [saveas T151222a25a.java {
class T151222a25a {
    static void foo(int i) {}
}
class T151222a25b extends T151222a25a {
    static void foo(long l) throws Exception {}
    { foo(0); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-25 FAILED


==== 15.12.2.2-ambiguous-27  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so T151222a27a.foo(int) is more specific than
        T151222a27b.foo(long).  FAILED
==== Contents of test case:

    compile [saveas T151222a27a.java {
class T151222a27a {
    void foo(int i) {}
}
class T151222a27b extends T151222a27a {
    void foo(long l) throws Exception {}
    { foo(0); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-27 FAILED


==== 15.12.2.2-ambiguous-29  More than one maximally specific method
        is ambiguous, and illegal.  FAILED
==== Contents of test case:

    empty_class T151222a29 {
        void m(int i, byte b) {}
        void m(byte b, int i) {}
        void n(byte b1, byte b2) {
            m(b, b);
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.12.2.2-ambiguous-29 FAILED


==== 15.12.2.2-ambiguous-31  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so concrete Object.toString() is chosen over
        abstract I.toString().  FAILED
==== Contents of test case:

    empty_class T151222a31 {
        interface I {
            String toString();
        }
        class A implements I {}
        class B extends A {
            { super.toString(); }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-31 FAILED


==== 15.12.2.2-ambiguous-32  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so concrete Object.toString() is chosen over
        abstract I.toString().  FAILED
==== Contents of test case:

    empty_class T151222a32 {
        interface I {
            String toString();
        }
        abstract class A implements I {}
        class B extends A {
            { super.toString(); }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-32 FAILED


==== 15.12.2.2-ambiguous-33  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so concrete Object.toString() is chosen over
        implicit abstract I.toString().  FAILED
==== Contents of test case:

    empty_class T151222a33 {
        interface I {}
        class A implements I {}
        class B extends A {
            { super.toString(); }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-33 FAILED


==== 15.12.2.2-ambiguous-34  More than one maximally specific method
        is ambiguous, and illegal.  By JLS2 Clarifications, declaring type
        is no longer considered, so concrete Object.toString() is chosen over
        implicit abstract I.toString().  FAILED
==== Contents of test case:

    empty_class T151222a34 {
        interface I {}
        abstract class A implements I {}
        class B extends A {
            { super.toString(); }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.12.2.2-ambiguous-34 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/multiplicative-operators

==== 15.17-void-2  void is not a primitive numeric type  FAILED
==== Contents of test case:

    empty_class T1517void2 {int i = 2/System.out.println();}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.17-void-2 FAILED


==== 15.17-mult-1  * is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517mult1 {2*2 == 4}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-mult-1 FAILED


==== 15.17-mult-2  * is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517mult2 {2L*2L == 4L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-mult-2 FAILED


==== 15.17-mult-3  * is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517mult3 {2.0F * 2.0F == 4.0F}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-mult-3 FAILED


==== 15.17-mult-4  * is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517mult4 {2.0D * 2.0D == 4.0D}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-mult-4 FAILED


==== 15.17-div-1  / is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517div1 {2/2 == 1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-div-1 FAILED


==== 15.17-div-2  / is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517div2 {2L/2L == 1L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-div-2 FAILED


==== 15.17-div-3  / is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517div3 {2.0F / 2.0F == 1.0F}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-div-3 FAILED


==== 15.17-div-4  / is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517div4 {2.0D / 2.0D == 1.0D}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-div-4 FAILED


==== 15.17-mod-1  % is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517mod1 {2%2 == 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-mod-1 FAILED


==== 15.17-mod-2  % is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517mod2 {2L%2L == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-mod-2 FAILED


==== 15.17-mod-3  % is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517mod3 {2.0F % 2.0F == 0.0F}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-mod-3 FAILED


==== 15.17-mod-4  % is a multiplicative operator  FAILED
==== Contents of test case:

    constant_expression T1517mod4 {2.0D % 2.0D == 0.0D}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-mod-4 FAILED


==== 15.17-type-2  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type2 long {1 * 2L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-type-2 FAILED


==== 15.17-type-3  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type3 int {1 / 2L}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.17-type-3 FAILED


==== 15.17-type-4  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type4 long {1 / 2L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-type-4 FAILED


==== 15.17-type-6  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type6 long {1 % 2L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-type-6 FAILED


==== 15.17-type-8  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type8 double {1f * 2D}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-type-8 FAILED


==== 15.17-type-9  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type9 float {1f / 2D}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.17-type-9 FAILED


==== 15.17-type-12  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type12 double {1f % 2D}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-type-12 FAILED


==== 15.17-type-14  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type14 double {1 * 2D}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-type-14 FAILED


==== 15.17-type-16  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type16 double {1 / 2D}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-type-16 FAILED


==== 15.17-type-18  The type of a multiplicative
        expression is the promoted type of its operands.  FAILED
==== Contents of test case:

    is_assignable_to T1517type18 double {1 % 2D}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17-type-18 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/multiplicative-operators/division-operator

==== 15.17.2-assoc-1  division is left-associative  FAILED
==== Contents of test case:

    constant_expression T15172assoc1  {10 / 3 / 2 == 1} {10 / (3 / 2) == 10}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-assoc-1 FAILED


==== 15.17.2-assoc-2  division is left-associative  FAILED
==== Contents of test case:

    constant_expression T15172assoc2  {10.0 / 3.0 / 2.0 == 1.6666666666666667}  {10.0 / (3.0 / 2.0) == 6.666666666666667}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-assoc-2 FAILED


==== 15.17.2-float-1  NaN / NaN is NaN  FAILED
==== Contents of test case:

    constant_expression T15172f1  {Float.NaN / Float.NaN != Float.NaN / Float.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-1 FAILED


==== 15.17.2-float-2  NaN / anything is NaN  FAILED
==== Contents of test case:

    constant_expression T15172f2  {Float.NaN / 1f != Float.NaN / 1f}  {1f / Float.NaN != 1f / Float.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-2 FAILED


==== 15.17.2-float-3  the result is positive in floating-point
        division if both operands have the same sign  FAILED
==== Contents of test case:

    constant_expression T15172f3 {-1f / -2f > 0f} {1f / 2f > 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-3 FAILED


==== 15.17.2-float-4  the result is negative in floating-point
        division if the operands have opposite sign  FAILED
==== Contents of test case:

    constant_expression T15172f4 {-1f / 2f < 0f} {1f / -2f < 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-4 FAILED


==== 15.17.2-float-5  0 / 0 is NaN  FAILED
==== Contents of test case:

    constant_expression T15172f5  {0f / 0f != 0f / 0f}  {-0f / 0f != -0f / 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-5 FAILED


==== 15.17.2-float-6  Infinity / finite == Infinity of correct sign  FAILED
==== Contents of test case:

    constant_expression T15172f6  {Float.NEGATIVE_INFINITY / -1f == Float.POSITIVE_INFINITY}  {Float.POSITIVE_INFINITY / -1f == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-6 FAILED


==== 15.17.2-float-7  Infinity / Infinity is NaN  FAILED
==== Contents of test case:

    constant_expression T15172f7  {Float.NEGATIVE_INFINITY / Float.NEGATIVE_INFINITY !=
            Float.NEGATIVE_INFINITY / Float.NEGATIVE_INFINITY}  {Float.POSITIVE_INFINITY / Float.NEGATIVE_INFINITY !=
            Float.POSITIVE_INFINITY / Float.NEGATIVE_INFINITY}  {Float.NEGATIVE_INFINITY / Float.POSITIVE_INFINITY !=
            Float.NEGATIVE_INFINITY / Float.POSITIVE_INFINITY}  {Float.POSITIVE_INFINITY / Float.POSITIVE_INFINITY !=
            Float.POSITIVE_INFINITY / Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-7 FAILED


==== 15.17.2-float-8  Finite / Infinity == Signed zero
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15172f8  {1f / Float.NEGATIVE_INFINITY == 0}  {1/(1f / Float.NEGATIVE_INFINITY) == Float.NEGATIVE_INFINITY}  {1f / Float.POSITIVE_INFINITY == 0}  {1/(1f / Float.POSITIVE_INFINITY) == Float.POSITIVE_INFINITY}  {-1f / Float.NEGATIVE_INFINITY == 0}  {1/(-1f / Float.NEGATIVE_INFINITY) == Float.POSITIVE_INFINITY}  {-1f / Float.POSITIVE_INFINITY == 0}  {1/(-1f / Float.POSITIVE_INFINITY) == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-8 FAILED


==== 15.17.2-float-9  Finite / 0 == Signed infinity  FAILED
==== Contents of test case:

    constant_expression T15172f9  {1f / 0f == Float.POSITIVE_INFINITY}  {-1f / 0f == Float.NEGATIVE_INFINITY}  {1f / -0f == Float.NEGATIVE_INFINITY}  {-1f / -0f == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-9 FAILED


==== 15.17.2-float-10  0 / non-zero Finite == Signed zero
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15172f10  {0f / 1f == 0} {1/(0f / 1f) == Float.POSITIVE_INFINITY}  {-0f / 1f == 0} {1/(-0f / 1f) == Float.NEGATIVE_INFINITY}  {0f / -1f == 0} {1/(0f / -1f) == Float.NEGATIVE_INFINITY}  {-0f / -1f == 0} {1/(-0f / -1f) == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-10 FAILED


==== 15.17.2-float-11  Floating-point / produces Infinity for overflow  FAILED
==== Contents of test case:

    constant_expression T15172f11  {1.0e30f / 1.0e-30f == Float.POSITIVE_INFINITY}  {1.0e30f / -1.0e-30f == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-11 FAILED


==== 15.17.2-float-12  Floating-point / supports gradual underflow  FAILED
==== Contents of test case:

    constant_expression T15172f12  {1e-22f / 1e22f == 1e-44f}  {1e-22f / -1e22f == -1e-44f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-12 FAILED


==== 15.17.2-float-13  Floating-point / produces 0 for underflow 
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15172f13  {1e-30f / 1e30f == 0}  {1/(1e-30f / 1e30f) == Float.POSITIVE_INFINITY}  {1e-30f / -1e30f == 0}  {1/(1e-30f / -1e30f) == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-13 FAILED


==== 15.17.2-float-14  Floating-point / works even with denorms  FAILED
==== Contents of test case:

    constant_expression T15172f14  {1e-10f / 1e-40f == 1.0000054E30f}  {1e-10f / -1e-40f == -1.0000054E30f}  {1e-40f / -1e-10f == -9.999946E-31f}  {-1e-40f / -1e-10f == 9.999946E-31f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-14 FAILED


==== 15.17.2-float-15  Floating-point / follows round-to-nearest rules  FAILED
==== Contents of test case:

    constant_expression T15172f15  {0x1800004 / 3f == 0x800001}  {0x1800008 / 3f == 0x800003}  {7e-45f / 2f == 2.8e-45f}  {9.8e-45f / 2f == 5.6e-45f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-15 FAILED


==== 15.17.2-float-16  Floating-point constants must be evaluated
        in strictfp mode  FAILED
==== Contents of test case:

    constant_expression T15172f16 {4.294968e9f / 256 / 16777216 == 1.0000001f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-float-16 FAILED


==== 15.17.2-double-1  NaN / NaN is NaN  FAILED
==== Contents of test case:

    constant_expression T15172d1  {Double.NaN / Double.NaN != Double.NaN / Double.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-1 FAILED


==== 15.17.2-double-2  NaN / anything is NaN  FAILED
==== Contents of test case:

    constant_expression T15172d2  {Double.NaN / 1d != Double.NaN / 1d}  {1d / Double.NaN != 1d / Double.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-2 FAILED


==== 15.17.2-double-3  the result is positive in floating-point
        division if both operands have the same sign  FAILED
==== Contents of test case:

    constant_expression T15172d3 {-1d / -2d > 0d} {1d / 2d > 0d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-3 FAILED


==== 15.17.2-double-4  the result is negative in floating-point
        division if the operands have opposite sign  FAILED
==== Contents of test case:

    constant_expression T15172d4 {-1.0 / 2.0 < 0.0} {1.0 / -2.0 < 0.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-4 FAILED


==== 15.17.2-double-5  0 / 0 is NaN  FAILED
==== Contents of test case:

    constant_expression T15172d5  {0d / 0d != 0d / 0d}  {-0d / 0d != -0d / 0d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-5 FAILED


==== 15.17.2-double-6  Infinity / finite == Infinity of correct sign  FAILED
==== Contents of test case:

    constant_expression T15172d6  {Double.NEGATIVE_INFINITY / -1d == Double.POSITIVE_INFINITY}  {Double.POSITIVE_INFINITY / -1d == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-6 FAILED


==== 15.17.2-double-7  Infinity / Infinity is NaN  FAILED
==== Contents of test case:

    constant_expression T15172d7  {Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY !=
            Double.NEGATIVE_INFINITY / Double.NEGATIVE_INFINITY}  {Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY !=
            Double.POSITIVE_INFINITY / Double.NEGATIVE_INFINITY}  {Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY !=
            Double.NEGATIVE_INFINITY / Double.POSITIVE_INFINITY}  {Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY !=
            Double.POSITIVE_INFINITY / Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-7 FAILED


==== 15.17.2-double-8  Finite / Infinity == Signed zero
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15172d8  {1d / Double.NEGATIVE_INFINITY == 0}  {1/(1d / Double.NEGATIVE_INFINITY) == Double.NEGATIVE_INFINITY}  {1d / Double.POSITIVE_INFINITY == 0}  {1/(1d / Double.POSITIVE_INFINITY) == Double.POSITIVE_INFINITY}  {-1d / Double.NEGATIVE_INFINITY == 0}  {1/(-1d / Double.NEGATIVE_INFINITY) == Double.POSITIVE_INFINITY}  {-1d / Double.POSITIVE_INFINITY == 0}  {1/(-1d / Double.POSITIVE_INFINITY) == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-8 FAILED


==== 15.17.2-double-9  Finite / 0 == Signed infinity  FAILED
==== Contents of test case:

    constant_expression T15172d9  {1d / 0d == Double.POSITIVE_INFINITY}  {-1d / 0d == Double.NEGATIVE_INFINITY}  {1d / -0d == Double.NEGATIVE_INFINITY}  {-1d / -0d == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-9 FAILED


==== 15.17.2-double-10  0 / non-zero Finite == Signed zero
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15172d10  {0d / 1d == 0} {1/(0d / 1d) == Double.POSITIVE_INFINITY}  {-0d / 1d == 0} {1/(-0d / 1d) == Double.NEGATIVE_INFINITY}  {0d / -1d == 0} {1/(0d / -1d) == Double.NEGATIVE_INFINITY}  {-0d / -1d == 0} {1/(-0d / -1d) == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-10 FAILED


==== 15.17.2-double-11  Floating-point / produces Infinity for overflow  FAILED
==== Contents of test case:

    constant_expression T15172d11  {1.0e160 / 1.0e-160 == Double.POSITIVE_INFINITY}  {1.0e160 / -1.0e-160 == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-11 FAILED


==== 15.17.2-double-12  Floating-point / supports gradual underflow  FAILED
==== Contents of test case:

    constant_expression T15172d12  {1e-160 / 1e160 == 1e-320}  {1e-160 / -1e160 == -1e-320}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-12 FAILED


==== 15.17.2-double-13  Floating-point / produces 0 for underflow 
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15172d13  {1e-170 / 1e170 == 0}  {1/(1e-170 / 1e170) == Double.POSITIVE_INFINITY}  {1e-170 / -1e170 == 0}  {1/(1e-170 / -1e170) == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-13 FAILED


==== 15.17.2-double-14  Floating-point / works even with denorms  FAILED
==== Contents of test case:

    constant_expression T15172d14  {1e-20 / 1e-320 == 1.0000111329412579e300}  {1e-20 / -1e-320 == -1.0000111329412579e300}  {1e-320 / -1e-20 == -9.999888671826831E-301}  {-1e-320 / -1e-20 == 9.999888671826831E-301}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-14 FAILED


==== 15.17.2-double-15  Floating-point / follows round-to-nearest rules  FAILED
==== Contents of test case:

    constant_expression T15172d15  {0x30000000000004L / 3d == 0x10000000000001L}  {0x30000000000008L / 3d == 0x10000000000003L}  {2.5e-323 / 2d == 1e-323}  {3.5e-323 / 2d == 2e-323}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-double-15 FAILED


==== 15.17.2-int-1  integer division rounds to 0  FAILED
==== Contents of test case:

    constant_expression T15172i1  {5 / 3 == 1}  {5 / -3 == -1}  {-5 / 3 == -1}  {-5 / -3 == 1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-int-1 FAILED


==== 15.17.2-int-2  MIN_INT / -1 overflows  FAILED
==== Contents of test case:

    constant_expression T15172i2 {0x80000000 / -1 == 0x80000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-int-2 FAILED


==== 15.17.2-long-1  integer division rounds to 0  FAILED
==== Contents of test case:

    constant_expression T15172l1  {5L / 3L == 1L}  {5L / -3L == -1L}  {-5L / 3L == -1L}  {-5L / -3L == 1L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-long-1 FAILED


==== 15.17.2-long-2  MIN_LONG / -1 overflows  FAILED
==== Contents of test case:

    constant_expression T15172l2 {0x8000000000000000L / -1L == 0x8000000000000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.2-long-2 FAILED


==== 15.17.2-long-3  Not a compile-time error to divide by
        constant integer 0  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T15172l3 {long l = 1L / 0L;}]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.17.2-long-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/multiplicative-operators/multiplication-operator

==== 15.17.1-commute-1  side-effect-free multiplication is commutative  FAILED
==== Contents of test case:

    constant_expression T15171commute1 {1 * 2 == 2 * 1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-commute-1 FAILED


==== 15.17.1-commute-2  side-effect-free multiplication is commutative  FAILED
==== Contents of test case:

    constant_expression T15171commute2 {1L * 2L == 2L * 1L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-commute-2 FAILED


==== 15.17.1-commute-3  side-effect-free multiplication is commutative  FAILED
==== Contents of test case:

    constant_expression T15171commute3 {1f * 2f == 2f * 1f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-commute-3 FAILED


==== 15.17.1-commute-4  side-effect-free multiplication is commutative  FAILED
==== Contents of test case:

    constant_expression T15171commute4 {1d * 2d == 2d * 1d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-commute-4 FAILED


==== 15.17.1-assoc-1  integer multiplication is associative when
        all arguments are of the same type  FAILED
==== Contents of test case:

    constant_expression T15171assoc1 {(1 * 2) * 3 == 1 * (2 * 3)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-assoc-1 FAILED


==== 15.17.1-assoc-4  multiplication is left-associative  FAILED
==== Contents of test case:

    constant_expression T15171assoc4  {1e308 * 100.0 * .01 == (1e308 * 100.0) * .01}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-assoc-4 FAILED


==== 15.17.1-float-1  NaN * NaN is NaN  FAILED
==== Contents of test case:

    constant_expression T15171f1  {Float.NaN * Float.NaN != Float.NaN * Float.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-1 FAILED


==== 15.17.1-float-2  NaN * anything is NaN  FAILED
==== Contents of test case:

    constant_expression T15171f2 {Float.NaN * 1f != Float.NaN * 1f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-2 FAILED


==== 15.17.1-float-3  the result is positive in floating-point
        multiplication if both operands have the same sign  FAILED
==== Contents of test case:

    constant_expression T15171f3 {-1f * -2f > 0f} {1f * 2f > 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-3 FAILED


==== 15.17.1-float-4  the result is negative in floating-point
        multiplication if the operands have opposite sign  FAILED
==== Contents of test case:

    constant_expression T15171f4 {-1f * 2f < 0f} {1f * -2f < 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-4 FAILED


==== 15.17.1-float-5  Infinity * 0 is NaN  FAILED
==== Contents of test case:

    constant_expression T15171f5  {Float.POSITIVE_INFINITY * 0f != Float.POSITIVE_INFINITY * 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-5 FAILED


==== 15.17.1-float-6  Infinity * finite == Infinity of correct sign  FAILED
==== Contents of test case:

    constant_expression T15171f6  {Float.NEGATIVE_INFINITY * -1f == Float.POSITIVE_INFINITY}  {Float.POSITIVE_INFINITY * -1f == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-6 FAILED


==== 15.17.1-float-7  Infinity * Infinity == Infinity of correct sign
        (Specified in JVMS errata)  FAILED
==== Contents of test case:

    constant_expression T15171f7  {Float.NEGATIVE_INFINITY * Float.NEGATIVE_INFINITY == Float.POSITIVE_INFINITY}  {Float.POSITIVE_INFINITY * Float.POSITIVE_INFINITY == Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-7 FAILED


==== 15.17.1-float-8  Infinity * Infinity == Infinity of correct sign
        (Specified in JVMS errata)  FAILED
==== Contents of test case:

    constant_expression T15171f8  {Float.NEGATIVE_INFINITY * Float.POSITIVE_INFINITY == Float.NEGATIVE_INFINITY}  {Float.POSITIVE_INFINITY * Float.NEGATIVE_INFINITY == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-8 FAILED


==== 15.17.1-float-9  Floating-point * produces Infinity for overflow  FAILED
==== Contents of test case:

    constant_expression T15171f9  {1.0e30f * 1.0e30f == Float.POSITIVE_INFINITY}  {1.0e30f * -1.0e30f == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-9 FAILED


==== 15.17.1-float-10  Floating-point * supports gradual underflow  FAILED
==== Contents of test case:

    constant_expression T15171f10  {1e-22f * 1e-22f == 1e-44f}  {1e-22f * -1e-22f == -1e-44f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-10 FAILED


==== 15.17.1-float-11  Floating-point * produces 0 for underflow 
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15171f11  {1e-30f * 1e-30f == 0}  {1/(1e-30f * 1e-30f) == Float.POSITIVE_INFINITY}  {1e-30f * -1e-30f == 0}  {1/(1e-30f * -1e-30f) == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-11 FAILED


==== 15.17.1-float-12  Floating-point * works even with denorms  FAILED
==== Contents of test case:

    constant_expression T15171f12  {1e30f * 1e-40f == 9.999946e-11f}  {1e30f * -1e-40f == -9.999946e-11f}  {1e-40f * -1e30f == -9.999946e-11f}  {-1e-40f * -1e30f == 9.999946e-11f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-12 FAILED


==== 15.17.1-float-13  Floating-point * follows round-to-nearest rules  FAILED
==== Contents of test case:

    constant_expression T15171f13  {0x800001 * 3f == 0x1800004}  {0x800001 * 5f == 0x2800004}  {0x800003 * 5f == 0x2800010}  {0x800002 * 5f == 0x2800008}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-13 FAILED


==== 15.17.1-float-14  Floating-point * follows round-to-nearest,
        even with denorms  FAILED
==== Contents of test case:

    constant_expression T15171f14  {2.1302879E-19f * 5.4316195E-20f == 1.1570912E-38f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-float-14 FAILED


==== 15.17.1-double-1  NaN * NaN is NaN  FAILED
==== Contents of test case:

    constant_expression T15171d1  {Double.NaN * Double.NaN != Double.NaN * Double.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-1 FAILED


==== 15.17.1-double-2  NaN * anything is NaN  FAILED
==== Contents of test case:

    constant_expression T15171d2 {Double.NaN * 1d != Double.NaN * 1d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-2 FAILED


==== 15.17.1-double-3  the result is positive in floating-point
        multiplication if both operands have the same sign  FAILED
==== Contents of test case:

    constant_expression T15171d3 {-1d * -2d > 0d} {1d * 2d > 0d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-3 FAILED


==== 15.17.1-double-4  the result is negative in floating-point
        multiplication if the operands have opposite sign  FAILED
==== Contents of test case:

    constant_expression T15171d4 {-1.0 * 2.0 < 0.0} {1.0 * -2.0 < 0.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-4 FAILED


==== 15.17.1-double-5  Infinity * 0 is NaN  FAILED
==== Contents of test case:

    constant_expression T15171d5  {Double.POSITIVE_INFINITY * 0d != Double.POSITIVE_INFINITY * 0d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-5 FAILED


==== 15.17.1-double-6  Infinity * finite == Infinity of correct sign  FAILED
==== Contents of test case:

    constant_expression T15171d6  {Double.NEGATIVE_INFINITY * -1d == Double.POSITIVE_INFINITY}  {Double.POSITIVE_INFINITY * -1d == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-6 FAILED


==== 15.17.1-double-7  Infinity * Infinity == Infinity of correct sign
        (Specified in JVMS errata)  FAILED
==== Contents of test case:

    constant_expression T15171d7  {Double.NEGATIVE_INFINITY * Double.NEGATIVE_INFINITY == Double.POSITIVE_INFINITY}  {Double.POSITIVE_INFINITY * Double.POSITIVE_INFINITY == Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-7 FAILED


==== 15.17.1-double-8  Infinity * Infinity == Infinity of correct sign
        (Specified in JVMS errata)  FAILED
==== Contents of test case:

    constant_expression T15171d8  {Double.NEGATIVE_INFINITY * Double.POSITIVE_INFINITY == Double.NEGATIVE_INFINITY}  {Double.POSITIVE_INFINITY * Double.NEGATIVE_INFINITY == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-8 FAILED


==== 15.17.1-double-9  Floating-point * produces Infinity for overflow  FAILED
==== Contents of test case:

    constant_expression T15171d9  {1.0e160 * 1.0e160 == Double.POSITIVE_INFINITY}  {1.0e160 * -1.0e160 == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-9 FAILED


==== 15.17.1-double-10  Floating-point * supports gradual underflow  FAILED
==== Contents of test case:

    constant_expression T15171d10  {1e-160 * 1e-160 == 1e-320}  {1e-160 * -1e-160 == -1e-320}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-10 FAILED


==== 15.17.1-double-11  Floating-point * produces 0 for underflow 
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15171d11  {1e-170 * 1e-170 == 0}  {1/(1e-170 * 1e-170) == Double.POSITIVE_INFINITY}  {1e-170 * -1e-170 == 0}  {1/(1e-170 * -1e-170) == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-11 FAILED


==== 15.17.1-double-12  Floating-point * works even with denorms  FAILED
==== Contents of test case:

    constant_expression T15171d12  {1e300 * 1e-320 == 9.99988867182683E-21}  {1e300 * -1e-320 == -9.99988867182683E-21}  {1e-320 * -1e300 == -9.99988867182683E-21}  {-1e-320 * -1e300 == 9.99988867182683E-21}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-12 FAILED


==== 15.17.1-double-13  Floating-point * follows round-to-nearest rules  FAILED
==== Contents of test case:

    constant_expression T15171d13  {0x10000000000001L * 3d == 0x30000000000004L}  {0x10000000000001L * 5d == 0x50000000000004L}  {0x10000000000003L * 5d == 0x50000000000010L}  {0x10000000000002L * 5d == 0x50000000000008L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-13 FAILED


==== 15.17.1-double-14  Floating-point * follows round-to-nearest,
        even with denorms, known bug in Sun's javac  FAILED
==== Contents of test case:

    constant_expression T15171d14  {8.578459548793971E-162 * 2.512418001798401E-147
            == 2.155267619808936E-308}  {6.946121092140867E-162 * 2.669444126910801E-147
            == 1.8542282154226677E-308}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-double-14 FAILED


==== 15.17.1-int-1  overflow in integer multiplication, simply 
        selects low-order bits, possibly changing sign  FAILED
==== Contents of test case:

    constant_expression T15171i1 {1234567890 * 10 == -539222988}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-int-1 FAILED


==== 15.17.1-int-2  constant expression with int multiplication  FAILED
==== Contents of test case:

    constant_expression T15171i2  {-12300000 == 100000 * -123}  {-50000000 == 500 * -100000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-int-2 FAILED


==== 15.17.1-long-1  constant expression with long multiplication  FAILED
==== Contents of test case:

    constant_expression T15171l1  {-12192592592745L == 987654321L * -12345}  {-12192592592745L == 12345 * -987654321L}  {12192592592745L == 987654321L * 12345}  {12192592592745L == -987654321L * -12345}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-long-1 FAILED


==== 15.17.1-long-2  constant expression with long multiplication  FAILED
==== Contents of test case:

    constant_expression T15171l2 {-2L*(1L<<28) == 0xffffffffe0000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.1-long-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/multiplicative-operators/remainder-operator

==== 15.17.3-assoc-1  remainder is left-associative  FAILED
==== Contents of test case:

    constant_expression T15173assoc1  {10 % 4 % 3 == 2} {10 % (4 % 3) == 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-assoc-1 FAILED


==== 15.17.3-assoc-2  remainder is left-associative  FAILED
==== Contents of test case:

    constant_expression T15173assoc2  {10.0 % 4.0 % 3.0 == 2.0}  {10.0 % (4.0 % 3.0) == 0.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-assoc-2 FAILED


==== 15.17.3-float-1  NaN % NaN is NaN  FAILED
==== Contents of test case:

    constant_expression T15173f1  {Float.NaN % Float.NaN != Float.NaN % Float.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-1 FAILED


==== 15.17.3-float-2  NaN % anything is NaN  FAILED
==== Contents of test case:

    constant_expression T15173f2  {Float.NaN % 1f != Float.NaN % 1f}  {1f % Float.NaN != 1f % Float.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-2 FAILED


==== 15.17.3-float-3  the result is positive in floating-point
        remainder if the dividend is positive  FAILED
==== Contents of test case:

    constant_expression T15173f3 {3f % -2f > 0f} {3f % 2f > 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-3 FAILED


==== 15.17.3-float-4  the result is negative in floating-point
        remainder if the dividend is negative  FAILED
==== Contents of test case:

    constant_expression T15173f4 {-3f % 2f < 0f} {-3f % -2f < 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-4 FAILED


==== 15.17.3-float-5  0 % 0 is NaN  FAILED
==== Contents of test case:

    constant_expression T15173f5  {0f % 0f != 0f % 0f}  {-0f % 0f != -0f % 0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-5 FAILED


==== 15.17.3-float-6  Infinity % finite is NaN  FAILED
==== Contents of test case:

    constant_expression T15173f6  {Float.NEGATIVE_INFINITY % -1f != Float.NEGATIVE_INFINITY % -1f}  {Float.POSITIVE_INFINITY % -1f != Float.POSITIVE_INFINITY % -1f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-6 FAILED


==== 15.17.3-float-7  Infinity % Infinity is NaN  FAILED
==== Contents of test case:

    constant_expression T15173f7  {Float.NEGATIVE_INFINITY % Float.NEGATIVE_INFINITY !=
            Float.NEGATIVE_INFINITY % Float.NEGATIVE_INFINITY}  {Float.POSITIVE_INFINITY % Float.NEGATIVE_INFINITY !=
            Float.POSITIVE_INFINITY % Float.NEGATIVE_INFINITY}  {Float.NEGATIVE_INFINITY % Float.POSITIVE_INFINITY !=
            Float.NEGATIVE_INFINITY % Float.POSITIVE_INFINITY}  {Float.POSITIVE_INFINITY % Float.POSITIVE_INFINITY !=
            Float.POSITIVE_INFINITY % Float.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-7 FAILED


==== 15.17.3-float-8  Finite % Infinity == dividend  FAILED
==== Contents of test case:

    constant_expression T15173f8  {1f % Float.NEGATIVE_INFINITY == 1f}  {1f % Float.POSITIVE_INFINITY == 1f}  {-1f % Float.NEGATIVE_INFINITY == -1f}  {-1f % Float.POSITIVE_INFINITY == -1f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-8 FAILED


==== 15.17.3-float-9  Finite % 0 is NaN  FAILED
==== Contents of test case:

    constant_expression T15173f9  {1f % 0f != 1f % 0f}  {-1f % 0f != -1f % 0f}  {1f % -0f != 1f % -0f}  {-1f % -0f != -1f % -0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-9 FAILED


==== 15.17.3-float-10  0 % non-zero Finite == Dividend
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15173f10  {0f % 1f == 0} {1/(0f % 1f) == Float.POSITIVE_INFINITY}  {-0f % 1f == 0} {1/(-0f % 1f) == Float.NEGATIVE_INFINITY}  {0f % -1f == 0} {1/(0f % -1f) == Float.POSITIVE_INFINITY}  {-0f % -1f == 0} {1/(-0f % -1f) == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-10 FAILED


==== 15.17.3-float-11  0 % Infinity == Dividend
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15173f11  {0f % Float.POSITIVE_INFINITY == 0}  {1/(0f % Float.POSITIVE_INFINITY) == Float.POSITIVE_INFINITY}  {-0f % Float.POSITIVE_INFINITY == 0}  {1/(-0f % Float.POSITIVE_INFINITY) == Float.NEGATIVE_INFINITY}  {0f % Float.NEGATIVE_INFINITY == 0}  {1/(0f % Float.NEGATIVE_INFINITY) == Float.POSITIVE_INFINITY}  {-0f % Float.NEGATIVE_INFINITY == 0}  {1/(-0f % Float.NEGATIVE_INFINITY) == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-11 FAILED


==== 15.17.3-float-12  Floating-point % cannot overflow  FAILED
==== Contents of test case:

    constant_expression T15173f12  {1e30f % 1e-30f == 8.166816e-31f}  {-1e30f % -1e-30f == -8.166816e-31f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-12 FAILED


==== 15.17.3-float-13  Floating-point % works even with denorms  FAILED
==== Contents of test case:

    constant_expression T15173f13  {1e30f % 1e-40f == 7.121e-42f}  {1e30f % -1e-40f == 7.121e-42f}  {-1e-40f % 1e30f == -1e-40f}  {-1e-40f % -1e30f == -1e-40f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-13 FAILED


==== 15.17.3-float-14  Example cases  FAILED
==== Contents of test case:

    constant_expression T15173f14  {5.0f % 3.0f == 2.0f}  {5.0f % -3.0f == 2.0f}  {-5.0f % 3.0f == -2.0f}  {-5.0f % -3.0f == -2.0f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-float-14 FAILED


==== 15.17.3-double-1  NaN % NaN is NaN  FAILED
==== Contents of test case:

    constant_expression T15173d1  {Double.NaN % Double.NaN != Double.NaN % Double.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-1 FAILED


==== 15.17.3-double-2  NaN % anything is NaN  FAILED
==== Contents of test case:

    constant_expression T15173d2  {Double.NaN % 1d != Double.NaN % 1d}  {1d % Double.NaN != 1d % Double.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-2 FAILED


==== 15.17.3-double-3  the result is positive in floating-point
        remainder if the dividend is positive  FAILED
==== Contents of test case:

    constant_expression T15173d3 {3d % -2d > 0d} {3d % 2d > 0d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-3 FAILED


==== 15.17.3-double-4  the result is negative in floating-point
        remainder if the dividend is negative  FAILED
==== Contents of test case:

    constant_expression T15173d4 {-3d % 2d < 0d} {-3d % -2d < 0d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-4 FAILED


==== 15.17.3-double-5  0 % 0 is NaN  FAILED
==== Contents of test case:

    constant_expression T15173d5  {0d % 0d != 0d % 0d}  {-0d % 0d != -0d % 0d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-5 FAILED


==== 15.17.3-double-6  Infinity % finite is NaN  FAILED
==== Contents of test case:

    constant_expression T15173d6  {Double.NEGATIVE_INFINITY % -1d != Double.NEGATIVE_INFINITY % -1d}  {Double.POSITIVE_INFINITY % -1d != Double.POSITIVE_INFINITY % -1d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-6 FAILED


==== 15.17.3-double-7  Infinity % Infinity is NaN  FAILED
==== Contents of test case:

    constant_expression T15173d7  {Double.NEGATIVE_INFINITY % Double.NEGATIVE_INFINITY !=
            Double.NEGATIVE_INFINITY % Double.NEGATIVE_INFINITY}  {Double.POSITIVE_INFINITY % Double.NEGATIVE_INFINITY !=
            Double.POSITIVE_INFINITY % Double.NEGATIVE_INFINITY}  {Double.NEGATIVE_INFINITY % Double.POSITIVE_INFINITY !=
            Double.NEGATIVE_INFINITY % Double.POSITIVE_INFINITY}  {Double.POSITIVE_INFINITY % Double.POSITIVE_INFINITY !=
            Double.POSITIVE_INFINITY % Double.POSITIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-7 FAILED


==== 15.17.3-double-8  Finite % Infinity == dividend  FAILED
==== Contents of test case:

    constant_expression T15173d8  {1d % Double.NEGATIVE_INFINITY == 1d}  {1d % Double.POSITIVE_INFINITY == 1d}  {-1d % Double.NEGATIVE_INFINITY == -1d}  {-1d % Double.POSITIVE_INFINITY == -1d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-8 FAILED


==== 15.17.3-double-9  Finite % 0 is NaN  FAILED
==== Contents of test case:

    constant_expression T15173d9  {1d % 0d != 1d % 0d}  {-1d % 0d != -1d % 0d}  {1d % -0d != 1d % -0d}  {-1d % -0d != -1d % -0d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-9 FAILED


==== 15.17.3-double-10  0 % non-zero Finite == Dividend
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15173d10  {0d % 1d == 0} {1/(0d % 1d) == Double.POSITIVE_INFINITY}  {-0d % 1d == 0} {1/(-0d % 1d) == Double.NEGATIVE_INFINITY}  {0d % -1d == 0} {1/(0d % -1d) == Double.POSITIVE_INFINITY}  {-0d % -1d == 0} {1/(-0d % -1d) == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-10 FAILED


==== 15.17.3-double-11  0 % Infinity == Dividend
        (check 1/0 to determine sign)  FAILED
==== Contents of test case:

    constant_expression T15173d11  {0d % Double.POSITIVE_INFINITY == 0}  {1/(0d % Double.POSITIVE_INFINITY) == Double.POSITIVE_INFINITY}  {-0d % Double.POSITIVE_INFINITY == 0}  {1/(-0d % Double.POSITIVE_INFINITY) == Double.NEGATIVE_INFINITY}  {0d % Double.NEGATIVE_INFINITY == 0}  {1/(0d % Double.NEGATIVE_INFINITY) == Double.POSITIVE_INFINITY}  {-0d % Double.NEGATIVE_INFINITY == 0}  {1/(-0d % Double.NEGATIVE_INFINITY) == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-11 FAILED


==== 15.17.3-double-12  Floating-point % cannot overflow  FAILED
==== Contents of test case:

    constant_expression T15173d12  {1e300 % 1e-300 == 4.891554850853602e-301}  {-1e300 % -1e-300 == -4.891554850853602e-301}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-12 FAILED


==== 15.17.3-double-13  Floating-point % works even with denorms  FAILED
==== Contents of test case:

    constant_expression T15173d13  {1e300 % 1e-320 == 3.16e-321}  {1e300 % -1e-320 == 3.16e-321}  {-1e-320 % 1e300 == -1e-320}  {-1e-320 % -1e300 == -1e-320}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-13 FAILED


==== 15.17.3-double-14  Example cases  FAILED
==== Contents of test case:

    constant_expression T15173d14  {5.0 % 3.0 == 2.0}  {5.0 % -3.0 == 2.0}  {-5.0 % 3.0 == -2.0}  {-5.0 % -3.0 == -2.0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-double-14 FAILED


==== 15.17.3-int-1  Example cases  FAILED
==== Contents of test case:

    constant_expression T15173i1  {5 % 3 == 2}  {5 % -3 == 2}  {-5 % 3 == -2}  {-5 % -3 == -2}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-int-1 FAILED


==== 15.17.3-int-2  (a/b)*b+(a%b) == a  FAILED
==== Contents of test case:

    constant_expression T15173i2  {(0x80000000 / -1) * -1 + (0x80000000 % -1) == 0x80000000}  {(5 / 3) * 3 + (5 % 3) == 5}  {(5 / -3) * -3 + (5 % -3) == 5}  {(-5 / 3) * 3 + (-5 % 3) == -5}  {(-5 / -3) * -3 + (-5 % -3) == -5}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-int-2 FAILED


==== 15.17.3-int-4  MIN_INT % -1 == 0  FAILED
==== Contents of test case:

    constant_expression T15173i4 {0x80000000 % -1 == 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-int-4 FAILED


==== 15.17.3-long-1  Example cases  FAILED
==== Contents of test case:

    constant_expression T15173l1  {5L % 3L == 2L}  {5L % -3L == 2L}  {-5L % 3L == -2L}  {-5L % -3L == -2L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-long-1 FAILED


==== 15.17.3-long-2  (a/b)*b+(a%b) == a  FAILED
==== Contents of test case:

    constant_expression T15173l2  {(0x8000000000000000L / -1L) * -1L + (0x8000000000000000L % -1L)
            == 0x8000000000000000L}  {(5L / 3L) * 3L + (5L % 3L) == 5L}  {(5L / -3L) * -3L + (5L % -3L) == 5L}  {(-5L / 3L) * 3L + (-5L % 3L) == -5L}  {(-5L / -3L) * -3L + (-5L % -3L) == -5L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-long-2 FAILED


==== 15.17.3-long-3  Not a compile-time error to divide by
        constant integer 0  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T15173l3 {long l = 1L % 0L;}]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.17.3-long-3 FAILED


==== 15.17.3-long-4  MIN_LONG % -1 == 0  FAILED
==== Contents of test case:

    constant_expression T15173l4 {0x8000000000000000L % -1L == 0L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.17.3-long-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/postfix-expressions/postfix-decrement-operator

==== 15.14.2-argument-10  Postfix-- must operate on a numeric
        variable, parenthesis may now surround variables  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T15142a10 {int i = 1, j = (i)--;}]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.14.2-argument-10 FAILED


==== 15.14.2-type-1  Postfix-- operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15142t1 {byte b = 1, b2 = b--;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.2-type-1 FAILED


==== 15.14.2-type-2  Postfix-- operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15142t2 {short s = 1, s2 = s--;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.2-type-2 FAILED


==== 15.14.2-type-3  Postfix-- operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15142t3 {char c = 1, c2 = c--;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.2-type-3 FAILED


==== 15.14.2-type-4  Postfix-- operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15142t4 {int i = 1, i2 = i--;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.2-type-4 FAILED


==== 15.14.2-type-5  Postfix-- operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15142t5 {long l = 1, l2 = l--;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.2-type-5 FAILED


==== 15.14.2-type-6  Postfix-- operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15142t6 {float f = 1, f2 = f--;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.2-type-6 FAILED


==== 15.14.2-type-7  Postfix-- operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15142t7 {double d = 1, d2 = d--;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.2-type-7 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/postfix-expressions/postfix-increment-operator

==== 15.14.1-argument-9  Postfix++ cannot operate on final variable  FAILED
==== Contents of test case:

    empty_class T15141a9 {final int i = 1, j = i++;}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.14.1-argument-9 FAILED


==== 15.14.1-type-5  Postfix++ operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15141t5 {long l = 1, l2 = l++;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.1-type-5 FAILED


==== 15.14.1-type-6  Postfix++ operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15141t6 {float f = 1, f2 = f++;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.1-type-6 FAILED


==== 15.14.1-type-7  Postfix++ operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15141t7 {double d = 1, d2 = d++;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.14.1-type-7 FAILED


==== 15.14.1-final-1  Postfix++ cannot be applied to a final  FAILED
==== Contents of test case:

    empty_class T15141f1 {
	final int i;
	int j = i++;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.14.1-final-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/primary-expressions/class-literals

==== 15.8.2-type-1  The class literal may be for any type  FAILED
==== Contents of test case:

    empty_main T1582t1 {
        Class c = Object.class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-1 FAILED


==== 15.8.2-type-2  The class literal may be for any type  FAILED
==== Contents of test case:

    empty_main T1582t2 {
        Class c = T1582t2.class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-2 FAILED


==== 15.8.2-type-3  The class literal may be for any type  FAILED
==== Contents of test case:

    empty_main T1582t3 {
        Class c = Runnable.class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-3 FAILED


==== 15.8.2-type-4  The class literal may be for any type  FAILED
==== Contents of test case:

    empty_main T1582t4 {
        Class c = void.class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-4 FAILED


==== 15.8.2-type-5  The class literal may be for any type  FAILED
==== Contents of test case:

    empty_main T1582t5 {
        Class c = int.class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-5 FAILED


==== 15.8.2-type-6  The class literal may be for any type  FAILED
==== Contents of test case:

    empty_main T1582t6 {
        Class c = int[].class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-6 FAILED


==== 15.8.2-type-7  The class literal may be for any type  FAILED
==== Contents of test case:

    empty_main T1582t7 {
        Class c = Object[].class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-7 FAILED


==== 15.8.2-type-8  The class literal may be for any type  FAILED
==== Contents of test case:

    empty_main T1582t8 {
        Class c = Runnable[][][][][][].class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-8 FAILED


==== 15.8.2-type-15  Jikes had problems with primitive base types
        when referenced inside a package  FAILED
==== Contents of test case:

    compile [saveas p1/T1582t15.java {
package p1;
class T1582t15 {
    Class c = int.class;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-15 FAILED


==== 15.8.2-type-16  Jikes had problems with primitive base types
        when referenced inside a package  FAILED
==== Contents of test case:

    compile [saveas p1/T1582t16.java {
package p1;
class T1582t16 {
    Class c = int[].class;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-type-16 FAILED


==== 15.8.2-primary-1  The class literal serves as a primary  FAILED
==== Contents of test case:

    empty_main T1582p1 {
        Object.class.getName();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-primary-1 FAILED


==== 15.8.2-primary-2  The class literal serves as a primary  FAILED
==== Contents of test case:

    empty_main T1582p2 {
	try {
	    Object.class.forName("java.lang.Object");
	} catch (Exception e) {
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-primary-2 FAILED


==== 15.8.2-syntax-7  The type in the class literal is not
        obscured  FAILED
==== Contents of test case:

    empty_class T1582s7 {
        int T1582s7; // obscure the class name from normal expressions
        Class c = T1582s7.class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-syntax-7 FAILED


==== 15.8.2-synthetic-1  Since the compiler must generate code to
        compile the class literal, this tests that the synthetic class$() method
        does not cause problems - jikes bug 2924  FAILED
==== Contents of test case:

    empty_class T1582synth1b {
	static final Object B_CONST = T1582synth1b.class;
    }
    compile [saveas T1582synth1c.java {
class T1582synth1c extends T1582synth1b {
    static final Object C_CONST = T1582synth1c.class;
}
    }]
    empty_class T1582synth1a {
	Object one = T1582synth1b.B_CONST;
	Object two = T1582synth1c.C_CONST;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-synthetic-1 FAILED


==== 15.8.2-synthetic-2  The compiler should synthesize byte.class
        and friends as Byte.TYPE and friends, rather than using Class.forName
        in the class$() method - jikes bug 3053  FAILED
==== Contents of test case:

    compile [saveas T1582synth2.java {
class T1582synth2 {
    Class c = byte.class;
}
    }] [saveas java/lang/Byte.java {
package java.lang;
public final class Byte extends Number implements Comparable
{
    public static final byte MIN_VALUE = -128;
    public static final byte MAX_VALUE = 127;
    // This may be recursive, but it works for the purpose of the test
    public static final Class TYPE = byte.class;
    public Byte(byte value) {}
    public Byte(String s) {}
    public static native String toString(byte b);
    public static native byte parseByte(String s);
    public static native byte parseByte(String s, int radix);
    public static native Byte valueOf(String s, int radix);
    public static native Byte valueOf(String s);
    public static native Byte decode(String s);
    public native byte byteValue();
    public native short shortValue();
    public native int intValue();
    public native long longValue();
    public native float floatValue();
    public native double doubleValue();
    public native String toString();
    public native int hashCode();
    public native boolean equals(Object obj);
    public native int compareTo(Byte b);
    public native int compareTo(Object o);
}
    }] [saveas java/dummy.java "package java; class dummy{}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-synthetic-2 FAILED


==== 15.8.2-synthetic-3  Test synthesis of class literal variables
        across inner classes without enclosing instance  FAILED
==== Contents of test case:

    empty_main T1582s3 {
        class Local {
            Local(Object o) {}
            void m() {
                Class c = Boolean.class;
            }
        }
        new Local(new Object() {
            Class c = Byte.class;
        });
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-synthetic-3 FAILED


==== 15.8.2-synthetic-4  Test synthesis of class literal variables
        in an interface field  FAILED
==== Contents of test case:

    compile [saveas T1582s4a.java {
class T1582s4a {
    Class c = T1582s4b.BUG;
}
    }] [saveas T1582s4b.java {
interface T1582s4b {
    Class BUG = Inner.class;
    class Inner {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.2-synthetic-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/primary-expressions/parenthesized-expressions

==== 15.8.5-statement-6  Parenthesized expression is not a statement  FAILED
==== Contents of test case:

    empty_class T1585s6 {
        void foo() {}
        void bar() {
            (foo());
        }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.8.5-statement-6 FAILED


==== 15.8.5-statement-7  Parenthesized expression is not a statement  FAILED
==== Contents of test case:

    empty_main T1585s7 {
        int i;
        (i = 1);
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.8.5-statement-7 FAILED


==== 15.8.5-primary-expression-2  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_main T1585p32 {
        Class c1 = (int.class),
              c2 = (int[].class),
              c3 = (Object.class),
              c4 = (Object[].class);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-primary-expression-2 FAILED


==== 15.8.5-primary-expression-3  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_main T1585p33 {
        Class c = (void.class);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-primary-expression-3 FAILED


==== 15.8.5-this-expression-1  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_class T1585te1 {
        int i;
        void foo() {
            (this).i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-this-expression-1 FAILED


==== 15.8.5-this-expression-2  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_class T1585te2 {
        int i;
        class Inner {
            Inner() {
                (T1585te2.this).i = 1;
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-this-expression-2 FAILED


==== 15.8.5-creation-expression-1  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_class T1585ce1 {
        int i;
        void foo() {
            (new T1585ce1()).i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-creation-expression-1 FAILED


==== 15.8.5-creation-expression-2  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_class T1585ce2 {
        void foo() {
            (new T1585ce2() {
                int i;
            }).i = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-creation-expression-2 FAILED


==== 15.8.5-creation-expression-4  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_main T1585ce4 {
        int[] i = (new int[] {1});
        Object[] o = (new Object[] {new Object()});
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-creation-expression-4 FAILED


==== 15.8.5-field-expression-1  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_class T1585fe1 {
        int i;
        T1585fe1 t;
        void foo() {
            int j = (t.i);
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-field-expression-1 FAILED


==== 15.8.5-field-expression-3  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    compile [saveas T1585fe3.java {
class T1585fe3 {
    int i;
    T1585fe3 t;
}
class Sub extends T1585fe3 {
    void foo() {
        (super.t).i = 1;
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-field-expression-3 FAILED


==== 15.8.5-field-expression-6  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    compile [saveas T1585fe6.java {
class T1585fe6 {
    int i;
    T1585fe6 t;
}
class Sub extends T1585fe6 {
    class Inner {
        void foo() {
            (Sub.super.t).i = 1;
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-field-expression-6 FAILED


==== 15.8.5-method-expression-1  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_class T1585me1 {
        int bar() { return 1; }
        int i = (bar());
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-method-expression-1 FAILED


==== 15.8.5-method-expression-3  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_class T1585me3 {
        int bar() { return 1; }
        T1585me3 t;
        int i = (t.bar());
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-method-expression-3 FAILED


==== 15.8.5-method-expression-5  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    compile [saveas T1585me5.java {
class T1585me5 {
    int bar() { return 1; }
}
class Sub extends T1585me5 {
    int i = (super.bar());
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-method-expression-5 FAILED


==== 15.8.5-method-expression-8  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    compile [saveas T1585me8.java {
class T1585me8 {
    int bar() { return 1; }
}
class Sub extends T1585me8 {
    class Inner {
        Inner() {
            int i = (Sub.super.bar());
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-method-expression-8 FAILED


==== 15.8.5-array-expression-1  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_main T1585ae1 {
        int[] ia = {1};
        int i = (ia[0]);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-array-expression-1 FAILED


==== 15.8.5-array-expression-2  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_main T1585ae2 {
        int[] ia = {1};
        int i = (ia)[0];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-array-expression-2 FAILED


==== 15.8.5-array-expression-3  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_main T1585ae3 {
        int[] ia = {1};
        int i = ((ia)[0]);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-array-expression-3 FAILED


==== 15.8.5-variable-1  Parenthesized expression may now
        represent a variable  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T1585v1 {
        static int i1 = 1, j1 = (i1)++;
        int i2 = 1, j2 = (i2)++;
        private static int i3 = 1;
        private int i4 = 1;
        class Inner {
            Inner() {
                int j3 = (i3)++;
                int j4 = (i4)++;
            }
        }
        void foo() {
            int i5 = 1, j5 = (i5)++;
            int[] i6 = {1};
            int j6 = (i6[0])++;
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.8.5-variable-1 FAILED


==== 15.8.5-variable-2  Parenthesized expression may now
        represent a variable  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T1585v2 {
        static int i1 = 1, j1 = (i1)--;
        int i2 = 1, j2 = (i2)--;
        private static int i3 = 1;
        private int i4 = 1;
        class Inner {
            Inner() {
                int j3 = (i3)--;
                int j4 = (i4)--;
            }
        }
        void foo() {
            int i5 = 1, j5 = (i5)--;
            int[] i6 = {1};
            int j6 = (i6[0])--;
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.8.5-variable-2 FAILED


==== 15.8.5-variable-3  Parenthesized expression may now
        represent a variable  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T1585v3 {
        static int i1 = 1, j1 = ++(i1);
        int i2 = 1, j2 = ++(i2);
        private static int i3 = 1;
        private int i4 = 1;
        class Inner {
            Inner() {
                int j3 = ++(i3);
                int j4 = ++(i4);
            }
        }
        void foo() {
            int i5 = 1, j5 = ++(i5);
            int[] i6 = {1};
            int j6 = ++(i6[0]);
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.8.5-variable-3 FAILED


==== 15.8.5-variable-4  Parenthesized expression may now
        represent a variable  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T1585v4 {
        static int i1 = 1, j1 = --(i1);
        int i2 = 1, j2 = --(i2);
        private static int i3 = 1;
        private int i4 = 1;
        class Inner {
            Inner() {
                int j3 = --(i3);
                int j4 = --(i4);
            }
        }
        void foo() {
            int i5 = 1, j5 = --(i5);
            int[] i6 = {1};
            int j6 = --(i6[0]);
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.8.5-variable-4 FAILED


==== 15.8.5-variable-6  Parenthesized expression may now represent
        variable in assignment  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_main T1585v6 {
        int[] i = {0};
        (i[0]) = 1;
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.8.5-variable-6 FAILED


==== 15.8.5-variable-8  Parenthesized expression may now represent
        variable in assignment  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_main T1585v8 {
        int[] i = {0};
        (i[0]) += 1;
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.8.5-variable-8 FAILED


==== 15.8.5-instanceof-1  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_main T1585i1 {
        boolean b = (new T1585i1() instanceof Object);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-instanceof-1 FAILED


==== 15.8.5-instanceof-2  Parenthesized expression must
        contain expression  FAILED
==== Contents of test case:

    empty_main T1585i2 {
        boolean b = (new T1585i2()) instanceof Object;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-instanceof-2 FAILED


==== 15.8.5-precedence-1  Parenthesized expression has highest precedence  FAILED
==== Contents of test case:

    constant_expression T1585p1 {1+2*3 == 7} {(1+2)*3 == 9} {1+(2*3) == 7}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.5-precedence-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/primary-expressions/qualified-this

==== 15.8.4-name-2  Qualified this must name an enclosing class, or
        the class itself  FAILED
==== Contents of test case:

    empty_class T1584n2 {
        int i;
        class Sub {
            int j = T1584n2.this.i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.4-name-2 FAILED


==== 15.8.4-name-3  Qualified this must name an enclosing class, or
        the class itself  FAILED
==== Contents of test case:

    empty_class T1584n3 {
        int i;
        int j = T1584n3.this.i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.4-name-3 FAILED


==== 15.8.4-syntax-1  The type in the qualified this is not
        obscured  FAILED
==== Contents of test case:

    empty_class T1584syn1 {
        int T1584syn1; // obscure the class name from normal expressions
        String s = T1584syn1.this.toString();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.8.4-syntax-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/relational-operators/type-comparison-operator-instanceof

==== 15.20.2-type-1  The left side may be null  FAILED
==== Contents of test case:

    empty_main T15202t1 {
	boolean b = null instanceof Object; // always false, but valid
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20.2-type-1 FAILED


==== 15.20.2-type-2  The left side may be null  FAILED
==== Contents of test case:

    empty_main T15202t2 {
	boolean b = null instanceof Runnable;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20.2-type-2 FAILED


==== 15.20.2-type-14  The left side may be a class literal  FAILED
==== Contents of test case:

    empty_main T15202t14 {
	boolean b = Object.class instanceof Class;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20.2-type-14 FAILED


==== 15.20.2-type-15  The left side may be a string literal  FAILED
==== Contents of test case:

    empty_main T15202t15 {
	boolean b = "" instanceof String;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20.2-type-15 FAILED


==== 15.20-2-always-1  Always true (but expression is still
        evaluated)  FAILED
==== Contents of test case:

    empty_main T15202a1 {
	// identity conversion of non-null
	boolean b = new Object() instanceof Object;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-always-1 FAILED


==== 15.20-2-always-2  Always true (but expression is still
        evaluated)  FAILED
==== Contents of test case:

    empty_main T15202a2 {
	// non-null subclass to superclass
	boolean b = new String() instanceof Object;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-always-2 FAILED


==== 15.20-2-always-3  Always true (but expression is still
        evaluated)  FAILED
==== Contents of test case:

    empty_main T15202a3 {
	// non-null array to Object
	boolean b = new int[1] instanceof Object;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-always-3 FAILED


==== 15.20-2-always-4  Always true (but expression is still
        evaluated)  FAILED
==== Contents of test case:

    empty_main T15202a4 {
	// non-null array to compatible array
	boolean b = new String[] {} instanceof String[];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-always-4 FAILED


==== 15.20-2-always-5  Always true (but expression is still
        evaluated)  FAILED
==== Contents of test case:

    empty_main T15202a5 {
	// non-null array to compatible array
	boolean b = new Integer[] {} instanceof Comparable[];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-always-5 FAILED


==== 15.20-2-always-6  Always true (but expression is still
        evaluated)  FAILED
==== Contents of test case:

    empty_main T15202a6 {
	// non-null array to Cloneable
	boolean b = new int[1] instanceof Cloneable;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-always-6 FAILED


==== 15.20-2-always-7  Always true (but expression is still
        evaluated)  FAILED
==== Contents of test case:

    empty_main T15202a7 {
	// non-null array to Serializable
	boolean b = new int[] {} instanceof java.io.Serializable;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-always-7 FAILED


==== 15.20-2-always-8  Always true (but expression is still
        evaluated)  FAILED
==== Contents of test case:

    empty_main T15202a8 {
	// non-null instance to superinterface
	boolean b = new Cloneable() {} instanceof Cloneable;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-always-8 FAILED


==== 15.20-2-sometimes-1  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_main T15202s1 {
	Object o = new Object();
	// identity
	boolean b = o instanceof Object;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-1 FAILED


==== 15.20-2-sometimes-2  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_main T15202s2 {
	Object o = "";
	// narrowing
	boolean b = o instanceof Integer; // false at runtime
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-2 FAILED


==== 15.20-2-sometimes-3  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_main T15202s3 {
	String s = "";
	// widening
	boolean b = s instanceof Object;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-3 FAILED


==== 15.20-2-sometimes-4  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_main T15202s4 {
	Object o = "";
	// narrowing to interface
	boolean b = o instanceof Cloneable;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-4 FAILED


==== 15.20-2-sometimes-5  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_main T15202s5 {
	Object o = "";
	// narrowing to array
	boolean b = o instanceof int[];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-5 FAILED


==== 15.20-2-sometimes-6  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_main T15202s6 {
	Comparable c = "";
	// widening to Object
	boolean b = c instanceof Object;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-6 FAILED


==== 15.20-2-sometimes-7  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_class T15202s7 {
	interface I extends Cloneable {}
	I i = new I() {};
	// widening to superinterface
	boolean b = i instanceof Cloneable;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-7 FAILED


==== 15.20-2-sometimes-8  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_class T15202s8 {
	interface I extends Cloneable {}
	Cloneable c = new Cloneable() {};
	// narrowing to subinterface
	boolean b = c instanceof I;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-8 FAILED


==== 15.20-2-sometimes-9  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_class T15202s9 {
	Cloneable c = new Cloneable() {};
	// narrowing to array
	boolean b = c instanceof int[];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-9 FAILED


==== 15.20-2-sometimes-10  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_class T15202s10 {
	interface I {}
	Cloneable c = new Cloneable() {};
	// narrowing to compatible interface
	boolean b = c instanceof I;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-10 FAILED


==== 15.20-2-sometimes-11  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_class T15202s11 {
	int[] i = {};
	// widening to interface
	boolean b = i instanceof Cloneable;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-11 FAILED


==== 15.20-2-sometimes-12  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_class T15202s12 {
	String[] s = {};
	// widening to compatible array
	boolean b = s instanceof Object[];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-12 FAILED


==== 15.20-2-sometimes-13  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_class T15202s13 {
	String[] s = {};
	// widening to compatible array
	boolean b = s instanceof Comparable[];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-13 FAILED


==== 15.20-2-sometimes-14  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_class T15202s14 {
	Object[] o = {};
	// narrowing to compatible array
	boolean b = o instanceof Integer[];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-14 FAILED


==== 15.20-2-sometimes-15  Sometimes true - requires runtime check
        that reference is non-null and compatible  FAILED
==== Contents of test case:

    empty_class T15202s15 {
	Object[] o = {};
	// narrowing to compatible array
	boolean b = o instanceof Comparable[];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.20-2-sometimes-15 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/unary-operators

==== 15.15-group-1  Unary operators group right-to-left  FAILED
==== Contents of test case:

    constant_expression T15151 {-~0xffffffff == 0}  {~-0xffffffff == 0xfffffffe}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15-group-1 FAILED


==== 15.15-precedence-1  Unary operators have higher
        precedence than multiplicative  FAILED
==== Contents of test case:

    is_assignable_to T1515p1 float {(float) 1/1.0}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.15-precedence-1 FAILED


==== 15.15-precedence-2  Unary operators have higher
        precedence than multiplicative  FAILED
==== Contents of test case:

    is_assignable_to T1515p2 float {(float) (1/1.0)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15-precedence-2 FAILED


==== 15.15-precedence-3  Unary operators have higher
        precedence than multiplicative  FAILED
==== Contents of test case:

    constant_expression T1515p3 {-0x80000000/2 == 0xc0000000}  {-(0x80000000/2) == 0x40000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15-precedence-3 FAILED


==== 15.15-precedence-4  Unary operators have higher
        precedence than multiplicative  FAILED
==== Contents of test case:

    constant_expression T1515p4 {~0xffffffff*2 == 0}  {~(0xffffffff*2) == 1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15-precedence-4 FAILED


==== 15.15-precedence-5  Unary operators have higher
        precedence than addition, for boolean  FAILED
==== Contents of test case:

    constant_expression T1515p5 {!true + "" == "false"}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15-precedence-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/unary-operators/bitwise-complement-operator

==== 15.15.5-type-8  ~ must have integral operand  FAILED
==== Contents of test case:

    is_assignable_to T15155t8 short ~1

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.5-type-8 FAILED


==== 15.15.5-type-9  ~ must have integral operand  FAILED
==== Contents of test case:

    is_assignable_to T15155t9 char ~(~'1')

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.5-type-9 FAILED


==== 15.15.5-type-10  ~ must have integral operand  FAILED
==== Contents of test case:

    is_assignable_to T15155t10 byte ~1

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.5-type-10 FAILED


==== 15.15.5-int-1  ~x = -x-1 for all ints  FAILED
==== Contents of test case:

    constant_expression T15155i1 {~0 == -0-1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.5-int-1 FAILED


==== 15.15.5-int-2  ~x = -x-1 for all ints  FAILED
==== Contents of test case:

    constant_expression T15155i2 {~0xffffffff == -0xffffffff-1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.5-int-2 FAILED


==== 15.15.5-long-1  ~x = -x-1 for all longs  FAILED
==== Contents of test case:

    constant_expression T15155l1 {~0L == -0L-1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.5-long-1 FAILED


==== 15.15.5-long-2  ~x = -x-1 for all longs  FAILED
==== Contents of test case:

    constant_expression T15155l2 {~0xffffffffffffffffL == -0xffffffffffffffffL-1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.5-long-2 FAILED


==== 15.15.5-optimize-1  jikes 1.19 got this wrong  FAILED
==== Contents of test case:

    empty_class T15155o1 {
        T15155o1() {}
        int i, j = ~i & 0;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.5-optimize-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/unary-operators/logical-complement-operator

==== 15.15.6-boolean-1  ! true is false  FAILED
==== Contents of test case:

    constant_expression T15156b1 {!true == false}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.6-boolean-1 FAILED


==== 15.15.6-boolean-2  ! false is true  FAILED
==== Contents of test case:

    constant_expression T15156b2 {!false == true}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.6-boolean-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/unary-operators/prefix-decrement-operator

==== 15.15.2-argument-10  --Prefix must operate on a numeric
        variable, parenthesis may now surround variables  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T15152a10 {int i = 1, j = --(i);}]

---- Result was:
FAIL
---- Result should have been:
OK
==== 15.15.2-argument-10 FAILED


==== 15.15.2-type-1  --Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15152t1 {byte b = 1, b2 = --b;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.2-type-1 FAILED


==== 15.15.2-type-2  --Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15152t2 {short s = 1, s2 = --s;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.2-type-2 FAILED


==== 15.15.2-type-3  --Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15152t3 {char c = 1, c2 = --c;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.2-type-3 FAILED


==== 15.15.2-type-4  --Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15152t4 {int i = 1, i2 = --i;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.2-type-4 FAILED


==== 15.15.2-type-5  --Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15152t5 {long l = 1, l2 = --l;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.2-type-5 FAILED


==== 15.15.2-type-6  --Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15152t6 {float f = 1, f2 = --f;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.2-type-6 FAILED


==== 15.15.2-type-7  --Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15152t7 {double d = 1, d2 = --d;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.2-type-7 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/unary-operators/prefix-increment-operator

==== 15.15.1-argument-9  ++Prefix cannot operate on final variable  FAILED
==== Contents of test case:

    empty_class T15151a9 {final int i = 1, j = ++i;}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.15.1-argument-9 FAILED


==== 15.15.1-type-5  ++Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15151t5 {long l = 1, l2 = ++l;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.1-type-5 FAILED


==== 15.15.1-type-6  ++Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15151t6 {float f = 1, f2 = ++f;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.1-type-6 FAILED


==== 15.15.1-type-7  ++Prefix operates on all numeric types  FAILED
==== Contents of test case:

    empty_class T15151t7 {double d = 1, d2 = ++d;}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.1-type-7 FAILED


==== 15.15.1-final-1  ++Prefix cannot be applied to a final  FAILED
==== Contents of test case:

    empty_class T15151f1 {
	final int i;
	int j = ++i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.15.1-final-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/unary-operators/unary-minus-operator

==== 15.15.4-type-1  - must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15154t1 Object -null

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.15.4-type-1 FAILED


==== 15.15.4-type-2  - must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15154t2 boolean -true

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.15.4-type-2 FAILED


==== 15.15.4-type-3  - must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15154t3 Object {-(new Object())}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.15.4-type-3 FAILED


==== 15.15.4-type-5  - performs unary promotion  FAILED
==== Contents of test case:

#is_assignable_to creates byte n1, byte n2
    is_assignable_to T15154t5 byte 1 byte -n1

---- Result was:
PASS
---- Result should have been:
FAIL
==== 15.15.4-type-5 FAILED


==== 15.15.4-int-1  -x = ~x+1 for all ints  FAILED
==== Contents of test case:

    constant_expression T15154i1 {-0 == ~0+1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-int-1 FAILED


==== 15.15.4-int-2  -x = ~x+1 for all ints  FAILED
==== Contents of test case:

    constant_expression T15154i2 {-0xffffffff == ~0xffffffff+1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-int-2 FAILED


==== 15.15.4-int-3  -MIN_INT is still MIN_INT  FAILED
==== Contents of test case:

    constant_expression T15154i3 {-0x80000000 == 0x80000000}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-int-3 FAILED


==== 15.15.4-long-1  -x = ~x+1 for all longs  FAILED
==== Contents of test case:

    constant_expression T15154l1 {-0L == ~0L+1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-long-1 FAILED


==== 15.15.4-long-2  -x = ~x+1 for all longs  FAILED
==== Contents of test case:

    constant_expression T15154l2 {-0xffffffffffffffffL == ~0xffffffffffffffffL+1}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-long-2 FAILED


==== 15.15.4-long-3  -MIN_LONG is still MIN_LONG  FAILED
==== Contents of test case:

    constant_expression T15154l3 {-0x8000000000000000L == 0x8000000000000000L}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-long-3 FAILED


==== 15.15.4-float-1  -NaN is still NaN  FAILED
==== Contents of test case:

    constant_expression T15154f1 {-Float.NaN != -Float.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-float-1 FAILED


==== 15.15.4-float-2  - Infinity is Infinity of opposite sign  FAILED
==== Contents of test case:

    constant_expression T15154f2 {-Float.POSITIVE_INFINITY == Float.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-float-2 FAILED


==== 15.15.4-float-3  - 0.0 is zero of opposite sign  FAILED
==== Contents of test case:

    constant_expression T15154f3 {(1/0.0f) != (1/-0.0f)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-float-3 FAILED


==== 15.15.4-double-1  -NaN is still NaN  FAILED
==== Contents of test case:

    constant_expression T15154d1 {-Double.NaN != -Double.NaN}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-double-1 FAILED


==== 15.15.4-double-2  - Infinity is Infinity of opposite sign  FAILED
==== Contents of test case:

    constant_expression T15154d2 {-Double.POSITIVE_INFINITY == Double.NEGATIVE_INFINITY}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-double-2 FAILED


==== 15.15.4-double-3  - 0.0 is zero of opposite sign  FAILED
==== Contents of test case:

    constant_expression T15154d3 {(1/0.0) != (1/-0.0)}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-double-3 FAILED


==== 15.15.4-optimize-1  jikes 1.19 got this wrong  FAILED
==== Contents of test case:

    empty_class T15154o1 {
        T15154o1() {}
        int i, j = -i & 0;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.4-optimize-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/expressions/unary-operators/unary-plus-operator

==== 15.15.3-type-6  + must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15153t6 int +1

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.3-type-6 FAILED


==== 15.15.3-type-7  + must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15153t7 long +1L

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.3-type-7 FAILED


==== 15.15.3-type-8  + must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15153t8 float +1f

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.3-type-8 FAILED


==== 15.15.3-type-9  + must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15153t9 double +1d

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.3-type-9 FAILED


==== 15.15.3-type-10  + must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15153t10 short +1

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.3-type-10 FAILED


==== 15.15.3-type-11  + must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15153t11 char +'1'

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.3-type-11 FAILED


==== 15.15.3-type-12  + must have numeric operand  FAILED
==== Contents of test case:

    is_assignable_to T15153t12 byte +1

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.3-type-12 FAILED


==== 15.15.3-optimize-1  jikes 1.19 got this wrong  FAILED
==== Contents of test case:

    empty_class T15153o1 {
        T15153o1() {}
        int i, j = +i & 0;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 15.15.3-optimize-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/abstract-method-declarations

==== 9.4-modifier-1  interface methods may be redundantly public  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T94m1 "interface I { public void m(); }"]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.4-modifier-1 FAILED


==== 9.4-modifier-3  interface methods may be redundantly
        abstract  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T94m3 "interface I { abstract void m(); }"]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.4-modifier-3 FAILED


==== 9.4-modifier-14  Longest legal modifier sequence  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T94m14 {
        interface I { public abstract void m(); }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.4-modifier-14 FAILED


==== 9.4-conflict-2  An interface may inherit a method with the same
        name and signature twice  FAILED
==== Contents of test case:

    empty_class T94c2 {
        interface I1 { void m(); }
        interface I2 { void m(); }
        interface I3 extends I1, I2 {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.4-conflict-2 FAILED


==== 9.4-conflict-3  An interface may inherit a method with the same
        name and signature twice, and there is no ambiguity in using it  FAILED
==== Contents of test case:

    empty_class T94c3 {
        interface I1 { void m(); }
        interface I2 { void m(); }
        interface I3 extends I1, I2 {}
        void foo(I3 i) {
            i.m();
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.4-conflict-3 FAILED


==== 9.4-conflict-4  A method inherited through two paths is not
        ambiguous  FAILED
==== Contents of test case:

    empty_class T94c4 {
        interface I1 { void m(); }
        interface I2 extends I1 {}
        interface I3 extends I1, I2 {}
        void bar(I3 i) {
            i.m();
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.4-conflict-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/abstract-method-declarations/inheritance-and-overriding

==== 9.4.1-conflict-4  An interface must not inherit conflicting
        return types, but throws clauses are ok  FAILED
==== Contents of test case:

    empty_class T941c4 {
        class E1 extends Exception {}
        class E2 extends Exception {}
        interface I1 { void m() throws E1; }
        interface I2 { void m() throws E2; }
        interface I3 extends I1, I2 {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.4.1-conflict-4 FAILED


==== 9.4.1-override-1  methods not overridden are inherited  FAILED
==== Contents of test case:

    empty_class T941o1 {
        interface I1 {
            void m();
            void m(int i);
        }
        interface I2 extends I1 {
            void m();
        }
        void foo(I2 i) {
            i.m(1);
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.4.1-override-1 FAILED


==== 9.4.1-override-2  A method may be overridden to have a less
        permissive throws clause  FAILED
==== Contents of test case:

    empty_class T941o2 {
        interface I1 { void m() throws Throwable; }
        interface I2 extends I1 { void m() throws Exception; }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.4.1-override-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/abstract-method-declarations/overloading

==== 9.4.2-overload-1  there are no required relations between
        overloaded methods  FAILED
==== Contents of test case:

    empty_class T942o1 {
        interface I {
            void m();
            int m(int i) throws Exception;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.4.2-overload-1 FAILED


==== 9.4.2-overload-2  there are no required relations between
        overloaded methods  FAILED
==== Contents of test case:

    empty_class T942o2 {
        interface I1 {
            void m();
        }
        interface I2 extends I1 {
            int m(int i) throws Exception;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.4.2-overload-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/field-constant-declarations

==== 9.3-modifier-1  An interface field may be redundantly public  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T93m1 "interface I { public int i = 1; }"]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.3-modifier-1 FAILED


==== 9.3-modifier-3  An interface field may be redundantly static  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T93m3 "interface I { static int i = 1; }"]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.3-modifier-3 FAILED


==== 9.3-modifier-5  An interface field may be redundantly final  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T93m5 "interface I { final int i = 1; }"]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.3-modifier-5 FAILED


==== 9.3-modifier-15  Longest legal modifier sequence  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T93m15 {
        interface I { public static final int i = 1; }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.3-modifier-15 FAILED


==== 9.3-modifier-17  static public is legal, though redundant and
        not in the preferred order  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T93m17 {
	interface I { static public int i = 1; }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.3-modifier-17 FAILED


==== 9.3-modifier-18  final public is legal, though redundant and
        not in the preferred order  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T93m18 {
	interface I { final public int i = 1; }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.3-modifier-18 FAILED


==== 9.3-modifier-19  final static is legal, though redundant and
        not in the preferred order  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T93m19 {
	interface I { final static int i = 1; }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.3-modifier-19 FAILED


==== 9.3-conflict-2  An interface may inherit a field with the same
        name twice, provided it doesn't either one by simple name  FAILED
==== Contents of test case:

    empty_class T93c2 {
        interface I1 { int i = 1; }
        interface I2 { int i = 2; }
        interface I3 extends I1, I2 {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.3-conflict-2 FAILED


==== 9.3-conflict-4  A field inherited through two paths is not
        ambiguous  FAILED
==== Contents of test case:

    empty_class T93c4 {
        interface I1 { int i = 1; }
        interface I2 extends I1 {}
        interface I3 extends I1, I2 { int j = i; }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.3-conflict-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/field-constant-declarations/initialization-of-fields

==== 9.3.1-init-1  All interface fields must have an initializer  FAILED
==== Contents of test case:

    compile [saveas T931i1.java {
        interface T931i1 { int i; }
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 9.3.1-init-1 FAILED


==== 9.3.1-init-4  Initializer may use anonymous class  FAILED
==== Contents of test case:

    empty_class T931i4 {
        interface I { int i = new Object() { int foo() { return 1; } }.foo(); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.3.1-init-4 FAILED


==== 9.3.1-init-5  Initializer may use class literal  FAILED
==== Contents of test case:

    empty_class T931i5 "interface I { Class c = I.class; }"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.3.1-init-5 FAILED


==== 9.3.1-init-6  Initializer may use anonymous class  FAILED
==== Contents of test case:

    compile [saveas T931i6a.java {
interface T931i6a {
    int i = new Object() {
	int m() { return 0; }
    }.m();
}
class T931i6b {
    int j = T931i6a.i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.3.1-init-6 FAILED


==== 9.3.1-legal-forward-1  Simple usage before
        declaration legal if not in declaring class  FAILED
==== Contents of test case:

    empty_class T931lf1 {
        interface I {
            int i = I.j; // not simple usage
            int j = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.3.1-legal-forward-1 FAILED


==== 9.3.1-legal-forward-2  Simple usage before
        declaration legal if not in declaring class  FAILED
==== Contents of test case:

    empty_class T931lf2 {
        interface I {
            int i = new Object(){ int bar() { return j; } }.bar();
            // not in declaring class
            int j = 1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.3.1-legal-forward-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/interface-declarations

==== 9.1-enclosing-4  An interface may not have the same simple name
        as an enclosing type  FAILED
==== Contents of test case:

    compile [saveas T91e4.java {
interface T91e4 {
    Object o = new T91e4() {}; // anonymous classes have no simple name
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1-enclosing-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/interface-declarations/interface-body-and-member-declarations

==== 9.1.3-body-1  An interface may include a field declaration  FAILED
==== Contents of test case:

    empty_class T913b1 "interface I { int i = 1; }"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.3-body-1 FAILED


==== 9.1.3-body-2  An interface may include an abstract method
        declaration  FAILED
==== Contents of test case:

     empty_class T913b2 "interface I { void m(); }"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.3-body-2 FAILED


==== 9.1.3-body-3  An interface may include a class declaration  FAILED
==== Contents of test case:

    empty_class T913b3 "interface I { class C {} }"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.3-body-3 FAILED


==== 9.1.3-body-4  An interface may include an interface
        declaration  FAILED
==== Contents of test case:

    empty_class T913b4 "interface I { interface I1 {} }"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.3-body-4 FAILED


==== 9.1.3-body-5  An interface may include an empty declaration  FAILED
==== Contents of test case:

    empty_class T913b5 "interface I { ; }"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.3-body-5 FAILED


==== 9.1.3-body-9  A class in an interface may have a static initializer  FAILED
==== Contents of test case:

    empty_class T913b9 "interface I { class C { static {} } }"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.3-body-9 FAILED


==== 9.1.3-body-10  An interface may still create a clinit method  FAILED
==== Contents of test case:

  empty_class T913b10 {
    public static int m() { return 5; }
    interface I { int CONSTANT = m(); }
  }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.3-body-10 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/interface-declarations/interface-modifiers

==== 9.1.1-4 should generate an error if a modifier is given more than once FAILED
==== Contents of test case:

    compile [saveas PublicPublicInterface.java  "public public interface PublicPublicInterface {}"]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 9.1.1-4 FAILED


==== 9.1.1-8  An interface may be strictfp  FAILED
==== Contents of test case:

    compile [saveas T9118.java "strictfp interface T9118 {}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.1-8 FAILED


==== 9.1.1-11  Error declaring abstract more than once  FAILED
==== Contents of test case:

    compile [saveas T91111.java "abstract abstract interface T91111 {}"]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 9.1.1-11 FAILED


==== 9.1.1-16  longest legal combination  FAILED
==== Contents of test case:

    ok_pass_or_warn [compile [saveas T91116.java {
public abstract strictfp interface T91116 {}
}]]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1-16 FAILED


==== 9.1.1-in-class-1  may be public  FAILED
==== Contents of test case:

    empty_class T911ic1 "public interface I {}"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.1-in-class-1 FAILED


==== 9.1.1-in-class-2  may be protected  FAILED
==== Contents of test case:

    empty_class T911ic2 "protected interface I {}"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.1-in-class-2 FAILED


==== 9.1.1-in-class-3  may be private  FAILED
==== Contents of test case:

    empty_class T911ic3 "private interface I {}"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.1-in-class-3 FAILED


==== 9.1.1-in-class-13  may be redundantly abstract  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T911ic13 "abstract interface I {}"]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1-in-class-13 FAILED


==== 9.1.1-in-class-15  may be redundantly static  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T911ic15 "static interface I {}"]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1-in-class-15 FAILED


==== 9.1.1-in-class-17  may be strictfp  FAILED
==== Contents of test case:

    empty_class T911ic17 "strictfp interface I {}"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.1-in-class-17 FAILED


==== 9.1.1-in-class-24  longest legal combination  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T911ic24 {
public abstract static strictfp interface I {}
}]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1-in-class-24 FAILED


==== 9.1.1-in-interface-1  may be redundantly public  FAILED
==== Contents of test case:

    ok_pass_or_warn [compile [saveas T911ii1.java {
interface T911ii1 {
    public interface I {}
}
}]]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1-in-interface-1 FAILED


==== 9.1.1-in-interface-5  may be redundantly abstract  FAILED
==== Contents of test case:

    ok_pass_or_warn [compile [saveas T911ii5.java {
interface T911ii5 {
    abstract interface I {}
}
}]]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1-in-interface-5 FAILED


==== 9.1.1-in-interface-7  may be redundantly static  FAILED
==== Contents of test case:

    ok_pass_or_warn [compile [saveas T911ii7.java {
interface T911ii7 {
    static interface I {}
}
}]]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1-in-interface-7 FAILED


==== 9.1.1-in-interface-9  may be strictfp  FAILED
==== Contents of test case:

    compile [saveas T911ii9.java {
interface T911ii9 {
    strictfp interface I {}
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.1-in-interface-9 FAILED


==== 9.1.1-in-interface-16  longest legal combination  FAILED
==== Contents of test case:

    ok_pass_or_warn [compile [saveas T911ii16.java {
interface T911ii16 {
    public abstract static strictfp interface I {}
}
}]]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1-in-interface-16 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/interface-declarations/interface-modifiers/abstract-interfaces

==== 9.1.1.1-2  The compiler may generate a warning when
        abstract modifier is applied to an implicitly abstract inner interface  FAILED
==== Contents of test case:

    saveas AbstractInnerInterface.java  {
public class AbstractInnerInterface {
    abstract interface Inter {}
}
}
    ok_pass_or_warn [compile AbstractInnerInterface.java]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1.1-2 FAILED


==== 9.1.1.1-3  The compiler may generate a warning when
        abstract modifier is applied to an implicitly abstract inner interface
        that is defined inside another interface  FAILED
==== Contents of test case:

    saveas AbstractInnerInterface_InInnerface.java  {
public interface AbstractInnerInterface_InInnerface {
    abstract interface Inter {}
}
}
    ok_pass_or_warn [compile AbstractInnerInterface_InInnerface.java]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.1.1.1-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/interface-declarations/superinterfaces-and-subinterfaces

==== 9.1.2-accessible-4  All interfaces in the extends clause must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T912a4a.java {
package p1;
interface T912a4a {}
    }] [saveas T912a4b.java {
interface T912a4b extends p1.T912a4a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 9.1.2-accessible-4 FAILED


==== 9.1.2-accessible-5  All interfaces in the extends clause must
        be accessible  FAILED
==== Contents of test case:

    compile [saveas p1/T912a5a.java {
package p1;
public class T912a5a {
    protected interface I {}
}
    }] [saveas T912a5b.java {
class T912a5b extends p1.T912a5a {
    interface Sub extends I {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.2-accessible-5 FAILED


==== 9.1.2-accessible-6  All interfaces in the extends clause must
        be accessible  FAILED
==== Contents of test case:

    empty_class T912a6 {
	private interface One {}
	interface Two extends One {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.2-accessible-6 FAILED


==== 9.1.2-interface-3  A superinterface name may be non-canonical  FAILED
==== Contents of test case:

    compile [saveas T912i3a.java {
class T912i3a {
    interface Super {}
}
class T912i3b extends T912i3a {}
interface T912i3c extends T912i3b.Super {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.2-interface-3 FAILED


==== 9.1.2-interface-4  A superinterface name may be non-canonical  FAILED
==== Contents of test case:

    compile [saveas T912i4a.java {
class T912i4a {
    interface Super {}
}
class T912i4b extends T912i4a {
    interface C extends Super {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.2-interface-4 FAILED


==== 9.1.2-interface-5  A superinterface name may be non-canonical  FAILED
==== Contents of test case:

    compile [saveas T912i5a.java {
class T912i5a {
    interface Super {}
}
class T912i5b extends T912i5a {
    interface C extends T912i5b.Super {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.2-interface-5 FAILED


==== 9.1.2-interface-6  A superinterface name may be non-canonical  FAILED
==== Contents of test case:

    compile [saveas T912i6a.java {
class T912i6a {
    interface Super {}
}
class T912i6b extends T912i6a {
    interface C extends Super {}
}
interface T912i6c extends T912i6b.Super {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.2-interface-6 FAILED


==== 9.1.2-circular-1  An interface must not depend on itself  FAILED
==== Contents of test case:

    compile [saveas T912c1.java "interface T912c1 extends T912c1 {}"]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 9.1.2-circular-1 FAILED


==== 9.1.2-circular-3  An interface must not depend on itself  FAILED
==== Contents of test case:

    compile [saveas T912c3a.java {
interface T912c3a extends T912c3b {}
interface T912c3b extends T912c3a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 9.1.2-circular-3 FAILED


==== 9.1.2-circular-5  An interface must not depend on itself  FAILED
==== Contents of test case:

    compile [saveas T912c5a.java {
interface T912c5a {
    interface Inner1 extends T912c5b.Inner2 {}
}
interface T912c5b extends T912c5a {
    interface Inner2 {}
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.2-circular-5 FAILED


==== 9.1.2-unique-1  The extends clause must not list an element
        twice, by any name  FAILED
==== Contents of test case:

    compile [saveas T912u1.java {
interface T912u1 extends Cloneable, Cloneable {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 9.1.2-unique-1 FAILED


==== 9.1.2-unique-2  The extends clause must not list an element
        twice, by any name  FAILED
==== Contents of test case:

    compile [saveas T912u2.java {
interface T912u2 extends java.lang.Cloneable, Cloneable {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 9.1.2-unique-2 FAILED


==== 9.1.2-supertype-1  Test for accessible inner supertype - Jikes
        bug 3202  FAILED
==== Contents of test case:

    compile [saveas T912s1_1.java {
interface T912s1_1 {
    interface One {}
}
interface T912s1_2 extends T912s1_1 {
    interface Two extends One {}
}
interface T912s1_3 extends T912s1_2 {
    interface Three extends Two {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.1.2-supertype-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/interfaces/interface-members

==== 9.2-implicit-1  Interfaces implicitly have all public method
        members of Object  FAILED
==== Contents of test case:

    empty_class T92i1 {
        interface I {}
        void foo(I i) {
            i.getClass();
            i.toString();
            i.equals(null);
            i.hashCode();
            try {
                i.wait();
                i.wait(1);
                i.wait(1, 0);
                i.notifyAll();
                i.notify();
            } catch (Throwable t) {
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.2-implicit-1 FAILED


==== 9.2-implicit-5  An interface may redeclare a non-final method
        of Object  FAILED
==== Contents of test case:

    empty_class T92i5 "interface I { String toString() throws Error; }"

---- Result was:
FAIL
---- Result should have been:
PASS
==== 9.2-implicit-5 FAILED


==== 9.2-implicit-8  Interfaces do not implicitly have any protected
        methods from Object. Thus, this declaration is legal (although the
        interface is unimplementable) - see Jikes bug 2878  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T92i8 "interface I { int clone(); }"]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.2-implicit-8 FAILED


==== 9.2-implicit-9  Interfaces do not implicitly have any protected
        methods from Object. Thus, this declaration is legal - see Jikes
        bug 2878  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T92i9 {
        interface I { Object clone() throws java.io.IOException; }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.2-implicit-9 FAILED


==== 9.2-implicit-10  Interfaces do not implicitly have any protected
        methods from Object. Thus, this declaration is legal (although the
        interface is unimplementable) - see Jikes bug 2878  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T92i10 "interface I { int finalize(); }"]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.2-implicit-10 FAILED


==== 9.2-implicit-13  Although an interface may extend the throws
        clause for clone(), implementing classes can only throw the common
        subset of checked exceptions as compared to Object.clone  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T92i13 {
        interface I { Object clone() throws java.io.IOException; }
        class C implements I {
            public Object clone() { return null; }
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.2-implicit-13 FAILED


==== 9.2-implicit-16  Although an interface may extend the throws
        clause for clone(), implementing classes can only throw the common
        subset of checked exceptions as compared to Object.clone  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T92i16 {
        interface I { Object clone() throws java.io.IOException; }
        abstract class C implements I {
            public abstract Object clone();
        }
        void m(C c) {
            c.clone(); // cannot throw a checked exception
        }
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 9.2-implicit-16 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/comments

==== 3.7-8  /**/ is a documentaiton comment  FAILED
==== Contents of test case:

    compile [saveas T378.java "class T378 {/**/}"]

---- Result was:
WARN
---- Result should have been:
PASS
==== 3.7-8 FAILED


==== 3.7-16  // may end at EOF. See Sun bug 4386773: the grammar
        given in the JLS will (most likely) be clarified to allow this, since
        virtually every previous compiler has done so  FAILED
==== Contents of test case:

    compile [saveas T3716.java "class T3716 {} //"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.7-16 FAILED


==== 3.7-25  comments may be unicode  FAILED
==== Contents of test case:

    empty_main T3725 {
        \u002f\u002f This is a comment\u000a int i;
        \u002f\u002a So's this \u002a\u002f
        i = 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.7-25 FAILED


==== 3.7-29  /**/ is a legal, degenerate doc comment, in spite of
        a bug in the grammar which doesn't allow it  FAILED
==== Contents of test case:

    empty_class T3729 "/**/"

---- Result was:
WARN
---- Result should have been:
PASS
==== 3.7-29 FAILED


==== 3.7-line-number-4  test line counts in comments  FAILED
==== Contents of test case:

    compile [saveas T37ln4.java "class T37ln4 { /* \\u000a */ }oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.7-line-number-4 FAILED


==== 3.7-line-number-6  test line counts in comments  FAILED
==== Contents of test case:

    compile [saveas T37ln6.java "class T37ln6 { /*\\u000a */ }oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.7-line-number-6 FAILED


==== 3.7-line-number-8  test line counts in comments  FAILED
==== Contents of test case:

    compile [saveas T37ln8.java "class T37ln8 { /* *\\u000a */ }oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.7-line-number-8 FAILED


==== 3.7-line-number-10  test line counts in comments  FAILED
==== Contents of test case:

    compile [saveas T37ln10.java "class T37ln10 { /** \\u000a */ }oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.7-line-number-10 FAILED


==== 3.7-line-number-14  test line counts in comments  FAILED
==== Contents of test case:

    compile [saveas T37ln14.java "class T37ln14 { /** *\\u000a */ }oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.7-line-number-14 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/identifiers

==== 3.8-valid-8  valid identifier, as \ufeff satisfies
        Character.isJavaIdentifierPart  FAILED
==== Contents of test case:

    identifier T38v8 i\\ufeff

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.8-valid-8 FAILED


==== 3.8-valid-9  valid identifier, as \u0000 satisfies
        Character.isJavaIdentifierPart  FAILED
==== Contents of test case:

    identifier T38v9 i\\u0000

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.8-valid-9 FAILED


==== 3.8-valid-10  example of unique identifiers  FAILED
==== Contents of test case:

    compile [saveas T38v10.java {
class T38v10 {
    int \u0041; // LATIN CAPITAL A
    int \u0061; // LATIN SMALL A
    int \u0391; // GREEK CAPITAL ALPHA
    int \u0480; // CYRILLIC SMALL A
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.8-valid-10 FAILED


==== 3.8-valid-11  example of unique identifiers  FAILED
==== Contents of test case:

    compile [saveas T38v11.java {
class T38v11 {
    int \u00c1; // LATIN CAPITAL A ACUTE
    int \u0041\u0301; // LATIN CAPITAL A, followed by NON-SPACING ACUTE
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.8-valid-11 FAILED


==== 3.8-valid-12  valid identifier, as \u001a satisfies
        Character.isJavaIdentifierPart  FAILED
==== Contents of test case:

    identifier T38v12 i\\u001a

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.8-valid-12 FAILED


==== 3.8-ignorable-2  JCL docs refer to 200a, but real value is 202a  FAILED
==== Contents of test case:

    compile [saveas T38ignoreable2.java {
class T38ignoreable2 {
    int i\u202a;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.8-ignorable-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/input-elements-and-tokens

==== 3.5-9  The ASCII SUB character (0x1a) should be ignored if it is
        the last character in the escaped stream.  FAILED
==== Contents of test case:

    set S \x1a
    compile [saveas T359.java "class T359 {  }$S"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.5-9 FAILED


==== 3.5-10  The ASCII SUB character (0x1a) should be ignored if it is
        the last character in the escaped stream.  FAILED
==== Contents of test case:

    set S \\u001a
    compile [saveas T3510.java "class T3510 {  }$S"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.5-10 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/keywords

==== 3.9-9  const is a keyword  FAILED
==== Contents of test case:

    keyword T399 const

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.9-9 FAILED


==== 3.9-20  goto is a keyword  FAILED
==== Contents of test case:

    keyword T3920 goto

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.9-20 FAILED


==== 3.9-24  instanceof is a keyword  FAILED
==== Contents of test case:

    keyword T3924 instanceof

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.9-24 FAILED


==== 3.9-37  strictfp is a keyword,
        it is new to version 2 of the JLS spec  FAILED
==== Contents of test case:

    keyword T3937 strictfp

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.9-37 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/lexical-translations

==== 3.2-invalid-9  Even in comments, \u escapes must be legal  FAILED
==== Contents of test case:

    empty_main T32i9 {
	/* \udefg */
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.2-invalid-9 FAILED


==== 3.2-valid-1  Compiler should recognize difference in tokens  FAILED
==== Contents of test case:

    empty_main T32v1 {
        boolean b1=""+1instanceof String;
        boolean b2=""+1Linstanceof String;
        boolean b3=""+1linstanceof String;
        boolean b4=""+1Dinstanceof String;
        boolean b5=""+1dinstanceof String;
        boolean b6=""+1Finstanceof String;
        boolean b7=""+1finstanceof String;
        boolean b8=""+0x1instanceof String;
        boolean b9=""+0xAinstanceof String;
        boolean b10=""+0xainstanceof String;
        boolean b11=""+'1'instanceof String;
        boolean b12=""+1.instanceof String;
        boolean b13=""+.1instanceof String;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.2-valid-1 FAILED


==== 3.2-valid-3  The parser must consume the largest token  FAILED
==== Contents of test case:

    empty_main T32v3 {
	int i = 1;
	boolean b = i >= 1;
	i >>= i >> 1;
	i >>>= i >>> 1;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.2-valid-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/line-terminators

==== 3.4-valid-3  CR (\u000d) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000d
    compile [saveas T34v3.java "class T34v3 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-3 FAILED


==== 3.4-valid-4  LF (\u000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000a
    compile [saveas T34v4.java "class T34v4 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-4 FAILED


==== 3.4-valid-5  CR (\u000D) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000D
    compile [saveas T34v5.java "class T34v5 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-5 FAILED


==== 3.4-valid-6  LF (\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000A
    compile [saveas T34v6.java "class T34v6 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-6 FAILED


==== 3.4-valid-8  CRLF (\r\u000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \r\\u000a
    compile [saveas T34v8.java "class T34v8 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-8 FAILED


==== 3.4-valid-10  CRLF (\r\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \r\\u000A
    compile [saveas T34v10.java "class T34v10 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-10 FAILED


==== 3.4-valid-12  CRLF (\u000d\u000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000d\\u000a
    compile [saveas T34v12.java "class T34v12 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-12 FAILED


==== 3.4-valid-13  CRLF (\u000d\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000d\\u000A
    compile [saveas T34v13.java "class T34v13 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-13 FAILED


==== 3.4-valid-14  CRLF (\u000D\u000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000D\\u000a
    compile [saveas T34v14.java "class T34v14 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-14 FAILED


==== 3.4-valid-15  CRLF (\u000D\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000D\\u000A
    compile [saveas T34v15.java "class T34v15 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-15 FAILED


==== 3.4-valid-16  CR (\uuuuu000d) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000d
    compile [saveas T34v16.java "class T34v16 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-16 FAILED


==== 3.4-valid-17  LF (\uuuuu000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000a
    compile [saveas T34v17.java "class T34v17 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-17 FAILED


==== 3.4-valid-18  CR (\uuuuu000D) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000D
    compile [saveas T34v18.java "class T34v18 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-18 FAILED


==== 3.4-valid-19  LF (\uuuuu000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000A
    compile [saveas T34v19.java "class T34v19 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-19 FAILED


==== 3.4-valid-20  CRLF (\r\uuuuu000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \r\\uuuuu000a
    compile [saveas T34v20.java "class T34v20 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-20 FAILED


==== 3.4-valid-22  CRLF (\r\uuuuu000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \r\\uuuuu000A
    compile [saveas T34v22.java "class T34v22 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-22 FAILED


==== 3.4-valid-24  CRLF (\uuuuu000d\u000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000d\\u000a
    compile [saveas T34v24.java "class T34v24 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-24 FAILED


==== 3.4-valid-25  CRLF (\uuuuu000d\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000d\\u000A
    compile [saveas T34v25.java "class T34v25 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-25 FAILED


==== 3.4-valid-26  CRLF (\uuuuu000D\u000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000D\\u000a
    compile [saveas T34v26.java "class T34v26 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-26 FAILED


==== 3.4-valid-27  CRLF (\uuuuu000D\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000D\\u000A
    compile [saveas T34v27.java "class T34v27 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-27 FAILED


==== 3.4-valid-28  CRLF (\u000d\uuuuu000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000d\\uuuuu000a
    compile [saveas T34v28.java "class T34v28 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-28 FAILED


==== 3.4-valid-29  CRLF (\u000d\uuuuu000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000d\\uuuuu000A
    compile [saveas T34v29.java "class T34v29 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-29 FAILED


==== 3.4-valid-30  CRLF (\u000D\uuuuu000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000D\\uuuuu000a
    compile [saveas T34v30.java "class T34v30 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-30 FAILED


==== 3.4-valid-31  CRLF (\u000D\uuuuu000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000D\\uuuuu000A
    compile [saveas T34v31.java "class T34v31 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-31 FAILED


==== 3.4-valid-32  CRLF (\uuuuu000d\uuuuu000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000d\\uuuuu000a
    compile [saveas T34v32.java "class T34v32 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-32 FAILED


==== 3.4-valid-33  CRLF (\uuuuu000d\uuuuu000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000d\\uuuuu000A
    compile [saveas T34v33.java "class T34v33 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-33 FAILED


==== 3.4-valid-34  CRLF (\uuuuu000D\uuuuu000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000D\\uuuuu000a
    compile [saveas T34v34.java "class T34v34 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-34 FAILED


==== 3.4-valid-35  CRLF (\uuuuu000D\uuuuu000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\uuuuu000D\\uuuuu000A
    compile [saveas T34v35.java "class T34v35 { // $S}"]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.4-valid-35 FAILED


==== 3.4-line-number-1  CR (\r) is a LineTerminator  FAILED
==== Contents of test case:

    set S \r
    compile [saveas T34ln1.java "${S}class T34ln1 {}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-1 FAILED


==== 3.4-line-number-3  CR (\u000d) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000d
    compile [saveas T34ln3.java "${S}class T34ln3 {}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-3 FAILED


==== 3.4-line-number-4  LF (\u000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000a
    compile [saveas T34ln4.java "${S}class T34ln4 {}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-4 FAILED


==== 3.4-line-number-5  CR (\u000D) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000D
    compile [saveas T34ln5.java "${S}class T34ln5 {}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-5 FAILED


==== 3.4-line-number-6  LF (\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000A
    compile [saveas T34ln6.java "${S}class T34ln6 {}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-6 FAILED


==== 3.4-line-number-8  CRLF (\r\u000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \r\\u000a
    compile [saveas T34ln8.java "${S}class T34ln8 {}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-8 FAILED


==== 3.4-line-number-9  CRLF (\u000d\n) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000d\n
    compile [saveas T34ln9.java "${S}class T34ln9 {}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-9 FAILED


==== 3.4-line-number-10  CRLF (\r\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \r\\u000A
    compile [saveas T34ln10.java "${S}class T34ln10{}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-10 FAILED


==== 3.4-line-number-11  CRLF (\u000D\n) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000D\n
    compile [saveas T34ln11.java "${S}class T34ln11{}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-11 FAILED


==== 3.4-line-number-13  CRLF (\u000d\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000d\\u000A
    compile [saveas T34ln13.java "${S}class T34ln13{}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-13 FAILED


==== 3.4-line-number-14  CRLF (\u000D\u000a) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000D\\u000a
    compile [saveas T34ln14.java "${S}class T34ln14{}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-14 FAILED


==== 3.4-line-number-15  CRLF (\u000D\u000A) is a LineTerminator  FAILED
==== Contents of test case:

    set S \\u000D\\u000A
    compile [saveas T34ln15.java "${S}class T34ln15{}oops"]
    match_err_or_warn {*.java*2*}

---- Result was:
0
---- Result should have been:
1
==== 3.4-line-number-15 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/literals/character-literals

==== 3.10.4-invalid-2  A SingleCharacter cannot be '  FAILED
==== Contents of test case:

    literal T3104i2 {\u0027}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.4-invalid-2 FAILED


==== 3.10.4-invalid-4  A SingleCharacter cannot be \  FAILED
==== Contents of test case:

    literal T3104i4 {\u005c}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.4-invalid-4 FAILED


==== 3.10.4-invalid-8  A LineTerminator is not an InputCharacter  FAILED
==== Contents of test case:

    literal T3104i8 {\u000d}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.4-invalid-8 FAILED


==== 3.10.4-invalid-9  A LineTerminator is not an InputCharacter  FAILED
==== Contents of test case:

    literal T3104i9 {\u000a}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.4-invalid-9 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/literals/escape-sequences

==== 3.10.7-valid-12  escape sequences may be written in unicode  FAILED
==== Contents of test case:

    sequence T3107v12 {\u005c\u005c}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.7-valid-12 FAILED


==== 3.10.7-valid-13  an octal sequence with the first
        digit >= 4 has at most two digits  FAILED
==== Contents of test case:

    compile [saveas T3107v13.java {
class T3107v13 {
    void foo(int i) {
	switch (i) {
	    case 0:
	    case (("\477" == "'7") ? 1 : 0):
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.7-valid-13 FAILED


==== 3.10.7-valid-14  escape sequences represent characters
        with identical value  FAILED
==== Contents of test case:

    compile [saveas T3107v14.java {
class T3107v14 {
    void foo(int i) {
	switch (i) {
	    case 0:
	    case (('\t' == 9) ? 1 : 0):
	    case (('\t' == '\011') ? 2 : 0):
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.7-valid-14 FAILED


==== 3.10.7-valid-15  escape sequences represent the same
        character in a String  FAILED
==== Contents of test case:

    compile [saveas T3107v15.java {
class T3107v15 {
    void foo(int i) {
	switch (i) {
	    case 0:
	    case (("\b" == "\u0008") ? 1 : 0):
	    case (("\10" == "\u0008") ? 2 : 0):
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.7-valid-15 FAILED


==== 3.10.7-valid-17  an octal sequence with the first
        digit < 4 has at most three digits  FAILED
==== Contents of test case:

    compile [saveas T3107v17.java {
class T3107v17 {
    void foo(int i) {
	switch (i) {
	    case 0:
	    case (("\0000" == '\u0000' + "0") ? 1 : 0):
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.7-valid-17 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/literals/floating-point-literals

==== 3.10.2-round-1  It is an error for a floating-point
        literal to round to an infinity  FAILED
==== Contents of test case:

    literal T3102r1 1e39f

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.2-round-1 FAILED


==== 3.10.2-round-2  It is an error for a floating-point
        literal to round to an infinity  FAILED
==== Contents of test case:

    literal T3102r2 -1e310

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.2-round-2 FAILED


==== 3.10.2-round-3  It is an error for a nonzero
        floating-point to round to zero  FAILED
==== Contents of test case:

    literal T3102r3 1e-47f

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.2-round-3 FAILED


==== 3.10.2-round-4  It is an error for a nonzero
        floating-point to round to zero  FAILED
==== Contents of test case:

    literal T3102r4 -1e-326

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.2-round-4 FAILED


==== 3.10.2-round-5  It is an error for a floating-point
        literal to round to an infinity  FAILED
==== Contents of test case:

    literal T3102r5 340282356779733661637539395458142568448f

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.2-round-5 FAILED


==== 3.10.2-round-6  It is an error for a floating-point
        literal to round to an infinity  FAILED
==== Contents of test case:

    literal T3102r6 179769313486231580793728971405303415079934132710037826936173778980444968292764750946649017977587207096330286416692887910946555547851940402630657488671505820681908902000708383676273854845817711531764475730270069855571366959622842914819860834936475292719074168444365510704342711559699508093042880177904174497792.0

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.2-round-6 FAILED


==== 3.10.2-round-7  It is an error for a nonzero
        floating-point to round to zero  FAILED
==== Contents of test case:

    literal T3102r7 0.000000000000000000000000000000000000000000000700649232162408535461864791644958065640130970938257885878534141944895541342930300743319094181060791015625f

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.2-round-7 FAILED


==== 3.10.2-round-8  It is an error for a nonzero
        floating-point to round to zero  FAILED
==== Contents of test case:

    literal T3102r8 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000024703282292062327208828439643411068618252990130716238221279284125033775363510437593264991818081799618989828234772285886546332835517796989819938739800539093906315035659515570226392290858392449105184435931802849936536152500319370457678249219365623669863658480757001585769269903706311928279558551332927834338409351978015531246597263579574622766465272827220056374006485499977096599470454020828166226237857393450736339007967761930577506740176324673600968951340535537458516661134223766678604162159680461914467291840300530057530849048765391711386591646239524912623653881879636239373280423891018672348497668235089863388587925628302755995657524455507255189313690836254779186948667994968324049705821028513185451396213837722826145437693412532098591327667236328125

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.2-round-8 FAILED


==== 3.10.2-round-9  test rounding at border of float denorms  FAILED
==== Contents of test case:

    constant_expression T3102r9  {0.00000000000000000000000000000000000001175494280757364291727882991035766513322858992758990427682963118425003064965173038558532425668090581893920898437499999f == 1.1754942e-38f}  {0.000000000000000000000000000000000000011754942807573642917278829910357665133228589927589904276829631184250030649651730385585324256680905818939208984375f == 1.1754944e-38f}  {0.00000000000000000000000000000000000001175494280757364291727882991035766513322858992758990427682963118425003064965173038558532425668090581893920898437500001f == 1.1754944e-38f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-round-9 FAILED


==== 3.10.2-round-10  test rounding at border of double denorms.
        Note that Javac 1.3 enters an infinite loop on this test.  FAILED
==== Contents of test case:

    constant_expression T3102r10  {0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072011360574097967091319759348195463516456480234261097248222220210769455165295239081350879141491589130396211068700864386945946455276572074078206217433799881410632673292535522868813721490129811224514518898490572223072852551331557550159143974763979834118019993239625482890171070818506906306666559949382757725720157630626906633326475653000092458883164330377797918696120494973903778297049050510806099407302629371289589500035837999672072543043602840788957717961509455167482434710307026091446215722898802581825451803257070188608721131280795122334262883686223215037756666225039825343359745688844239002654981983854879482922068947216898310996983658468140228542433306603398508864458040010349339704275671864433837704860378616227717385456230658746790140867233276367187499999 == 2.225073858507201e-308}  {0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000222507385850720113605740979670913197593481954635164564802342610972482222202107694551652952390813508791414915891303962110687008643869459464552765720740782062174337998814106326732925355228688137214901298112245145188984905722230728525513315575501591439747639798341180199932396254828901710708185069063066665599493827577257201576306269066333264756530000924588831643303777979186961204949739037782970490505108060994073026293712895895000358379996720725430436028407889577179615094551674824347103070260914462157228988025818254518032570701886087211312807951223342628836862232150377566662250398253433597456888442390026549819838548794829220689472168983109969836584681402285424333066033985088644580400103493397042756718644338377048603786162277173854562306587467901408672332763671875 == 2.2250738585072014e-308}  {0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000022250738585072011360574097967091319759348195463516456480234261097248222220210769455165295239081350879141491589130396211068700864386945946455276572074078206217433799881410632673292535522868813721490129811224514518898490572223072852551331557550159143974763979834118019993239625482890171070818506906306666559949382757725720157630626906633326475653000092458883164330377797918696120494973903778297049050510806099407302629371289589500035837999672072543043602840788957717961509455167482434710307026091446215722898802581825451803257070188608721131280795122334262883686223215037756666225039825343359745688844239002654981983854879482922068947216898310996983658468140228542433306603398508864458040010349339704275671864433837704860378616227717385456230658746790140867233276367187500001 == 2.2250738585072014e-308}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-round-10 FAILED


==== 3.10.2-round-11  test rounding at largest float where
        Float.MIN_VALUE is 1 ulp  FAILED
==== Contents of test case:

    constant_expression T3102r11  {0.00000000000000000000000000000000000002350988491449805367214912435885053862149911421504883761540137648996591935440791942824034777004271745681762695312499999999f == 2.3509884e-38f}  {0.00000000000000000000000000000000000002350988491449805367214912435885053862149911421504883761540137648996591935440791942824034777004271745681762695312500000000f == 2.3509884e-38f}  {0.00000000000000000000000000000000000002350988491449805367214912435885053862149911421504883761540137648996591935440791942824034777004271745681762695312500000001f == 2.3509886e-38f}  {0.00000000000000000000000000000000000002350988631579651799696619528258012191141524549531077949191714824703420324419900211410094925668090581893920898437499999999f == 2.3509886e-38f}  {0.00000000000000000000000000000000000002350988631579651799696619528258012191141524549531077949191714824703420324419900211410094925668090581893920898437500000000f == 2.3509887e-38f}  {0.00000000000000000000000000000000000002350988631579651799696619528258012191141524549531077949191714824703420324419900211410094925668090581893920898437500000001f == 2.3509887e-38f}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-round-11 FAILED


==== 3.10.2-round-12  test rounding at largest double where
        Double.MIN_VALUE is 1 ulp  FAILED
==== Contents of test case:

    constant_expression T3102r12  {0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044501477170144020250819966727949918635852426585926051135169509122872622312493126406953054127118942431783801370080830523154578251545303238277269592368457430440993619708911874715081505094180604803751173783204118519353387964161152051487413083163272520124606023105869053620631175265621765214646643181420505164043632222668006474326056011713528291579642227455489682133472873831754840341397809846934151055619529382191981473003234105366170879223151087335413188049110555339027884856781219017754500629806224571029581637117459456877330110324211689177656713705497387108207822477584250967061891687062782163335299376138075114200886249979505279101870966346394401564490729731565935244123171539810221213221201847003580761626016356864581135848683152156368691976240370422601699829101562499999 == 4.450147717014402e-308}  {0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044501477170144020250819966727949918635852426585926051135169509122872622312493126406953054127118942431783801370080830523154578251545303238277269592368457430440993619708911874715081505094180604803751173783204118519353387964161152051487413083163272520124606023105869053620631175265621765214646643181420505164043632222668006474326056011713528291579642227455489682133472873831754840341397809846934151055619529382191981473003234105366170879223151087335413188049110555339027884856781219017754500629806224571029581637117459456877330110324211689177656713705497387108207822477584250967061891687062782163335299376138075114200886249979505279101870966346394401564490729731565935244123171539810221213221201847003580761626016356864581135848683152156368691976240370422601699829101562500000 == 4.450147717014402e-308}  {0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044501477170144020250819966727949918635852426585926051135169509122872622312493126406953054127118942431783801370080830523154578251545303238277269592368457430440993619708911874715081505094180604803751173783204118519353387964161152051487413083163272520124606023105869053620631175265621765214646643181420505164043632222668006474326056011713528291579642227455489682133472873831754840341397809846934151055619529382191981473003234105366170879223151087335413188049110555339027884856781219017754500629806224571029581637117459456877330110324211689177656713705497387108207822477584250967061891687062782163335299376138075114200886249979505279101870966346394401564490729731565935244123171539810221213221201847003580761626016356864581135848683152156368691976240370422601699829101562500001 == 4.4501477170144023e-308}  {0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044501477170144025191476425140415360401540355268139774785767535266120266568349951413708126829206461084782164986440754321120225206002480547543836695927855394428741579816730655978088636997294650082209345461693939556240574324731139358717913147037364055774449896230603026352327326665938919068627384443806161075753898808234874156196451614819777611032358142380042975188038317843029641638497805266254045146423695015437229044481924252633972472775537202836761223314045275532818152963888710721086727474559560291862013573209842350335698170430223195347466466783839664426537070382566775697838267614310656819420077579872544813734533267952182996686996626897593533069381831182603797982290422495647610946820195511813521925831718993954860378616227717385456230658746790140867233276367187499999 == 4.4501477170144023e-308}  {0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044501477170144025191476425140415360401540355268139774785767535266120266568349951413708126829206461084782164986440754321120225206002480547543836695927855394428741579816730655978088636997294650082209345461693939556240574324731139358717913147037364055774449896230603026352327326665938919068627384443806161075753898808234874156196451614819777611032358142380042975188038317843029641638497805266254045146423695015437229044481924252633972472775537202836761223314045275532818152963888710721086727474559560291862013573209842350335698170430223195347466466783839664426537070382566775697838267614310656819420077579872544813734533267952182996686996626897593533069381831182603797982290422495647610946820195511813521925831718993954860378616227717385456230658746790140867233276367187500000 == 4.450147717014403e-308}  {0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000044501477170144025191476425140415360401540355268139774785767535266120266568349951413708126829206461084782164986440754321120225206002480547543836695927855394428741579816730655978088636997294650082209345461693939556240574324731139358717913147037364055774449896230603026352327326665938919068627384443806161075753898808234874156196451614819777611032358142380042975188038317843029641638497805266254045146423695015437229044481924252633972472775537202836761223314045275532818152963888710721086727474559560291862013573209842350335698170430223195347466466783839664426537070382566775697838267614310656819420077579872544813734533267952182996686996626897593533069381831182603797982290422495647610946820195511813521925831718993954860378616227717385456230658746790140867233276367187500001 == 4.450147717014403e-308}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-round-12 FAILED


==== 3.10.2-float-11  unicode 1e0F  FAILED
==== Contents of test case:

    literal T3102f11 {\u0031\u0065\u0030\u0046}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-float-11 FAILED


==== 3.10.2-float-12  largest finite float, by rounding  FAILED
==== Contents of test case:

    constant_expression T3102f12 {340282356779733661637539395458142568447.99999f == Float.MAX_VALUE}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-float-12 FAILED


==== 3.10.2-float-13  smallest finite float, by rounding.
        errors: fail to parse number, round number to zero
        note: We can't compare to Float.MIN_VALUE because
        some stupid JDK versions don't use a constant value  FAILED
==== Contents of test case:

    constant_expression T3102f13 {0.00000000000000000000000000000000000000000000070064923216240853546186479164495806564013097093825788587853414194489554134293030074331909418106079101562500001f != 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-float-13 FAILED


==== 3.10.2-float-14  valid float overrides invalid octal  FAILED
==== Contents of test case:

    constant_expression T3102f14 {08.f == 8} {09.f == 9}  {08e0f == 8} {09e0f == 9}  {08f == 8} {09f == 9}  {08.F == 8} {09.F == 9}  {08e0F == 8} {09e0F == 9}  {08F == 8} {09F == 9}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-float-14 FAILED


==== 3.10.2-float-15  valid float overrides invalid octal  FAILED
==== Contents of test case:

    constant_expression T3102f15 {0180.f == 180} {0190.f == 190}  {0180e0f == 180} {0190e0f == 190}  {0180f == 180} {0190f == 190}  {0180.F == 180} {0190.F == 190}  {0180e0F == 180} {0190e0F == 190}  {0180F == 180} {0190F == 190}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-float-15 FAILED


==== 3.10.2-float-16  check for 0 followed by letter  FAILED
==== Contents of test case:

    constant_expression T3102f16 {0e+0f == 0e-0f} {0E1f == 0} {0f == 0F}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-float-16 FAILED


==== 3.10.2-double-10  the compiler should correctly
        round denormalized literals  FAILED
==== Contents of test case:

    constant_expression T3102d10 {.0000000000012345678901234567890e+10 ==
	    1.2345678901234568e-2}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-double-10 FAILED


==== 3.10.2-double-13  largest finite double, by rounding  FAILED
==== Contents of test case:

    constant_expression T3102d13 {179769313486231580793728971405303415079934132710037826936173778980444968292764750946649017977587207096330286416692887910946555547851940402630657488671505820681908902000708383676273854845817711531764475730270069855571366959622842914819860834936475292719074168444365510704342711559699508093042880177904174497791.999999 == Double.MAX_VALUE}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-double-13 FAILED


==== 3.10.2-double-14  smallest finite double, by rounding
        errors: fail to parse number, round number to zero
        note: We can't compare to Double.MIN_VALUE because
        some stupid JDK versions don't use a constant value  FAILED
==== Contents of test case:

    constant_expression T3102d14 {0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002470328229206232720882843964341106861825299013071623822127928412503377536351043759326499181808179961898982823477228588654633283551779698981993873980053909390631503565951557022639229085839244910518443593180284993653615250031937045767824921936562366986365848075700158576926990370631192827955855133292783433840935197801553124659726357957462276646527282722005637400648549997709659947045402082816622623785739345073633900796776193057750674017632467360096895134053553745851666113422376667860416215968046191446729184030053005753084904876539171138659164623952491262365388187963623937328042389101867234849766823508986338858792562830275599565752445550725518931369083625477918694866799496832404970582102851318545139621383772282614543769341253209859132766723632812500001 != 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-double-14 FAILED


==== 3.10.2-double-15  valid double overrides invalid octal  FAILED
==== Contents of test case:

    constant_expression T3102d15 {08. == 8} {09. == 9}  {08e0 == 8} {09e0 == 9}  {08.d == 8} {09.d == 9}  {08e0d == 8} {09e0d == 9}  {08d == 8} {09d == 9}  {08.D == 8} {09.D == 9}  {08e0D == 8} {09e0D == 9}  {08D == 8} {09D == 9}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-double-15 FAILED


==== 3.10.2-double-16  valid double overrides invalid octal  FAILED
==== Contents of test case:

    constant_expression T3102d16 {0180. == 180} {0190. == 190}  {0180e0 == 180} {0190e0 == 190}  {0180.d == 180} {0190.d == 190}  {0180e0d == 180} {0190e0d == 190}  {0180d == 180} {0190d == 190}  {0180.D == 180} {0190.D == 190}  {0180e0D == 180} {0190e0D == 190}  {0180D == 180} {0190D == 190}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-double-16 FAILED


==== 3.10.2-double-17  check for 0 followed by letter  FAILED
==== Contents of test case:

    constant_expression T3102d17 {0e+0d == 0e-0d} {0E1 == 0} {0d == 0D}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.2-double-17 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/literals/integer-literals

==== 3.10.1-valid-1  example decimal int literal  FAILED
==== Contents of test case:

    literal T3101v1 0

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-1 FAILED


==== 3.10.1-valid-2  example octal int literal  FAILED
==== Contents of test case:

    literal T3101v2 0372

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-2 FAILED


==== 3.10.1-valid-3  example hex int literal  FAILED
==== Contents of test case:

    literal T3101v3 0xDadaCafe

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-3 FAILED


==== 3.10.1-valid-4  example hex int literal  FAILED
==== Contents of test case:

    literal T3101v4 0X00FF00FF

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-4 FAILED


==== 3.10.1-valid-5  decimal 0, octal 00, and hex 0x0 are equal  FAILED
==== Contents of test case:

    compile [saveas T3101v5.java {
class T3101v5 {
    void foo(int i) {
	switch (i) {
	    case 0:
	    case ((0 == 00) ? 1 : 0):
	    case ((0 == 0x0) ? 2 : 0):
	    case ((00 == 0x0) ? 3 : 0):
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-5 FAILED


==== 3.10.1-valid-6  2147483648 is valid when negative  FAILED
==== Contents of test case:

    literal T3101v6 -2147483648

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-6 FAILED


==== 3.10.1-valid-7  example long literal, suffix l (ell) == L  FAILED
==== Contents of test case:

    literal T3101v7 0l

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-7 FAILED


==== 3.10.1-valid-8  example long literal  FAILED
==== Contents of test case:

    literal T3101v8 0777L

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-8 FAILED


==== 3.10.1-valid-9  example long literal  FAILED
==== Contents of test case:

    literal T3101v9 0X100000000L

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-9 FAILED


==== 3.10.1-valid-10  example long literal  FAILED
==== Contents of test case:

    literal T3101v10 2147483648L

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-10 FAILED


==== 3.10.1-valid-11  example long literal  FAILED
==== Contents of test case:

    literal T3101v11 0xC0B0L

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-11 FAILED


==== 3.10.1-valid-12  9223372036854775807L is valid when negative  FAILED
==== Contents of test case:

    literal T3101v12 -9223372036854775807L

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-12 FAILED


==== 3.10.1-valid-13  An octal that fits in 32 bits is legal int  FAILED
==== Contents of test case:

    literal T3101v13 0000000000000000000000000001

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-13 FAILED


==== 3.10.1-valid-14  A hex literal that fits in 64 bits is a legal long  FAILED
==== Contents of test case:

    literal T3101v14 0x000012345678CAFEBABEL

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.10.1-valid-14 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/literals/string-literals

==== 3.10.5-invalid-2  A StringCharacter cannot be "  FAILED
==== Contents of test case:

    literal T3105i2 {\u0022}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.5-invalid-2 FAILED


==== 3.10.5-invalid-4  A StringCharacter cannot be \  FAILED
==== Contents of test case:

    literal T3105i4 {\u005c}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.5-invalid-4 FAILED


==== 3.10.5-invalid-8  A LineTerminator is not an InputCharacter  FAILED
==== Contents of test case:

    literal T3105i8 {\u000d}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.5-invalid-8 FAILED


==== 3.10.5-invalid-9  A LineTerminator is not an InputCharacter  FAILED
==== Contents of test case:

    literal T3105i9 {\u000a}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.5-invalid-9 FAILED


==== 3.10.5-invalid-10  A LineTerminator is not an InputCharacter  FAILED
==== Contents of test case:

    literal T3105i10 {\u000d\u000a}

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.10.5-invalid-10 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/unicode
leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/unicode-escapes

==== 3.3-invalid-2  A unicode sequence does not recursively
        form more unicode sequences  FAILED
==== Contents of test case:

    compile [saveas T33i2.java {
class T33i2 {
    String s = "\u005cu005a"; // this sequence is not 'z'
}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.3-invalid-2 FAILED


==== 3.3-valid-1  Multiple u's are allowed in unicode escapes  FAILED
==== Contents of test case:

    compile [saveas T33v1.java {class T33v1 { char c = '\uuuuuuuuuuabcd'; }}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.3-valid-1 FAILED


==== 3.3-valid-2  Unicode sequences are case insensitive  FAILED
==== Contents of test case:

    compile [saveas T33v2.java {
class T33v2 {
    void foo(int i) {
        switch (i) {
            case 0:
            case (('\uABcD' == '\uabCd') ? 1 : 0):
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.3-valid-2 FAILED


==== 3.3-valid-3  Check that \u replacement matches single quoted char  FAILED
==== Contents of test case:

    compile [saveas T33v3.java {
class T33v3 {
    void foo(int i) {
        switch (i) {
            case 0:
            case (('\u0061' == 'a') ? 1 : 0):
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.3-valid-3 FAILED


==== 3.3-valid-4  Check \u replacements in the ASCII range  FAILED
==== Contents of test case:


    set class "
class T33v4 \{
    void foo(int i) \{
        switch (i) \{
            case 0:
"

    set total_cases 0

    # Avoid 10 (\n), 13 (\r), 39 ('), and 92 (\)

    foreach {low high} {0 9
                        11 12
                        14 38
                        40 91
                        93 127} {

        for {set i $low} {$i <= $high} {incr i} {
            incr total_cases
            append class [format "%scase ((%d == '\\u%04x') ? %d : 0): // '%c'\n"  "            "  $i $i $total_cases $i]
        }
    }

    append class "        \}\n    \}\n\}\n"

    compile [saveas T33v4.java $class]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.3-valid-4 FAILED


==== 3.3-valid-5  Unicode \u005c ('\') does not suppress next \  FAILED
==== Contents of test case:

    constant_expression T33v5 {'\u005c\u0030' == 0}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.3-valid-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/lexical-structure/white-space

==== 3.6-invalid-1  Vertical tab (Ctrl-K) '\v' is not whitespace  FAILED
==== Contents of test case:

    whitespace T36i1 \v

---- Result was:
PASS
---- Result should have been:
FAIL
==== 3.6-invalid-1 FAILED


==== 3.6-valid-2  Linefeed (Ctrl-J) '\u000a' is whitespace  FAILED
==== Contents of test case:

    whitespace T36v2 {\u000a}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.6-valid-2 FAILED


==== 3.6-valid-4  Carriage Return (Ctrl-M) '\u000d' is whitespace  FAILED
==== Contents of test case:

    whitespace T36v4 {\u000d}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.6-valid-4 FAILED


==== 3.6-valid-6  CR/LF '\u000d\u000a' is whitespace  FAILED
==== Contents of test case:

    whitespace T36v6 {\u000d\u000a}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.6-valid-6 FAILED


==== 3.6-valid-8  Space '\u0020' is whitespace  FAILED
==== Contents of test case:

    whitespace T36v8 {\u0020}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.6-valid-8 FAILED


==== 3.6-valid-10  Tab (Ctrl-I) '\u0009' is whitespace  FAILED
==== Contents of test case:

    whitespace T36v10 {\u0009}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.6-valid-10 FAILED


==== 3.6-valid-12  Form Feed (Ctrl-L) '\u000c' is whitespace  FAILED
==== Contents of test case:

    whitespace T36v12 {\u000c}

---- Result was:
FAIL
---- Result should have been:
PASS
==== 3.6-valid-12 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/access-control/details-on-protected-access/protected-constructor

==== 6.6.2.2-protected-superctor-3  A protected superconstructor may
        be always be accessed, even by an anonymous class  FAILED
==== Contents of test case:

    compile [saveas T6622ps3a.java {
class T6622ps3a {
    protected T6622ps3a() {}
}
class T6622ps3b {
    Object o = new T6622ps3a() {};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.2-protected-superctor-3 FAILED


==== 6.6.2.2-protected-superctor-4  A protected superconstructor may
        be always be accessed, even by an anonymous class  FAILED
==== Contents of test case:

    compile [saveas p1/T6622ps4a.java {
package p1;
public class T6622ps4a {
    protected T6622ps4a() {}
}
    }] [saveas T6622ps4b.java {
class T6622ps4b {
    Object o = new p1.T6622ps4a() {};
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.2-protected-superctor-4 FAILED


==== 6.6.2.2-protected-superctor-5  A protected superconstructor may
        always be accessed, even by a inner member class  FAILED
==== Contents of test case:

    compile [saveas p1/T6622ps5a.java {
package p1;
public class T6622ps5a {
    protected T6622ps5a() {}
}
    }] [saveas T6622ps5b.java {
class T6622ps5b {
    class C extends p1.T6622ps5a {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.2-protected-superctor-5 FAILED


==== 6.6.2.2-protected-creation-1  A protected constructor may
        be accessed by instance creation in the same package  FAILED
==== Contents of test case:

    compile [saveas T6622pc1a.java {
class T6622pc1a {
    protected T6622pc1a() {}
}
class T6622pc1b {
    Object o = new T6622pc1a();
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.2-protected-creation-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/access-control/details-on-protected-access/protected-member

==== 6.6.2.1-protected-static-field-1  Access to a protected
        static field is legal in the same package  FAILED
==== Contents of test case:

    compile [saveas T6621psf1a.java {
class T6621psf1a {
    protected static int i;
}
class T6621psf1b {
    int j = T6621psf1a.i++;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-field-1 FAILED


==== 6.6.2.1-protected-static-field-3  Access to a protected
        static field is legal outside the package in a subclass, regardless
        of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psf3a.java {
package p1;
public class T6621psf3a {
    protected static int i;
}
    }] [saveas T6621psf3b.java {
class T6621psf3b extends p1.T6621psf3a {
    int j = p1.T6621psf3a.i++;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-field-3 FAILED


==== 6.6.2.1-protected-static-field-4  Access to a protected
        static field is legal outside the package in a subclass, regardless
        of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psf4a.java {
package p1;
public class T6621psf4a {
    protected static int i;
}
    }] [saveas p1/T6621psf4b.java {
package p1;
public class T6621psf4b extends T6621psf4a {}
    }] [saveas T6621psf4c.java {
class T6621psf4c extends p1.T6621psf4a {
    int j = p1.T6621psf4b.i++;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-field-4 FAILED


==== 6.6.2.1-protected-static-field-5  Access to a protected
        static field is legal outside the package in a subclass, regardless
        of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psf5a.java {
package p1;
public class T6621psf5a {
    protected static int i;
}
    }] [saveas p1/T6621psf5c.java {
package p1;
public class T6621psf5c extends p2.T6621psf5b {}
    }] [saveas p2/T6621psf5b.java {
package p2;
public class T6621psf5b extends p1.T6621psf5a {
    int j = p1.T6621psf5c.i++;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-field-5 FAILED


==== 6.6.2.1-protected-static-field-6  Access to a protected
        static field is legal outside the package in the body of a subclass,
        regardless of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psf6a.java {
package p1;
public class T6621psf6a {
    protected static int i;
}
    }] [saveas T6621psf6b.java {
class T6621psf6b extends p1.T6621psf6a {
    Object o = new Object() {
        { p1.T6621psf6a.i++; }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-field-6 FAILED


==== 6.6.2.1-protected-static-field-7  Access to a protected
        static field is legal outside the package in the body of a subclass,
        regardless of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psf7a.java {
package p1;
public class T6621psf7a {
    protected static int i;
}
    }] [saveas p1/T6621psf7b.java {
package p1;
public class T6621psf7b extends T6621psf7a {}
    }] [saveas T6621psf7c.java {
class T6621psf7c extends p1.T6621psf7a {
    Object o = new Object() {
        { p1.T6621psf7b.i++; }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-field-7 FAILED


==== 6.6.2.1-protected-static-field-8  Access to a protected
        static field is legal outside the package in the body of a subclass,
        regardless of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psf8a.java {
package p1;
public class T6621psf8a {
    protected static int i;
}
    }] [saveas p1/T6621psf8c.java {
package p1;
public class T6621psf8c extends p2.T6621psf8b {}
    }] [saveas p2/T6621psf8b.java {
package p2;
public class T6621psf8b extends p1.T6621psf8a {
    Object o = new Object() {
        { p1.T6621psf8c.i++; }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-field-8 FAILED


==== 6.6.2.1-protected-instance-field-1  Access to a protected
        instance field is legal in the same package  FAILED
==== Contents of test case:

    compile [saveas T6621pif1a.java {
class T6621pif1a {
    protected int i;
}
class T6621pif1b {
    int j = new T6621pif1a().i++;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-instance-field-1 FAILED


==== 6.6.2.1-protected-instance-field-5  Access to a protected
        instance field is legal outside the package in a subclass only
        if the qualifier is the type the access occurs in  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pif5a.java {
package p1;
public class T6621pif5a {
    protected static int i;
}
    }] [saveas p1/T6621pif5c.java {
package p1;
public class T6621pif5c extends p2.T6621pif5b {}
    }] [saveas p2/T6621pif5b.java {
package p2;
public class T6621pif5b extends p1.T6621pif5a {
    int j = new p1.T6621pif5c().i++;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-instance-field-5 FAILED


==== 6.6.2.1-protected-instance-field-8  Access to a protected
        instance field is legal outside the package in the body of a subclass
        only if the qualifier is the type the access occurs in  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pif8a.java {
package p1;
public class T6621pif8a {
    protected int i;
}
    }] [saveas p1/T6621pif8c.java {
package p1;
public class T6621pif8c extends p2.T6621pif8b {}
    }] [saveas p2/T6621pif8b.java {
package p2;
public class T6621pif8b extends p1.T6621pif8a {
    Object o = new Object() {
        { new p1.T6621pif8c().i++; }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-instance-field-8 FAILED


==== 6.6.2.1-protected-static-method-1  Access to a protected
        static method is legal in the same package  FAILED
==== Contents of test case:

    compile [saveas T6621psm1a.java {
class T6621psm1a {
    protected static void m() {}
}
class T6621psm1b {
    { T6621psm1a.m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-method-1 FAILED


==== 6.6.2.1-protected-static-method-3  Access to a protected
        static method is legal outside the package in a subclass, regardless
        of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psm3a.java {
package p1;
public class T6621psm3a {
    protected static void m() {}
}
    }] [saveas T6621psm3b.java {
class T6621psm3b extends p1.T6621psm3a {
    { p1.T6621psm3a.m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-method-3 FAILED


==== 6.6.2.1-protected-static-method-4  Access to a protected
        static method is legal outside the package in a subclass, regardless
        of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psm4a.java {
package p1;
public class T6621psm4a {
    protected static void m() {}
}
    }] [saveas p1/T6621psm4b.java {
package p1;
public class T6621psm4b extends T6621psm4a {}
    }] [saveas T6621psm4c.java {
class T6621psm4c extends p1.T6621psm4a {
    { p1.T6621psm4b.m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-method-4 FAILED


==== 6.6.2.1-protected-static-method-5  Access to a protected
        static method is legal outside the package in a subclass, regardless
        of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psm5a.java {
package p1;
public class T6621psm5a {
    protected static void m() {}
}
    }] [saveas p1/T6621psm5c.java {
package p1;
public class T6621psm5c extends p2.T6621psm5b {}
    }] [saveas p2/T6621psm5b.java {
package p2;
public class T6621psm5b extends p1.T6621psm5a {
    { p1.T6621psm5c.m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-method-5 FAILED


==== 6.6.2.1-protected-static-method-6  Access to a protected
        static method is legal outside the package in the body of a subclass,
        regardless of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psm6a.java {
package p1;
public class T6621psm6a {
    protected static void m() {}
}
    }] [saveas T6621psm6b.java {
class T6621psm6b extends p1.T6621psm6a {
    Object o = new Object() {
        { p1.T6621psm6a.m(); }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-method-6 FAILED


==== 6.6.2.1-protected-static-method-7  Access to a protected
        static method is legal outside the package in the body of a subclass,
        regardless of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psm7a.java {
package p1;
public class T6621psm7a {
    protected static void m() {}
}
    }] [saveas p1/T6621psm7b.java {
package p1;
public class T6621psm7b extends T6621psm7a {}
    }] [saveas T6621psm7c.java {
class T6621psm7c extends p1.T6621psm7a {
    Object o = new Object() {
        { p1.T6621psm7b.m(); }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-method-7 FAILED


==== 6.6.2.1-protected-static-method-8  Access to a protected
        static method is legal outside the package in the body of a subclass,
        regardless of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621psm8a.java {
package p1;
public class T6621psm8a {
    protected static void m() {}
}
    }] [saveas p1/T6621psm8c.java {
package p1;
public class T6621psm8c extends p2.T6621psm8b {}
    }] [saveas p2/T6621psm8b.java {
package p2;
public class T6621psm8b extends p1.T6621psm8a {
    Object o = new Object() {
        { p1.T6621psm8c.m(); }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-static-method-8 FAILED


==== 6.6.2.1-protected-instance-method-1  Access to a protected
        instance method is legal in the same package  FAILED
==== Contents of test case:

    compile [saveas T6621pim1a.java {
class T6621pim1a {
    protected void m() {}
}
class T6621pim1b {
    { new T6621pim1a().m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-instance-method-1 FAILED


==== 6.6.2.1-protected-instance-method-5  Access to a protected
        instance method is legal outside the package in a subclass only
        if the qualifier is the type the access occurs in  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pim5a.java {
package p1;
public class T6621pim5a {
    protected static void m() {}
}
    }] [saveas p1/T6621pim5c.java {
package p1;
public class T6621pim5c extends p2.T6621pim5b {}
    }] [saveas p2/T6621pim5b.java {
package p2;
public class T6621pim5b extends p1.T6621pim5a {
    { new p1.T6621pim5c().m(); }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-instance-method-5 FAILED


==== 6.6.2.1-protected-instance-method-8  Access to a protected
        instance method is legal outside the package in the body of a subclass
        only if the qualifier is the type the access occurs in  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pim8a.java {
package p1;
public class T6621pim8a {
    protected void m() {}
}
    }] [saveas p1/T6621pim8c.java {
package p1;
public class T6621pim8c extends p2.T6621pim8b {}
    }] [saveas p2/T6621pim8b.java {
package p2;
public class T6621pim8b extends p1.T6621pim8a {
    Object o = new Object() {
        { new p1.T6621pim8c().m(); }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-instance-method-8 FAILED


==== 6.6.2.1-protected-type-1  Access to a protected
        member type is legal in the same package  FAILED
==== Contents of test case:

    compile [saveas T6621pt1a.java {
class T6621pt1a {
    protected class Inner {};
}
class T6621pt1b {
    Class c = T6621pt1a.Inner.class;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-type-1 FAILED


==== 6.6.2.1-protected-type-3  Access to a protected
        member type is legal outside the package in a subclass, regardless
        of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pt3a.java {
package p1;
public class T6621pt3a {
    protected class Inner {}
}
    }] [saveas T6621pt3b.java {
class T6621pt3b extends p1.T6621pt3a {
    Class c = p1.T6621pt3a.Inner.class;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-type-3 FAILED


==== 6.6.2.1-protected-type-4  Access to a protected
        member type is legal outside the package in a subclass, regardless
        of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pt4a.java {
package p1;
public class T6621pt4a {
    protected class Inner {}
}
    }] [saveas p1/T6621pt4b.java {
package p1;
public class T6621pt4b extends T6621pt4a {}
    }] [saveas T6621pt4c.java {
class T6621pt4c extends p1.T6621pt4a {
    Class c = p1.T6621pt4b.Inner.class;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-type-4 FAILED


==== 6.6.2.1-protected-type-5  Access to a protected
        member type is legal outside the package in a subclass, regardless
        of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pt5a.java {
package p1;
public class T6621pt5a {
    protected class Inner {}
}
    }] [saveas p1/T6621pt5c.java {
package p1;
public class T6621pt5c extends p2.T6621pt5b {}
    }] [saveas p2/T6621pt5b.java {
package p2;
public class T6621pt5b extends p1.T6621pt5a {
    Class c = p1.T6621pt5c.Inner.class;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-type-5 FAILED


==== 6.6.2.1-protected-type-6  Access to a protected
        member type is legal outside the package in the body of a subclass,
        regardless of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pt6a.java {
package p1;
public class T6621pt6a {
    protected class Inner {}
}
    }] [saveas T6621pt6b.java {
class T6621pt6b extends p1.T6621pt6a {
    Object o = new Object() {
        { Class c = p1.T6621pt6a.Inner.class; }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-type-6 FAILED


==== 6.6.2.1-protected-type-7  Access to a protected
        member type is legal outside the package in the body of a subclass,
        regardless of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pt7a.java {
package p1;
public class T6621pt7a {
    protected class Inner {}
}
    }] [saveas p1/T6621pt7b.java {
package p1;
public class T6621pt7b extends T6621pt7a {}
    }] [saveas T6621pt7c.java {
class T6621pt7c extends p1.T6621pt7a {
    Object o = new Object() {
        { Class c = p1.T6621pt7b.Inner.class; }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-type-7 FAILED


==== 6.6.2.1-protected-type-8  Access to a protected
        member type is legal outside the package in the body of a subclass,
        regardless of the type of the qualifier  FAILED
==== Contents of test case:

    compile [saveas p1/T6621pt8a.java {
package p1;
public class T6621pt8a {
    protected class Inner {}
}
    }] [saveas p1/T6621pt8c.java {
package p1;
public class T6621pt8c extends p2.T6621pt8b {}
    }] [saveas p2/T6621pt8b.java {
package p2;
public class T6621pt8b extends p1.T6621pt8a {
    Object o = new Object() {
        { Class c = p1.T6621pt8c.Inner.class; }
    };
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.2.1-protected-type-8 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/access-control/determining-accessibility

==== 6.6.1-1 A class declared public is accessible from outside
        the package FAILED
==== Contents of test case:

    compile [saveas T661_1a.java {
class T661_1a {
    pkg.T661_1b ref;
}
    }] [saveas pkg/T661_1b.java {
package pkg;
public class T661_1b {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-1 FAILED


==== 6.6.1-2 A class declared public is accessible from outside
        the package when the .java source is loaded from the CLASSPATH FAILED
==== Contents of test case:

    saveas pkg/T661_2a.java {
package pkg;
public class T661_2a {}
    }
    compile -classpath . [saveas T661_2b.java {
class T661_2b {
    pkg.T661_2a ref;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-2 FAILED


==== 6.6.1-3 A class declared public is accessible from outside
        the package when the .class file is loaded from the CLASSPATH FAILED
==== Contents of test case:

    set result [compile [saveas pkg/T661_3a.java {
package pkg;
public class T661_3a {}
    }]]
    delete pkg/T661_3a.java
    list $result [compile -classpath . [saveas T661_3b.java {
class T661_3b {
    pkg.T661_3a ref;
}
    }]]

---- Result was:
PASS FAIL
---- Result should have been:
PASS PASS
==== 6.6.1-3 FAILED


==== 6.6.1-4 An interface declared public is accessible from outside
        the package FAILED
==== Contents of test case:

    compile [saveas T661_4a.java {
class T661_4a {
    pkg.T661_4b ref;
}
    }] [saveas pkg/T661_4b.java {
package pkg;
public interface T661_4b {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-4 FAILED


==== 6.6.1-5 An interface declared public is accessible from outside
        the package when the .java source is loaded from the CLASSPATH FAILED
==== Contents of test case:

    saveas pkg/T661_5a.java {
package pkg;
public interface T661_5a {}
    }
    compile -classpath . [saveas T661_5b.java {
class T661_5b {
    pkg.T661_5a ref;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-5 FAILED


==== 6.6.1-6 An interface declared public is accessible from outside
        the package when the .class file is loaded from the CLASSPATH FAILED
==== Contents of test case:

    set result [compile [saveas pkg/T661_6a.java {
package pkg;
public interface T661_6a {}
    }]]
    delete pkg/T661_6a.java
    list $result [compile -classpath . [saveas T661_6b.java {
class T661_6b {
    pkg.T661_6a ref;
}
    }]]

---- Result was:
PASS FAIL
---- Result should have been:
PASS PASS
==== 6.6.1-6 FAILED


==== 6.6.1-7 Access a public class from inside the package FAILED
==== Contents of test case:

    compile [saveas pkg/T661_7a.java {
package pkg;
public class T661_7a {}
    }] [saveas pkg/T661_7b.java {
package pkg;
class T661_7b {
    pkg.T661_7a ref;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-7 FAILED


==== 6.6.1-14 Access a default class from inside the package FAILED
==== Contents of test case:

    compile [saveas pkg/T661_14a.java {
package pkg;
class T661_14a {}
    }] [saveas pkg/T661_14b.java {
package pkg;
class T661_14b {
    pkg.T661_14a ref;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-14 FAILED


==== 6.6.1-15 A class field declared public is accessible from
        outside the package FAILED
==== Contents of test case:

    compile [saveas pkg/T661_15.java {
package pkg;
public class T661_15 {
    public static int FIELD = 0;
}
    }] [saveas T661_15_Test.java {
class T661_15_Test {
    int i = pkg.T661_15.FIELD;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-15 FAILED


==== 6.6.1-16 A class field declared public is accessible from
        outside the package when the .java source is loaded from
        the CLASSPATH  FAILED
==== Contents of test case:

    saveas pkg/T661_16.java {
package pkg;
public class T661_16 {
    public static int FIELD = 0;
}
    }
    compile -classpath . [saveas T661_16_Test.java {
class T661_16_Test {
    int i = pkg.T661_16.FIELD;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-16 FAILED


==== 6.6.1-17 A class field declared public is accessible from
        outside the package when the .class file is loaded from the
        CLASSPATH FAILED
==== Contents of test case:

    set result [compile [saveas pkg/T661_17.java {
package pkg;
public class T661_17 {
    public static int FIELD = 0;
}
    }]]
    delete pkg/T661_17.java
    list $result [compile -classpath . [saveas T661_17_Test.java {
class T661_17_Test {
    int i = pkg.T661_17.FIELD;
}
    }]]

---- Result was:
PASS FAIL
---- Result should have been:
PASS PASS
==== 6.6.1-17 FAILED


==== 6.6.1-array-1  Arrays are exactly as accessible as their
        component type  FAILED
==== Contents of test case:

    compile [saveas T661a1.java {
class T661a1 {
    pkg.Array1[] ref;
}
    }] [saveas pkg/Array1.java {
package pkg;
public class Array1 {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-1 FAILED


==== 6.6.1-array-4  Arrays are exactly as accessible as their
        component type  FAILED
==== Contents of test case:

    compile [saveas T661a4.java {
class T661a4 extends pkg.Array4 {
    pkg.Array4.A[] ref;
}
    }] [saveas pkg/Array4.java {
package pkg;
public class Array4 {
    protected static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-4 FAILED


==== 6.6.1-array-6  Arrays are exactly as accessible as their
        component type  FAILED
==== Contents of test case:

    compile [saveas T661a6.java {
class T661a6 {
    Array6.A[] ref;
}
class Array6 {
    protected static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-6 FAILED


==== 6.6.1-array-7  Arrays are exactly as accessible as their
        component type  FAILED
==== Contents of test case:

    compile [saveas T661a7.java {
class T661a7 {
    Array7.A[] ref;
}
class Array7 {
    static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-7 FAILED


==== 6.6.1-array-9  Arrays are exactly as accessible as their
        component type  FAILED
==== Contents of test case:

    empty_class T661a9 {
        class Inner {
            Array[] ref;
        }
        private static class Array {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-9 FAILED


==== 6.6.1-array-10  The public length field of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a10.java {
class T661a10 {
    int i = pkg.Array10.array.length;
}
    }] [saveas pkg/Array10.java {
package pkg;
public class Array10 {
    public static A[] array;
    public static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-10 FAILED


==== 6.6.1-array-12  The public length field of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a12.java {
class T661a12 extends pkg.Array12 {
    int i = pkg.Array12.array.length;
}
    }] [saveas pkg/Array12.java {
package pkg;
public class Array12 {
    public static A[] array;
    protected static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-12 FAILED


==== 6.6.1-array-15  The public length field of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a15.java {
class T661a15 {
    int i = Array15.array.length;
}
class Array15 {
    static A[] array;
    protected static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-15 FAILED


==== 6.6.1-array-16  The public length field of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a16.java {
class T661a16 {
    int i = Array16.array.length;
}
class Array16 {
    static A[] array;
    static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-16 FAILED


==== 6.6.1-array-18  The public length field of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    empty_class T661a18 {
        class Inner {
            int i = Array18.array.length;
        }
        static class Array18 {
            static A[] array;
            private static class A {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-18 FAILED


==== 6.6.1-array-19  A public member method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a19.java {
class T661a19 {
    Object o = pkg.Array19.array.toString();
}
    }] [saveas pkg/Array19.java {
package pkg;
public class Array19 {
    public static A[] array;
    public static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-19 FAILED


==== 6.6.1-array-21  A public member method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a21.java {
class T661a21 extends pkg.Array21 {
    Object o = pkg.Array21.array.toString();
}
    }] [saveas pkg/Array21.java {
package pkg;
public class Array21 {
    public static A[] array;
    protected static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-21 FAILED


==== 6.6.1-array-24  A public member method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a24.java {
class T661a24 {
    Object o = Array24.array.toString();
}
class Array24 {
    static A[] array;
    protected static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-24 FAILED


==== 6.6.1-array-25  A public member method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a25.java {
class T661a25 {
    Object o = Array25.array.toString();
}
class Array25 {
    static A[] array;
    static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-25 FAILED


==== 6.6.1-array-27  A public member method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    empty_class T661a27 {
        class Inner {
            Object o = Array27.array.toString();
        }
        static class Array27 {
            static A[] array;
            private static class A {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-27 FAILED


==== 6.6.1-array-28  The public clone method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a28.java {
class T661a28 {
    Object o = pkg.Array28.array.clone();
}
    }] [saveas pkg/Array28.java {
package pkg;
public class Array28 {
    public static A[] array;
    public static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-28 FAILED


==== 6.6.1-array-30  The public clone method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a30.java {
class T661a30 extends pkg.Array30 {
    Object o = pkg.Array30.array.clone();
}
    }] [saveas pkg/Array30.java {
package pkg;
public class Array30 {
    public static A[] array;
    protected static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-30 FAILED


==== 6.6.1-array-33  The public clone method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a33.java {
class T661a33 {
    Object o = Array33.array.clone();
}
class Array33 {
    static A[] array;
    protected static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-33 FAILED


==== 6.6.1-array-34  The public clone method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    compile [saveas T661a34.java {
class T661a34 {
    Object o = Array34.array.clone();
}
class Array34 {
    static A[] array;
    static class A {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-34 FAILED


==== 6.6.1-array-36  The public clone method of an array is
        accessible only if the array class is accessible  FAILED
==== Contents of test case:

    empty_class T661a36 {
        class Inner {
            Object o = Array36.array.clone();
        }
        static class Array36 {
            static A[] array;
            private static class A {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.6.1-array-36 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/expression-names/qualified

==== 6.5.6.2-type-3  A qualified expression name which is qualified
        by a type name must name a single accessible field of that type, which
        must be static  FAILED
==== Contents of test case:

    empty_class T6562t3 {
        static int i;
        int j = T6562t3.i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.2-type-3 FAILED


==== 6.5.6.2-type-6  A qualified expression name which is qualified
        by a type name must name a single accessible field of that type, which
        must be static  FAILED
==== Contents of test case:

    compile [saveas p1/T6562t6c.java {
package p1;
class T6562t6a {
    int i;
}
interface T6562t6b {
    int i = 1;
}
public class T6562t6c extends T6562t6a implements T6562t6b {}
    }] [saveas T6562t6d.java {
class T6562t6d {
    int i = p1.T6562t6c.i; // only T6562t6b.i is accessible
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.2-type-6 FAILED


==== 6.5.6.2-type-7  A qualified expression name which is qualified
        by a type name must name a single accessible field of that type, which
        must be static - this tests jikes bug 3044  FAILED
==== Contents of test case:

    compile [saveas T6562t7a.java {
interface T6562t7a {
    int i = T6562t7b.i;
}
    }] [saveas T6562t7b.java {
class T6562t7b {
    final static int i;
    static { i = 1; }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.2-type-7 FAILED


==== 6.5.6.2-type-9  A qualified expression name which is qualified
        by a type name must name a single accessible field of that type, which
        must be static  FAILED
==== Contents of test case:

    compile [saveas p1/T6562t9c.java {
package p1;
class T6562t9a {
    protected int i;
}
interface T6562t9b {
    int i = 1;
}
public class T6562t9c extends T6562t9a implements T6562t9b {}
    }] [saveas T6562t9d.java {
class T6562t9d extends p1.T6562t9c {
    // since a.i is an instance field, and qualifier is not d or subclass,
    // only b.i is accessible
    int i = p1.T6562t9c.i;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.2-type-9 FAILED


==== 6.5.6.2-expression-3  A qualified expression name which is
        qualified by an expression name must name a single accessible field
        of the type of the qualifier, which must be a reference  FAILED
==== Contents of test case:

    empty_class T6562e3 {
        T6562e3 t;
        int i;
        int j = t.i;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.2-expression-3 FAILED


==== 6.5.6.2-expression-6  A qualified expression name which is
        qualified by an expression name must name a single accessible field
        of the type of the qualifier, which must be a reference  FAILED
==== Contents of test case:

    compile [saveas p1/T6562e6c.java {
package p1;
class T6562e6a {
    int i;
}
interface T6562e6b {
    int i = 1;
}
public class T6562e6c extends T6562e6a implements T6562e6b {}
    }] [saveas T6562e6d.java {
class T6562e6d {
    p1.T6562e6c t;
    int i = t.i; // only T6562e6b.i is accessible
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.2-expression-6 FAILED


==== 6.5.6.2-expression-7  A qualified expression name which is
        qualified by an expression name must name a single accessible field
        of the type of the qualifier, which must be a reference  FAILED
==== Contents of test case:

    empty_class T6562e7 {
        Object o[] = {};
        int i = o.length;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.2-expression-7 FAILED


==== 6.5.6.2-expression-8  A qualified expression name may occur
        in a static context, even when it references an instance field  FAILED
==== Contents of test case:

    empty_class T6562e8 {
        int i;
        static T6562e8 t;
        static {
            t.i++;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.2-expression-8 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/expression-names/simple

==== 6.5.6.1-local-2  If a simple expression name appears in the
        scope of a local variable or parameter, it denotes that variable  FAILED
==== Contents of test case:

    empty_main T6561l2 {
        final int i = 1;
        new Object() {
            void foo() {
                Object i;
                i = null; // refers to the local Object i, which shadows int i
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-local-2 FAILED


==== 6.5.6.1-local-3  If a simple expression name appears in the
        scope of a local variable or parameter, it denotes that variable  FAILED
==== Contents of test case:

    empty_main T6561l3 {
        final int i = 1;
        new Object() {
            Object i;
            void foo() {
                i = null; // the field Object i shadows the local int i
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-local-3 FAILED


==== 6.5.6.1-local-4  If a simple expression name appears in the
        scope of a local variable or parameter, it denotes that variable  FAILED
==== Contents of test case:

    empty_class T6561l4 {
        class Super {
            Object i;
        }
        void foo(final int i) {
            new Super() {
                void foo() {
                    // the inherited field Object i shadows the parameter int i
                    i = null;
                }
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-local-4 FAILED


==== 6.5.6.1-field-3  If a simple expression name is not in the
        scope of a local variable or parameter, it must represent a single
        accessible field of the innermost type with the field  FAILED
==== Contents of test case:

    empty_class T6561f3 {
        int i;
        class Inner {
            Object i;
            void foo() {
                i = null; // refers to Object Inner.i, not int T6561f3.i
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-field-3 FAILED


==== 6.5.6.1-field-4  If a simple expression name is not in the
        scope of a local variable or parameter, it must represent a single
        accessible field of the innermost type with the field  FAILED
==== Contents of test case:

    empty_class T6561f4 {
        int i;
        class Super {
            Object i;
        }
        class Sub extends Super {
            void foo() {
                // refers to inherited Object Super.i, not int T6561f3.i
                i = null;
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-field-4 FAILED


==== 6.5.6.1-field-6  If a simple expression name is not in the
        scope of a local variable or parameter, it must represent a single
        accessible field of the innermost type with the field  FAILED
==== Contents of test case:

    compile [saveas p1/T6561f6c.java {
package p1;
class T6561f6a {
    int i;
}
interface T6561f6b {
    int i = 1;
}
public class T6561f6c extends T6561f6a implements T6561f6b {}
    }] [saveas T6561f6d.java {
class T6561f6d extends p1.T6561f6c {
    int j = i; // only T6561f6b.i is inherited
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-field-6 FAILED


==== 6.5.6.1-field-7  If a simple expression name is not in the
        scope of a local variable or parameter, it must represent a single
        accessible field of the innermost type with the field  FAILED
==== Contents of test case:

    empty_class T6561f7 {
	int i;
	class A {
	    class B {
		int j = i;
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-field-7 FAILED


==== 6.5.6.1-field-8  If a simple expression name is not in the
        scope of a local variable or parameter, it must represent a single
        accessible field of the innermost type with the field  FAILED
==== Contents of test case:

    empty_class T6561f8 {
	class Super {
	    int i;
	}
	class Sub extends Super {
	    class Inner {
		{ i++; }
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-field-8 FAILED


==== 6.5.6.1-instance-2  An expression name which resolves to an
        instance field must not occur in a static context  FAILED
==== Contents of test case:

    empty_class T6561i2 {
        int i;
        static int j = i;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 6.5.6.1-instance-2 FAILED


==== 6.5.6.1-instance-3  An expression name which resolves to an
        instance field must not occur in a static context  FAILED
==== Contents of test case:

    empty_class T6561i3 {
        int i;
        static void m() { i++; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 6.5.6.1-instance-3 FAILED


==== 6.5.6.1-explicit-constructor-3  Cannot access instance fields
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T6561ec3 {
	int i;
	class Inner {
	    Inner(int i) {}
	    Inner() {
		this(i); // i is not inherited, and this$0.i is available
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-explicit-constructor-3 FAILED


==== 6.5.6.1-explicit-constructor-4  Cannot access instance fields
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    empty_class T6561ec4 {
	private int i;
	T6561ec4(int i) {}
	class Sub extends T6561ec4 {
	    Sub() {
		super(i); // i is not inherited, so it is the enclosing i
	    }
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-explicit-constructor-4 FAILED


==== 6.5.6.1-explicit-constructor-5  Cannot access instance fields
        from this class within an explicit constructor  FAILED
==== Contents of test case:

    compile [saveas p1/T6561ec5a.java {
package p1;
public class T6561ec5a {
    int i;
    class C extends p2.T6561ec5b {
	C(int j) {}
	C() {
	    // although c is a subclass of a, it does not inherit i, since
	    // its superclass is in a different package
	    this(i);
	}
    }
}
    }] [saveas p2/T6561ec5b.java {
package p2;
public class T6561ec5b extends p1.T6561ec5a {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-explicit-constructor-5 FAILED


==== 6.5.6.1-example-1  JLS example  FAILED
==== Contents of test case:

    empty_class T6561e1 {
        static int v;
        static final int f = 3;
        public static void main(String[] args) {
	    int i;
	    i = 1; // local
	    v = 2; // field
	    System.out.println(i + " " + v + " " + f);
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.6.1-example-1 FAILED


==== 6.5.6.1-example-2  JLS example  FAILED
==== Contents of test case:

    empty_class T6561e2 {
        static final int f = 3;
        public static void main(String[] args) {
	    f = 33; // compile-time error
	}
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 6.5.6.1-example-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/method-names/qualified

==== 6.5.7.2-type-3  A method name qualified by a type name must
        name at least one static method in the type  FAILED
==== Contents of test case:

    empty_class T6572t3 {
        static int m() { return 1; }
        int i = T6572t3.m();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.7.2-type-3 FAILED


==== 6.5.7.2-expression-2  A method name qualified by an expression
        name must name at least one method in the type of the expression FAILED
==== Contents of test case:

    empty_class T6572e2 {
        static int m() { return 1; }
        T6572e2 t;
        int i = t.m();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.7.2-expression-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/method-names/simple

==== 6.5.7.1-simple-2  A simple method name must name a method in
        the current type  FAILED
==== Contents of test case:

    empty_class T6571s2 {
        int foo() { return 1; }
        int i = foo();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.7.1-simple-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/package-names/qualified

==== 6.5.3.2-qualified-3  A qualified package name denotes the member
        subpackage of the qualifying package  FAILED
==== Contents of test case:

    compile [saveas p1/sub/T6532q3a.java {
package p1.sub;
public class T6532q3a {
    public static int i;
}
}] [saveas p1/T6532q3b.java {
package p1;
class T6532q3b {
    int j = p1.sub.T6532q3a.i; // p1.sub was reclassified from ambiguous
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.3.2-qualified-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/package-names/simple

==== 6.5.3.1-simple-2  A simple package name denotes the top-level
        package which is in scope  FAILED
==== Contents of test case:

    compile [saveas p1/T6531s2.java {
package p1;
class T6531s2 {
    static int i;
    void foo() {
        p1.T6531s2.i++; // p1 was reclassified from ambiguous
    }
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.3.1-simple-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/packageortypenames/qualified

==== 6.5.4.2-qualified-1  A package-or-type name is reclassified as
        a type name if the qualifier package name contains that member type  FAILED
==== Contents of test case:

    compile [saveas p1/T6542q1a.java {
package p1;
public class T6542q1a {
    public static class Inner {}
}
}] [saveas T6542q1b.java {
class T6542q1b extends p1.T6542q1a.Inner {}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.4.2-qualified-1 FAILED


==== 6.5.4.2-qualified-2  A package-or-type name is reclassified as
        a type name if the qualifier type name contains that member type  FAILED
==== Contents of test case:

    empty_class T6542q2 {
        class Middle {
            class Inner {}
        }
        T6542q2.Middle.Inner t;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.4.2-qualified-2 FAILED


==== 6.5.4.2-qualified-4  A package-or-type name is reclassified as
        a package name if the qualifier package name does not contain that
        member type  FAILED
==== Contents of test case:

    compile [saveas p1/sub/T6542q4a.java {
package p1.sub;
public class T6542q4a {}
}] [saveas p1/T6542q4b.java {
package p1;
class T6542q4b {
    // p1.sub is classified as a package name
    p1.sub.T6542q4a t;
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.4.2-qualified-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/packageortypenames/simple

==== 6.5.4.1-simple-1  If a simple package-or-type name is in the
        scope of a type, it is reclassified as a type name  FAILED
==== Contents of test case:

    compile [saveas p1/T6541s1a.java {
package p1;
public class T6541s1a {}
    }] [saveas T6541s1b.java {
class T6541s1b {
    static class p1 {
        interface T6541s1a {}
    }
    // p1 is a type, not a package, so p1.T6541s1a is an interface, not a class
    class Sub implements p1.T6541s1a {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.4.1-simple-1 FAILED


==== 6.5.4.1-simple-2  If a simple package-or-type name is in the
        scope of a type, it is reclassified as a type name  FAILED
==== Contents of test case:

    compile [saveas p1/T6541s2a.java {
package p1;
public class T6541s2a {}
    }] [saveas p2/T6541s2b.java {
package p2;
public class T6541s2b {
    public static class p1 {
        public interface T6541s2a {}
    }
}
    }] [saveas T6541s2c.java {
class T6541s1c extends p2.T6541s2b {
    // p1 is an inherited type, not a package, so p1.T6541s2a is an
    class Sub implements p1.T6541s2a {} // interface, not a class
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.4.1-simple-2 FAILED


==== 6.5.4.1-simple-5  If a simple package-or-type name is not in
        the scope of a type, it is reclassified as a package name; an error
        will eventually occur if the package is not observable  FAILED
==== Contents of test case:

    compile [saveas T6541s5.java {
// badpackage is reclassified as a package, but it does not exist
class T6541s5 extends badpackage.Type {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 6.5.4.1-simple-5 FAILED


==== 6.5.4.1-simple-6  If a simple package-or-type name is not in
the scope of a type, it is reclassified as a package name  FAILED
==== Contents of test case:

    compile [saveas p1/T6541s6a.java {
package p1;
public class T6541s6a {
    public static class p2 {
        public class T6541s6b {}
    }
}
    }] [saveas p2/T6541s6b.java {
package p2;
public interface T6541s6b {}
    }] [saveas T6541s6c.java {
// the inherited class p2 is not in scope until the body of class T6541s6c,
// so p2 refers to the package, and p2.T6541s6b is an interface, not a class
class T6541s6c extends p1.T6541s6a implements p2.T6541s6b {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.4.1-simple-6 FAILED


==== 6.5.4.1-simple-7  If a simple package-or-type name is not in
the scope of a type, it is reclassified as a package name  FAILED
==== Contents of test case:

    compile [saveas p1/T6541s7a.java {
package p1;
public interface T6541s7a {
    public class p2 {
        public interface T6541s7b {}
    }
}
    }] [saveas p2/T6541s7b.java {
package p2;
public class T6541s7b {}
    }] [saveas T6541s7c.java {
// the inherited interface p2 is not in scope until the body of class T6541s7c,
// so p2 refers to the package, and p2.T6541s7b is a class, not an interface
class T6541s7c extends p2.T6541s7b implements p1.T6541s7a {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.4.1-simple-7 FAILED


==== 6.5.4.1-simple-10  If a simple package-or-type name is not in
        the scope of a type, it is reclassified as a package name  FAILED
==== Contents of test case:

    compile [saveas p1/T6541s10a.java {
package p1;
public class T6541s10a {
    class p1 {}
}
class T6541s10c extends p2.T6541s10b {
    // class p1 was not inherited, although it is accessible
    // p1 resolves to a package
    p1.T6541s10c p;
}
    }] [saveas p2/T6541s10b.java {
package p2;
public class T6541s10b extends p1.T6541s10a {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.4.1-simple-10 FAILED


==== 6.5.4.1-simple-11  If a simple package-or-type name is not in
        the scope of a type, it is reclassified as a package name  FAILED
==== Contents of test case:

    compile [saveas p1/T6541s11a.java {
package p1;
public class T6541s11a {
    public class p1 {}
}
class T6541s11c extends p2.T6541s11b {
    // class a.p1 was not inherited, although it is accessible
    // p1 resolves to a package
    p1.T6541s11c p;
}
    }] [saveas p2/T6541s11b.java {
package p2;
public class T6541s11b extends p1.T6541s11a {
    private class p1 {} // hides a.p1
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.4.1-simple-11 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/reclassification

==== 6.5.2-simple-1  A simple ambiguous name is reclassified as
        an expression name if it appears in the scope of any variable  FAILED
==== Contents of test case:

    empty_class T652s1 {
        T652s1 t, u;
        static class t {
            static int u;
        }
        void foo() { // t refers to the field, not the class, thus t.u
            t.u = null; // is an Object, not an int
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-simple-1 FAILED


==== 6.5.2-simple-2  A simple ambiguous name is reclassified as
        an expression name if it appears in the scope of any variable  FAILED
==== Contents of test case:

    empty_class T652s2 {
        static class Super {
            Super t, u;
        }
        static class Sub extends Super {
            static class t {
                static int u;
            }
            void foo() { // t refers to the inherited field, not the locally
                t.u = null; // declared class, thus t.u is an Object
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-simple-2 FAILED


==== 6.5.2-simple-3  A simple ambiguous name is reclassified as
        a type name if it appears in the scope of any type, but no variable  FAILED
==== Contents of test case:

    compile [saveas p1/T652s3a.java {
package p1;
public class T652s3a {}
}] [saveas T652s3b.java {
    class T652s3b {
        static class p1 {
            static int T652s3a;
        }
        void foo() {
            // Even though p1.T652s3a is also a type, this is resolved to
            // the int T652s3b.p1.T652s3a.
            p1.T652s3a++;
        }
    }
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-simple-3 FAILED


==== 6.5.2-simple-4  A simple ambiguous name is reclassified as
        a type name if it appears in the scope of any type, but no variable  FAILED
==== Contents of test case:

    compile [saveas p1/T652s4a.java {
package p1;
public class T652s4a {}
}] [saveas p2/T652s4b.java {
package p2;
public class T652s4b {
    public static class p1 {
        public static int T652s4a;
    }
}
}] [saveas T652s4c.java {
    class T652s4c extends p2.T652s4b {
        void foo() {
            // Even though p1.T652s4a is also a type, this is resolved to
            // the inherited int T652s4b.p1.T652s4a.
            p1.T652s4a++;
        }
    }
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-simple-4 FAILED


==== 6.5.2-qualified-1  If the qualifier of an ambiguous name is
        reclassified as a package name, the full name is reclassified as
        a type name if the package exists and has a type by that name  FAILED
==== Contents of test case:

    compile [saveas p1/T652q1.java {
package p1;
class T652q1 {
    static int i;
    void foo() {
        p1.T652q1.i++; // T652q1 is a type in package p1
    }
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-qualified-1 FAILED


==== 6.5.2-qualified-2  If the qualifier of an ambiguous name is
        reclassified as a package name, the full name is reclassified as
        a package name if the package exists but has no type by that name  FAILED
==== Contents of test case:

    empty_class T652q2 {
        // java is a package, but does not contain a type lang, so
        // java.lang is classified as a PackageName
        String s = java.lang.String.valueOf(1);
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-qualified-2 FAILED


==== 6.5.2-qualified-5  If the qualifier of an ambiguous name is
        reclassified as a type name, the full name is reclassified as
        an expression name if the type contains a field by that name  FAILED
==== Contents of test case:

    empty_class T652q5 {
        static T652q5 t, u;
        static class t {
            static int u;
        }
        void foo() { // t refers to the field, not the class, thus T652q5.t.u
            T652q5.t.u = null; // is an Object, not an int
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-qualified-5 FAILED


==== 6.5.2-qualified-6  If the qualifier of an ambiguous name is
        reclassified as a type name, the full name is reclassified as
        an expression name if the type contains a field by that name  FAILED
==== Contents of test case:

    empty_class T652q6 {
        static class Super {
            static Super t, u;
        }
        static class Sub extends Super {
            static class t {
                static int u;
            }
            void foo() { // t refers to the inherited field, not the locally
                Sub.t.u = null; // declared class, thus Sub.t.u is an Object
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-qualified-6 FAILED


==== 6.5.2-qualified-7  If the qualifier of an ambiguous name is
        reclassified as a type name, the full name is reclassified as
        a type name if there is a member type but no field in scope  FAILED
==== Contents of test case:

    empty_class T652q7 {
        static class t {
            static int i;
        }
        int j = T652q7.t.i; // T652q7.t is a type name
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-qualified-7 FAILED


==== 6.5.2-qualified-8  If the qualifier of an ambiguous name is
        reclassified as a type name, the full name is reclassified as
        a type name if there is a member type but no field in scope  FAILED
==== Contents of test case:

    empty_class T652q8 {
        static class Super {
            static class t {
                static int i;
            }
        }
        class Sub extends Super {
            int j = Sub.t.i; // Sub.t is a type name since class t is inherited
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-qualified-8 FAILED


==== 6.5.2-qualified-10  If the qualifier of an ambiguous name is
        reclassified as an expression name, the full name is reclassified as
        an expression name it the type of the qualifier contains a field
        by that name  FAILED
==== Contents of test case:

    empty_class T652q10 {
        T652q10 u;
        int i;
        void foo(T652q10 t) {
            t.u.i++; // u is a field of type T652q10, so t.u is an expression
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-qualified-10 FAILED


==== 6.5.2-qualified-11  If the qualifier of an ambiguous name is
        reclassified as an expression name, the full name is reclassified as
        an expression name it the type of the qualifier contains a field
        by that name  FAILED
==== Contents of test case:

    empty_class T652q11 {
        static class Super {
            Super sup;
        }
        static class Sub extends Super {
            void bar(Sub s) {
                // sup is an inherited field in type Sub, so s.sup is an
                s.sup.toString(); // expression name
            }
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-qualified-11 FAILED


==== 6.5.2-example-1  Example of ambiguous name resolution  FAILED
==== Contents of test case:

    saveas org/rpgpoet/Music.java {
package org.rpgpoet;
import java.util.Random;
public interface Music { Random[] wizards = new Random[4]; }
}
    saveas org/dummy.txt "Here for cleanup purposes"
    saveas bazola/Gabriel.java {
package bazola;
class Gabriel {
    static int n = org.rpgpoet.Music.wizards.length;
    // org is classified as a package name
    // org.rpgpoet is classified as a package name
    // org.rpgpoet.Music is classified as a type name
    // org.rpgpoet.Music.wizards is classified as an expression name
}
}
    compile org/rpgpoet/Music.java bazola/Gabriel.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.2-example-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/syntactic-classification

==== 6.5.1-type-1  A name in an extends clause is a type name, not
        an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t1 {
        int Super;
        class Super {}
        class Sub extends Super {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-1 FAILED


==== 6.5.1-type-2  A name in an implements clause is a type name, not
        an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t2 {
        int Super;
        interface Super {}
        class Sub implements Super {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-2 FAILED


==== 6.5.1-type-3  A name in an interface extends clause is a type
        name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t3 {
        int Super;
        interface Super {}
        interface Sub extends Super {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-3 FAILED


==== 6.5.1-type-4  A name in a field declaration is a type name, not
        an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t4 {
        int T651t4;
        T651t4 t;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-4 FAILED


==== 6.5.1-type-5  A name in the result type of a method is a type
        name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t5 {
        int T651t5;
        T651t5 m() { return null; }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-5 FAILED


==== 6.5.1-type-6  A name in a formal parameter is a type name, not
        an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t6 {
        int T651t6;
        void m(T651t6 T651t6) {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-6 FAILED


==== 6.5.1-type-7  A name in a throws clause is a type name, not
        an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t7 {
        int Type;
        class Type extends Exception {}
        void m() throws Type {}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-7 FAILED


==== 6.5.1-type-8  A name in the type of a local variable is a type
name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_main T651t8 {
        int T651t8;
        T651t8 t;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-8 FAILED


==== 6.5.1-type-9  A name in an exception parameter is a type name,
        not an ambiguous name  FAILED
==== Contents of test case:

    empty_main T651t9 {
        int Type;
        class Type extends Exception {}
        try {
            throw new Type();
        } catch (Type t) {
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-9 FAILED


==== 6.5.1-type-10  A name in a class literal is a type name, not
        an ambiguous name  FAILED
==== Contents of test case:

    empty_main T651t10 {
        int T651t10;
        T651t10.class.toString();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-10 FAILED


==== 6.5.1-type-11  A name qualifying a this expression is a type
        name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t11 {
        void foo() {
            int T651t11;
            T651t11.this.toString();
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-11 FAILED


==== 6.5.1-type-12  A name in an unqualified class instance creation
        expression is a type name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_main T651t12 {
        int T651t12;
        new T651t12();
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-12 FAILED


==== 6.5.1-type-13  A name in an unqualified anonymous class instance
        creation expression is a type name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_main T651t13 {
        int T651t13;
        new T651t13() {};
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-13 FAILED


==== 6.5.1-type-14  A name as the element type of an array creation
        expression is a type name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_main T651t14 {
        int T651t14;
        Object o = new T651t14[1];
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-14 FAILED


==== 6.5.1-type-15  A name qualifying a super field access is a
        type name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t15 {
        class Super {
            int i;
        }
        class Sub extends Super {
            int Sub;
            int j = Sub.super.i;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-15 FAILED


==== 6.5.1-type-16  A name qualifying a super method access is a
        type name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t16 {
        void foo() {
            int T651t16;
            T651t16.super.toString();
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-16 FAILED


==== 6.5.1-type-17  A name in a cast operator is a type name, not
        an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t17 {
        int T651t17;
        void foo(Object o) {
            ((T651t17) o).toString();
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-17 FAILED


==== 6.5.1-type-18  A name following the instanceof operator is a
        type name, not an ambiguous name  FAILED
==== Contents of test case:

    empty_class T651t18 {
        int T651t18;
        void foo(Object o) {
            boolean b = o instanceof T651t18;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-18 FAILED


==== 6.5.1-type-19  A name in a single type import is a type name,
        not an ambiguous name  FAILED
==== Contents of test case:

    compile [saveas p1/T651t19a.java {
package p1;
public class T651t19a {
    public int C;
    public int C() { return 0; }
    public static class C {}
}
    }] [saveas T651t19b.java {
import p1.T651t19a.C;
class T651t19b extends C {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-type-19 FAILED


==== 6.5.1-typeorpackage-1  A typename qualifier is a typeorpackage
        name, not an ambiguous name  FAILED
==== Contents of test case:

    compile [saveas T651tp1a.java {
class T651tp1a {
    int C;
    int C() { return 0; }
    static class C {
	static class Inner {}
    }
}
// T651tp1a.C is a typeorpackage, which gets resolved to a type; and not an int
class T651tp1b extends T651tp1a.C.Inner {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-typeorpackage-1 FAILED


==== 6.5.1-typeorpackage-2  An import-on-demand name is a
        typeorpackage name, not an ambiguous name  FAILED
==== Contents of test case:

    compile [saveas p1/T651tp2a.java {
package p1;
public class T651tp2a {
    public int C;
    public int C() { return 0; }
    public static class C {
	public static class Inner {}
    }
}
    }] [saveas T651tp2b.java {
// p1.T651tp2a.C is a typeorpackage, which gets resolved to a type
import p1.T651tp2a.C.*;
class T651tp1b extends Inner {}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.1-typeorpackage-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/type-names/qualified

==== 6.5.5.2-package-1  A qualified type name must refer to a
        single accessible member type of the qualifying package, or an error
        occurs  FAILED
==== Contents of test case:

    compile [saveas p1/T6552p1.java {
package p1;
class T6552p1 {
    p1.T6552p1 t;
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.2-package-1 FAILED


==== 6.5.5.2-package-3  A qualified type name must refer to a
        single accessible member type of the qualifying package, or an error
        occurs  FAILED
==== Contents of test case:

    compile [saveas p1/T6552p3a.java {
package p1;
class T6552p3a {
    public T6552p3a() {}
}
    }] [saveas T6552p3b.java {
// p1.T6552p3a is not accessible
class T6552p3b extends p1.T6552p3a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 6.5.5.2-package-3 FAILED


==== 6.5.5.2-type-1  A qualified type name must refer to a single
        accessible member type of the qualifying type, or an error occurs  FAILED
==== Contents of test case:

    empty_class T6552t1 {
        class Inner {}
        T6552t1.Inner t;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.2-type-1 FAILED


==== 6.5.5.2-type-5  A qualified type name must refer to a single
        accessible member type of the qualifying type, or an error occurs  FAILED
==== Contents of test case:

    compile [saveas p1/T6552t5c.java {
package p1;
class T6552t5a {
    class C {}
}
interface T6552t5b {
    class C {}
}
public class T6552t5c extends T6552t5a implements T6552t5b {}
    }] [saveas T6552t5d.java {
class T6552t5d extends p1.T6552t5c {
    // only the accessible T6552t5b.C is inherited
    T6552t5d.C t;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.2-type-5 FAILED


==== 6.5.5.2-type-6  A qualified type name must refer to a single
        accessible member type of the qualifying type, or an error occurs  FAILED
==== Contents of test case:

    compile [saveas p1/T6552t6c.java {
package p1;
class T6552t6a {
    class C {}
}
interface T6552t6b {
    class C {}
}
public class T6552t6c extends T6552t6a implements T6552t6b {}
    }] [saveas T6552t6d.java {
class T6552t6d {
    // a.C is not accessible, so this is b.C
    p1.T6552t6c.C t;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.2-type-6 FAILED


==== 6.5.5.2-type-7  A qualified type name must refer to a single
        accessible member type of the qualifying type, or an error occurs  FAILED
==== Contents of test case:

    compile [saveas p1/T6552t7c.java {
package p1;
class T6552t7a {
    protected class C {}
}
interface T6552t7b {
    class C {}
}
public class T6552t7c extends T6552t7a implements T6552t7b {}
    }] [saveas T6552t7d.java {
class T6552t7d {
    // a.C is not accessible, so this is b.C
    p1.T6552t7c.C t;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.2-type-7 FAILED


==== 6.5.5.2-type-8  A qualified type name must refer to a single
        accessible member type of the qualifying type, or an error occurs  FAILED
==== Contents of test case:

    compile [saveas p1/T6552t8a.java {
package p1;
public class T6552t8a {
    protected class C {}
}
    }] [saveas p1/T6552t8b.java {
package p1;
public interface T6552t8b {
    class C {}
}
    }] [saveas T6552t8c.java {
class T6552t8c extends p1.T6552t8a implements p1.T6552t8b {}
class T6552t8d {
    // a.C is not accessible, so this is b.C
    T6552t8c.C t;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.2-type-8 FAILED


==== 6.5.5.2-example-1  Example in the specs  FAILED
==== Contents of test case:

    empty_class T6552e1 {
        public static void main(String[] args) {
            java.util.Date date
                = new java.util.Date(System.currentTimeMillis());
            // Just like Sun to deprecate their example!
            System.out.println(date/*.toLocaleString()*/);
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.2-example-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/meaning-of-a-name/type-names/simple

==== 6.5.5.1-nested-2  A simple type name favors a visible local
        class declaration over member types  FAILED
==== Contents of test case:

    empty_class T6551n2 {
        interface C {}
        void foo() {
            class C {}
            // C refers to the local class, not member interface
            class Sub extends C {}
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-2 FAILED


==== 6.5.5.1-nested-3  A simple type name favors a visible local
        class declaration over member types  FAILED
==== Contents of test case:

    empty_main T6551n3 {
        class C { // local
            static final int i = 1;
        }
        new Object() {
            class C { // member
                static final int i = 2;
            }
            void foo(int j) {
                switch (j) {
                    case 0:
                    case 1:
                    // C refers to the member class, since the local is
                    // shadowed, hence C.i is 2
                    case C.i:
                }
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-3 FAILED


==== 6.5.5.1-nested-4  A simple type name favors a visible local
        class declaration over member types  FAILED
==== Contents of test case:

    empty_class T6551n4 {
        static class Super {
            interface C {} // member
        }
        void foo() {
            class C {} // local
            new Super() {
                // C refers to the inherited member class, since the
                // local is shadowed, hence C is an interface
                class Sub implements C {}
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-4 FAILED


==== 6.5.5.1-nested-5  A simple type name favors a visible local
        class declaration over member types  FAILED
==== Contents of test case:

    empty_main T6551n5 {
        class C {
            static final int i = 1;
        }
        new Object() {
            void foo(int j) {
                class C {
                    static final int i = 2;
                }
                switch (j) {
                    case 0:
                    case 1:
                    // C refers to the innermost local class, since it shadows
                    // the other version, hence C.i is 2
                    case C.i:
                }
            }
        };
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-5 FAILED


==== 6.5.5.1-nested-6  A simple type name must not have ambiguity in
       referring to visible member types  FAILED
==== Contents of test case:

    empty_class T6551n6 {
        interface C {}
        void foo() {
            new Object() {
                class C {}
                // C refers to the innermost class C, not the outer interface
                class Sub extends C {}
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-6 FAILED


==== 6.5.5.1-nested-7  A simple type name must not have ambiguity in
       referring to visible member types  FAILED
==== Contents of test case:

    empty_class T6551n7 {
        interface C {}
        static class Super {
            class C {}
        }
        void foo() {
            new Super() {
                // C refers to the inherited class Super.C, not the shadowed
                // interface T6551n7.C
                class Sub extends C {}
            };
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-7 FAILED


==== 6.5.5.1-nested-9  A simple type name must not have ambiguity in
       referring to visible member types  FAILED
==== Contents of test case:

    compile [saveas p1/T6551n9c.java {
package p1;
class T6551n9a {
    class C {}
}
interface T6551n9b {
    class C {}
}
public class T6551n9c extends T6551n9a implements T6551n9b {}
    }] [saveas T6551n9d.java {
class T6551n9d extends p1.T6551n9c {
    C c; // T6551n9a.C is not accessible, so this is T6551n9b.C
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-9 FAILED


==== 6.5.5.1-nested-10  A simple type name favors a visible
        member type over top-level and single-type imports in the same
        compilation unit  FAILED
==== Contents of test case:

    compile [saveas p1/T6551n10a.java {
package p1;
public interface T6551n10a {}
    }] [saveas T6551n10b.java {
import p1.T6551n10a;
class T6551n10b {
    class T6551n10a {}
    // T6551n10a refers to the member class, not the imported interface
    class Sub extends T6551n10a {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-10 FAILED


==== 6.5.5.1-nested-11  A simple type name favors a visible
        member type over top-level and single-type imports in the same
        compilation unit  FAILED
==== Contents of test case:

    compile [saveas T6551n11a.java {
interface T6551n11a {}
class T6551n11b {
    class T6551n11a {}
    // T6551n11a refers to the member class, not the top-level interface
    class Sub extends T6551n11a {}
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-11 FAILED


==== 6.5.5.1-nested-14  A simple type name favors a visible
        member type over top-level and single-type imports in the same
        compilation unit  FAILED
==== Contents of test case:

    ok_pass_or_warn [compile [saveas p1/T6551n14a.java {
package p1;
public class T6551n14a {
    public interface T6551n14b {}
}
    }] [saveas T6551n14b.java {
final class T6551n14b extends p1.T6551n14a implements p1.T6551n14a.T6551n14b {
    void foo() {
        // the inherited member type shadows the current enclosing type
        new T6551n14b() {};
    }
}
    }]]

---- Result was:
FAIL
---- Result should have been:
OK
==== 6.5.5.1-nested-14 FAILED


==== 6.5.5.1-nested-15  A simple type name favors a visible
        member type over top-level and single-type imports in the same
        compilation unit  FAILED
==== Contents of test case:

    compile [saveas p1/T6551n15a.java {
package p1;
public class T6551n15a {
    public interface T6551n15b {}
}
    }] [saveas p2/T6551n15b.java {
package p2;
public final class T6551n15b {}
    }] [saveas T6551n15c.java {
import p2.T6551n15b;
class T6551n15c extends p1.T6551n15a {
    void foo() {
        // resolves to the inherited interface, not the imported class
        new T6551n15b() {};
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-15 FAILED


==== 6.5.5.1-nested-17  A simple type name favors a visible
        member type over top-level types in the same compilation unit  FAILED
==== Contents of test case:

    ok_pass_or_warn [empty_class T6551n17 {
	static class A {
	    interface B {}
	}
	final static class B extends A {
	    { new B() {}; } // the inherited T6551n16.A.B shadows T6551n16.B

	}
    }]

---- Result was:
FAIL
---- Result should have been:
OK
==== 6.5.5.1-nested-17 FAILED


==== 6.5.5.1-nested-19  A simple type name favors a visible
        member type over top-level types in the same compilation unit  FAILED
==== Contents of test case:

    ok_pass_or_warn [compile [saveas T6551n19a.java {
class T6551n19a {
    interface T6551n19b {}
}
final class T6551n19b extends T6551n19a {
    // the inherited T6551n19a.T6551n19b shadows T6551n19b
    { new T6551n19b() {}; }
}
    }]]

---- Result was:
FAIL
---- Result should have been:
OK
==== 6.5.5.1-nested-19 FAILED


==== 6.5.5.1-nested-20  A simple type name favors a visible
        member type over top-level types in the same compilation unit  FAILED
==== Contents of test case:

    ok_pass_or_warn [compile [saveas T6551n20a.java {
interface T6551n20a {
    class T6551n20b {}
}
interface T6551n20b extends T6551n20a {
    // the inherited T6551n20a.T6551n20b shadows T6551n20b
    T6551n20b t = new T6551n20b();
}
    }]]

---- Result was:
FAIL
---- Result should have been:
OK
==== 6.5.5.1-nested-20 FAILED


==== 6.5.5.1-nested-22  A simple type name favors a visible
        member type over top-level types in the same compilation unit  FAILED
==== Contents of test case:

    empty_class T6551n22 {
	class Inner extends T6551n22 {
	    // inherited Inner.Inner (etc.) is same as current Inner
	    Inner i;
	    Inner.Inner j = i;
	    Inner.Inner.Inner k = j;
	}
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-22 FAILED


==== 6.5.5.1-nested-23  A simple type name must not have ambiguity in
       referring to visible member types  FAILED
==== Contents of test case:

    compile [saveas p1/T6551n23c.java {
package p1;
class T6551n23a {
    class C {
	public static final int i = 1;
    }
}
interface T6551n23b {
    class C {
	public static final int i = 2;
    }
}
public class T6551n23c extends T6551n23a implements T6551n23b {}
    }] [saveas T6551n23d.java {
class T6551n23d extends p1.T6551n23c {
    void m(int i) {
	switch (i) {
	    case 1:
	    case C.i: // a.C.i is not accessible, so this is b.C.i == 2
	}
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-nested-23 FAILED


==== 6.5.5.1-import-2  A simple type name favors a single-type
        import over import-on-demand  FAILED
==== Contents of test case:

    compile [saveas p1/T6551i2a.java {
package p1;
public class T6551i2a {
    public static final int i = 2;
}
    }] [saveas p2/T6551i2a.java {
package p2;
public class T6551i2a {
    public static final int i = 1;
}
    }] [saveas T6551i2b.java {
import p1.T6551i2a;
import p2.*;
class T6551i2b {
    void foo(int j) {
        switch (j) {
            case 0:
            case 1:
            // T6551i2a refers to the specific p1 import, not the on-demand p2,
            // so T6551i2a.i resolves to 2
            case T6551i2a.i:
        }
    }
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.5.5.1-import-2 FAILED


==== 6.5.5.1-import-4  A simple type name may not resolve to
        ambiguous types from import-on-demand  FAILED
==== Contents of test case:

    compile [saveas p1/T6551i4a.java {
package p1;
public class T6551i4a {}
    }] [saveas p2/T6551i4a.java {
package p2;
public class T6551i4a {}
    }] [saveas T6551i4b.java {
import p1.*;
import p2.*;
// T6551i4a is ambiguous between p1 and p2
class T6551i4b extends T6551i4a {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 6.5.5.1-import-4 FAILED


==== 6.5.5.1-superclass-1  From jikes bug 3404, the compiler should
        gracefully handle a superclass simple name that is an invalid (or
        missing) type from the CLASSPATH  FAILED
==== Contents of test case:

    compile [saveas T6551s1c.java {
class T6551s1a {}
class T6551s1b extends T6551s1a {}
class T6551s1c extends T6551s1b {}
    }]
    delete T6551s1a.class
    compile -classpath . [saveas T6551s1c.java {
class T6551s1c extends T6551s1b {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 6.5.5.1-superclass-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/members-and-inheritance/members-of-a-class-type

==== 6.4.2-2  a qualified reference is not ambiguous  FAILED
==== Contents of test case:

    saveas QualifiedInterfaceMember.java  {
interface One {
  int VAL = 1;
}

interface Two {
  int VAL = 2;
}

class QualifiedInterfaceMember implements One, Two {
  int i = One.VAL;
}
}

    compile QualifiedInterfaceMember.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.4.2-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/members-and-inheritance/members-of-a-package

==== 6.4.1-class-member-1  A class declared in a package
        is a member of that package  FAILED
==== Contents of test case:


    saveas pkg/T641cm1.java {
package pkg;
public class T641cm1 {}
}

    saveas T641cm1_Test.java {
public class T641cm1_Test {
    Object o = new pkg.T641cm1();
}
}

    compile -classpath . pkg/T641cm1.java T641cm1_Test.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.4.1-class-member-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/members-and-inheritance/members-of-an-array-type

==== 6.4.4-1  An array object should be able to access methods
        defined in the java.lang.Object class  FAILED
==== Contents of test case:

    compile [saveas ArrayIsObject.java  {
public class ArrayIsObject {
    public static void main(String[] args) {
        int len = args.length;
        System.out.println(len);
        Class c = args.getClass();
        System.out.println(c);
        String s = args.toString();
        System.out.println(s);
    }
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.4.4-1 FAILED


==== 6.4.4-2  the length member of an array is an int  FAILED
==== Contents of test case:

    compile [saveas ArrayLengthIsInt.java  {
public class ArrayLengthIsInt {
    void foo() {
        int[] foo = new int[3];
        int val = foo.length;
    }
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.4.4-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/members-and-inheritance/members-of-an-interface-type

==== 6.4.3-1  interface member reference can not be ambiguous  FAILED
==== Contents of test case:

    saveas AmbiguousExtendedInterfaceMember.java  {
interface One {
  int VAL = 1;
}

interface Two {
  int VAL = 2;
}

interface AmbiguousExtendedInterfaceMember extends One, Two {
  int i = VAL;
}
}

    compile AmbiguousExtendedInterfaceMember.java

---- Result was:
PASS
---- Result should have been:
FAIL
==== 6.4.3-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/names-and-identifiers

==== 6.2-example-1  First example from the specs  FAILED
==== Contents of test case:

    compile [saveas T62e1.java {
// T62e1 is identifier
class T62e1 {
    // main, args are identifier; String is name
    public static void main(String[] args) {
        // c is identifier; Class, System.out.getClass are names
        Class c = System.out.getClass();
        // length is identifier; System.out.println, c are names
        System.out.println(c.toString().length() + 
        // first length is identifier; args, args.length are names
            args[0].length() + args.length);
    }
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.2-example-1 FAILED


==== 6.2-example-2  Second example from the specs: labels are
        independent from other uses of names  FAILED
==== Contents of test case:

    empty_class T62e2 {
        char[] value;
        int offset, count;
        int indexOf(T62e2 str, int fromIndex) {
            char[] v1 = value, v2 = str.value;
            int max = offset + (count - str.count);
            int start = offset + ((fromIndex < 0) ? 0 : fromIndex);
        i:
            for (int i = start; i <= max; i++) {
                int n = str.count, j = i, k = str.offset;
                while (n-- != 0) {
                    if (v1[j++] != v2[k++])
                        continue i;
                }
                return i - offset;
            }
            return -1;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.2-example-2 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/names/scope-of-a-declaration

==== 6.3-2  forward reference to a field outside of an initializer is legal  FAILED
==== Contents of test case:

    compile [saveas LegalForwardReference.java  {
public class LegalForwardReference {
  void foo() { a = 1; }
  int a;
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.3-2 FAILED


==== 6.3-3  use of a class before it is defined is legal  FAILED
==== Contents of test case:

    compile [saveas UseOfTypeBeforeDeclaration.java  {
public class UseOfTypeBeforeDeclaration {
  Object o = new UseOfTypeBeforeDeclaration_Type();
}

class UseOfTypeBeforeDeclaration_Type {
  Object o = new UseOfTypeBeforeDeclaration();
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.3-3 FAILED


==== 6.3-4  the scope of a class includes every known member of
        the package, so we should be able to make a forward ref  FAILED
==== Contents of test case:

    saveas GlobalOne.java  {
public class GlobalOne {
    void foo() {
	Object o = new GlobalTwo();
    }
}
}

    saveas GlobalTwo.java  {
public class GlobalTwo {
    void foo() {
	Object o = new GlobalOne();
    }
}
}

    compile GlobalOne.java GlobalTwo.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== 6.3-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/packages/compilation-units
leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/packages/import-declarations/automatic-imports
leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/packages/import-declarations/single-type-import-declaration

==== 7.5.1-1  Doing an import of a class that does not exist
        should fail FAILED
==== Contents of test case:

    compile [saveas T7511.java {
import foo.a_class_that_does_not_exist;
public class T7511 {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.5.1-1 FAILED


==== 7.5.1-2  Cannot import from the unnamed package  FAILED
==== Contents of test case:

    compile [saveas ClassInDefaultPackage.java {
public class T7512a {}
}] [saveas foo/T7512b.java {
package foo;
import T7512a;
public class T7512b extends T7512a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.5.1-2 FAILED


==== 7.5.1-3  Importing a non-public class should fail FAILED
==== Contents of test case:

    compile [saveas foo/T7513a.java {
package foo;
class T7513a {}
}] [saveas T7513b.java {
import foo.T7513a;
class T7513b extends T7513a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.5.1-3 FAILED


==== 7.5.1-accessible-1  A single-type import must name an
        accessible type  FAILED
==== Contents of test case:

    compile [saveas p1/T751a1a.java {
package p1;
class T751a1a {
    interface Inner {}
}
}] [saveas p1/T751a1b.java {
package p1;
import p1.T751a1a.Inner;
class T751a1b implements Inner {}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 7.5.1-accessible-1 FAILED


==== 7.5.1-duplicate-2  Importing two classes of the same name is
        illegal  FAILED
==== Contents of test case:

    compile [saveas p1/T751d2a.java {
package p1;
public class T751d2a {}
}] [saveas p2/T751d2a.java {
package p2;
public class T751d2a {}
}] [saveas T751d2b.java {
import p1.T751d2a;
import p2.T751d2a;
class T751d2b extends T751d2a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.5.1-duplicate-2 FAILED


==== 7.5.1-duplicate-3  It is an error to single-type import a
        distinct type with the same name as one in the compilation unit  FAILED
==== Contents of test case:

    compile [saveas p1/T751d3a.java {
package p1;
public class T751d3a {}
}] [saveas T751d3a.java {
import p1.T751d3a;
class T751d3a {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.5.1-duplicate-3 FAILED


==== 7.5.1-subpackage-1  Single-type import cannot import
        subpackages  FAILED
==== Contents of test case:

    compile [saveas T751sub1.java {
import java.util;
class T751sub1 extends util.Random {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.5.1-subpackage-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/packages/import-declarations/strange-example

==== 7.5.4-example-1  Example in the JLS: imported names are not
        in scope in later imports  FAILED
==== Contents of test case:

    compile [saveas Vector/Mosquito.java {
package Vector;
public class Mosquito {}
}] [saveas T754e1.java {
import java.util.Vector;
import Vector.Mosquito;
class T754e1 {
    public static void main(String[] args) {
        System.out.println(new Vector().getClass());
        System.out.println(new Mosquito().getClass());
    }
}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 7.5.4-example-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/packages/import-declarations/type-import-on-demand-declaration

==== 7.5.2-accessible-1  It is an error for an import statement to
        mention an inaccessible type or package  FAILED
==== Contents of test case:

    compile [saveas T752a1.java {
import non_existant_package.*;
class T752a1 {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.5.2-accessible-1 FAILED


==== 7.5.2-accessible-3  It is an error for an import statement to
        mention an inaccessible type or package  FAILED
==== Contents of test case:

    compile [saveas p1/T752a3a.java {
package p1;
class T752a3a {
    interface Inner {}
}
}] [saveas p1/T752a3b.java {
package p1;
import p1.T752a3a.*;
class T752a3b implements Inner {}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 7.5.2-accessible-3 FAILED


==== 7.5.2-duplicate-3  It is legal to import a type declared in
        the same compilation unit  FAILED
==== Contents of test case:

    compile [saveas p1/T752d3a.java {
package p1;
import p1.T752d3a.*;
class T752d3a {
    static class Inner {}
}
class T752d3b extends Inner {}
}]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 7.5.2-duplicate-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/packages/package-declarations/named-packages
leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/packages/package-declarations/unnamed-packages
leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/packages/package-members

==== 7.1-unnamed-1  The unnamed package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas T71u1.java {
class T71u1 {}
class T71u1 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-unnamed-1 FAILED


==== 7.1-unnamed-2  The unnamed package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas T71u2.java {
class T71u2 {}
interface T71u2 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-unnamed-2 FAILED


==== 7.1-unnamed-3  The unnamed package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas T71u3.java {
interface T71u3 {}
interface T71u3 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-unnamed-3 FAILED


==== 7.1-unnamed-4  The unnamed package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas T71u4a.java {
class T71u4a {}
    }] [saveas T71u4b.java {
class T71u4a {} // duplicate of the one in file T71u4a
class T71u4b {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-unnamed-4 FAILED


==== 7.1-named-1  A named package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas p1/T71n1.java {
package p1;
class T71n1 {}
class T71n1 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-named-1 FAILED


==== 7.1-named-2  A named package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas p1/T71n2.java {
package p1;
class T71n2 {}
interface T71n2 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-named-2 FAILED


==== 7.1-named-3  A named package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas p1/T71n3.java {
package p1;
interface T71n3 {}
interface T71n3 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-named-3 FAILED


==== 7.1-named-4  A named package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas p1/T71n4a.java {
package p1;
class T71n4a {}
    }] [saveas p1/T71n4b.java {
package p1;
class T71n4a {} // duplicate of the one in file T71n4a
class T71n4b {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-named-4 FAILED


==== 7.1-named-5  A named package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas p1/T71n5/T71n5a.java {
package p1.T71n5;
class T71n5a {}
    }] [saveas p1/T71n5.java {
package p1;
class T71n5 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-named-5 FAILED


==== 7.1-named-6  A named package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas p1/T71n6/T71n6a.java {
package p1.T71n6;
class T71n6a {}
    }] [saveas p1/T71n6.java {
package p1;
interface T71n6 {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-named-6 FAILED


==== 7.1-named-7  A named package may not contain duplicate
        members  FAILED
==== Contents of test case:

    compile [saveas java/lang.java {
package java;
class lang {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.1-named-7 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/packages/top-level-type-declarations

==== 7.6-scope-1  TypeDeclaration within a package must
        have a unique Identifier  FAILED
==== Contents of test case:

    compile [saveas T76scope1.java {
class Point {}
interface Point {}
}]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.6-scope-1 FAILED


==== 7.6-scope-2  TypeDeclaration cannot conflict with
        single-type-imports  FAILED
==== Contents of test case:

    compile [saveas T76scope2.java {
import java.util.Vector;
class Vector {}
    }]

---- Result was:
PASS
---- Result should have been:
FAIL
==== 7.6-scope-2 FAILED


==== 7.6-scope-4  TypeDeclaration may have forward
        references within a compilation unit  FAILED
==== Contents of test case:

    compile [saveas T76scope4.java {
class first {
    second a;
}
class second {
    first b;
}
    }]

---- Result was:
FAIL
---- Result should have been:
PASS
==== 7.6-scope-4 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jls/types-values-and-variables/variables/final-variables

==== 4.5.4-instance-1  final variable must be definitely assigned  FAILED
==== Contents of test case:

    empty_class T454i1 {
        final int val;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 4.5.4-instance-1 FAILED


==== 4.5.4-instance-2  final variable must be definitely assigned  FAILED
==== Contents of test case:

    empty_class T454i2 {
        final int val = 0;
        final String str = null;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 4.5.4-instance-2 FAILED


==== 4.5.4-instance-4  final variable must be definitely assigned  FAILED
==== Contents of test case:

    empty_class T454i4 {
        final int val;
        final String str;

        {
            val = 0;
            str = null;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 4.5.4-instance-4 FAILED


==== 4.5.4-instance-9  blank final variable must be assigned in
        every constructor  FAILED
==== Contents of test case:

    empty_class T454i9 {
        final int val;
        final String str;

        T454i9() { val = 0; }
        T454i9(int foo) { str = null; }
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 4.5.4-instance-9 FAILED


==== 4.5.4-static-1  final variable must be definitely assigned  FAILED
==== Contents of test case:

    empty_class T454s1 {
        static final int val;
        static final String str;
    }

---- Result was:
PASS
---- Result should have been:
FAIL
==== 4.5.4-static-1 FAILED


==== 4.5.4-static-2  final variable must be definitely assigned  FAILED
==== Contents of test case:

    empty_class T454s2 {
        static final int val = 0;
        static final String str = null;
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 4.5.4-static-2 FAILED


==== 4.5.4-static-3  final variable must be definitely assigned  FAILED
==== Contents of test case:

    empty_class T454s3 {
        static final int val;
        static final String str;
        static {
            val = 0;
            str = null;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 4.5.4-static-3 FAILED


==== 4.5.4-reference-1  a final variable can reference an Object, the
        reference can not change but the object being referenced can change  FAILED
==== Contents of test case:

    empty_class T454r1 {
        final StringBuffer sbuf = new StringBuffer();
        
        void append() {
            sbuf.append("nuggy");
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 4.5.4-reference-1 FAILED


==== 4.5.4-reference-2  a final variable can reference an array, the
        elements of the array can be modified  FAILED
==== Contents of test case:

    empty_class T454r2 {
        final Object[] objarr = {new Object(), new Object()};

        void swap() {
            Object tmp = objarr[0];
            objarr[0] = objarr[1];
            objarr[1] = tmp;
        }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 4.5.4-reference-2 FAILED


==== 4.5.4-9  blank final variable must be assigned in every 
        constructor  FAILED
==== Contents of test case:

    empty_class T4549 {
        final int val;
        T4549() { val = 0; }
        T4549(int foo) { this(); }
    }

---- Result was:
FAIL
---- Result should have been:
PASS
==== 4.5.4-9 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jvms/class-file-format/attributes/deprecated-attribute

==== 4.7.10-jvms-class-1  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc1a.java {
// most compact form, need not start line
import java.lang.*;/**@deprecated*/ class T4710jc1a {}
    }]
    delete T4710jc1a.java
    list [compile -classpath . -deprecation [saveas T4710jc1b.java {
class T4710jc1b extends T4710jc1a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-1 FAILED


==== 4.7.10-jvms-class-2  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc2a.java {
// one-liner form
/** @deprecated */
class T4710jc2a {}
    }]
    delete T4710jc2a.java
    list [compile -classpath . -deprecation [saveas T4710jc2b.java {
class T4710jc2b extends T4710jc2a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-2 FAILED


==== 4.7.10-jvms-class-3  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc3a.java {
/**
 * all leading whitespace and * are ignored
 	* ** 	 @deprecated
 **/
class T4710jc3a {}
    }]
    delete T4710jc3a.java
    list [compile -classpath . -deprecation [saveas T4710jc3b.java {
class T4710jc3b extends T4710jc3a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-3 FAILED


==== 4.7.10-jvms-class-4  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc4a.java {
/**
 leading * is optional
 @deprecated
 */
class T4710jc4a {}
    }]
    delete T4710jc4a.java
    list [compile -classpath . -deprecation [saveas T4710jc4b.java {
class T4710jc4b extends T4710jc4a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-4 FAILED


==== 4.7.10-jvms-class-5  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc5a.java {
/**
 @deprecated
 */ /* */ // additional comments don't matter
class T4710jc5a {}
    }]
    delete T4710jc5a.java
    list [compile -classpath . -deprecation [saveas T4710jc5b.java {
class T4710jc5b extends T4710jc5a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-5 FAILED


==== 4.7.10-jvms-class-6  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc6a.java {
/**
 @deprecated
 */
; // oops, must be directly before class
class T4710jc6a {}
    }]
    delete T4710jc6a.java
    list [compile -classpath . -deprecation [saveas T4710jc6b.java {
class T4710jc6b extends T4710jc6a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-class-6 FAILED


==== 4.7.10-jvms-class-7  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc7a.java {
/**
 @deprecated
 */
import java.lang.*; // oops, must be directly before class
class T4710jc7a {}
    }]
    delete T4710jc7a.java
    list [compile -classpath . -deprecation [saveas T4710jc7b.java {
class T4710jc7b extends T4710jc7a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-class-7 FAILED


==== 4.7.10-jvms-class-8  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc8a.java {
public
/** oops - too late
 * @deprecated */
       class T4710jc8a {}
    }]
    delete T4710jc8a.java
    list [compile -classpath . -deprecation [saveas T4710jc8b.java {
class T4710jc8b extends T4710jc8a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-class-8 FAILED


==== 4.7.10-jvms-class-9  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc9a.java {
/** characters besides whitespace or * before @ deactivate tag @deprecated */
class T4710jc9a {}
    }]
    delete T4710jc9a.java
    list [compile -classpath . -deprecation [saveas T4710jc9b.java {
class T4710jc9b extends T4710jc9a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-class-9 FAILED


==== 4.7.10-jvms-class-10  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc10a.java {
/** @deprecated */
class T4710jc10a {}
    }]
    delete T4710jc10a.java
    list [compile -classpath . -deprecation [saveas T4710jc10b.java {
class T4710jc10b {
    Object o = new T4710jc10a();
}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-10 FAILED


==== 4.7.10-jvms-class-11  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc11a.java {
/** @deprecated */
class T4710jc11a {
    static int i;
}
    }]
    delete T4710jc11a.java
    list [compile -classpath . -deprecation [saveas T4710jc11b.java {
class T4710jc11b {
    int i = T4710jc11a.i;
}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-11 FAILED


==== 4.7.10-jvms-class-12  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc12a.java {
/** @deprecated */
class T4710jc12a {}
    }]
    delete T4710jc12a.java
    list [compile -classpath . -deprecation [saveas T4710jc12b.java {
class T4710jc12b {
    Object o;
    boolean b = o instanceof T4710jc12a;
}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-12 FAILED


==== 4.7.10-jvms-class-13  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc13a.java {
/** @deprecated */
class T4710jc13a {}
    }]
    delete T4710jc13a.java
    list [compile -classpath . -deprecation [saveas T4710jc13b.java {
class T4710jc13b {
    T4710jc13a t;
}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-13 FAILED


==== 4.7.10-jvms-class-14  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc14a.java {
/** @deprecated */
class T4710jc14a {}
    }]
    delete T4710jc14a.java
    list [compile -classpath . -deprecation [saveas T4710jc14b.java {
class T4710jc14b {
    T4710jc14a[] t;
}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-14 FAILED


==== 4.7.10-jvms-class-15  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc15a.java {
/** @deprecated */
/** Only the most recent doc comment applies */
class T4710jc15a {}
    }]
    delete T4710jc15a.java
    list [compile -classpath . -deprecation [saveas T4710jc15b.java {
class T4710jc15b extends T4710jc15a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-class-15 FAILED


==== 4.7.10-jvms-class-16  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc16a.java {
/** @deprecated */
/**/ // degenerate doc comment; only most recent one applies
class T4710jc16a {}
    }]
    delete T4710jc16a.java
    list [compile -classpath . -deprecation [saveas T4710jc16b.java {
class T4710jc16b extends T4710jc16a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-class-16 FAILED


==== 4.7.10-jvms-class-17  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas p1/T4710jc17a.java {
package p1;
/** @deprecated */
public class T4710jc17a {}
    }]
    delete p1/T4710jc17a.java
    list [compile -classpath . -deprecation [saveas T4710jc17b.java {
import p1.T4710jc17a;
class T4710jc17b {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-17 FAILED


==== 4.7.10-jvms-class-18  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas p1/T4710jc18a.java {
package p1;
/** @deprecated */
public class T4710jc18a {
    public static class Inner {}
}
    }]
    delete p1/T4710jc18a.java
    list [compile -classpath . -deprecation [saveas T4710jc18b.java {
import p1.T4710jc18a.*;
class T4710jc18b extends Inner {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-18 FAILED


==== 4.7.10-jvms-class-19  Test that a class can be deprecated  FAILED
==== Contents of test case:

    compile [saveas T4710jc19a.java {
public class T4710jc19a {
    /** @deprecated */
    public static class Inner {}
}
    }]
    delete T4710jc19a.java
    list [compile -classpath . -deprecation [saveas T4710jc19b.java {
class T4710jc19b extends T4710jc19a.Inner {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-class-19 FAILED


==== 4.7.10-jvms-method-1  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm1a {
	// most compact form, need not start line
	int i;/**@deprecated*/ static int m() { return 1; }
    }
    delete T4710jm1a.java
    list [compile -classpath . -deprecation [saveas T4710jm1b.java {
class T4710jm1b { int i = T4710jm1a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-method-1 FAILED


==== 4.7.10-jvms-method-2  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm2a {
	// one-liner form
	/** @deprecated */
	static int m() { return 1; }
    }
    delete T4710jm2a.java
    list [compile -classpath . -deprecation [saveas T4710jm2b.java {
class T4710jm2b { int i = T4710jm2a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-method-2 FAILED


==== 4.7.10-jvms-method-3  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm3a {
	/**
          * all leading whitespace and * are ignored
	 	* ** 	 @deprecated
	 **/
	static int m() { return 1; }
    }
    delete T4710jm3a.java
    list [compile -classpath . -deprecation [saveas T4710jm3b.java {
class T4710jm3b { int i = T4710jm3a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-method-3 FAILED


==== 4.7.10-jvms-method-4  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm4a {
	/**
	  leading * is optional
	  @deprecated
	 */
	static int m() { return 1; }
    }
    delete T4710jm4a.java
    list [compile -classpath . -deprecation [saveas T4710jm4b.java {
class T4710jm4b { int i = T4710jm4a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-method-4 FAILED


==== 4.7.10-jvms-method-5  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm5a {
	/**
	  @deprecated
	 */ /* */ // additional comments don't matter
	static int m() { return 1; }
    }
    delete T4710jm5a.java
    list [compile -classpath . -deprecation [saveas T4710jm5b.java {
class T4710jm5b { int i = T4710jm5a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-method-5 FAILED


==== 4.7.10-jvms-method-6  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm6a {
	/**
	  @deprecated
	 */
	; // oops, must be directly before method
	static int m() { return 1; }
    }
    delete T4710jm6a.java
    list [compile -classpath . -deprecation [saveas T4710jm6b.java {
class T4710jm6b { int i = T4710jm6a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-method-6 FAILED


==== 4.7.10-jvms-method-7  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm7a {
	/**
	  @deprecated
	 */
	int j; // oops, must be directly before method
	static int m() { return 1; }
    }
    delete T4710jm7a.java
    list [compile -classpath . -deprecation [saveas T4710jm7b.java {
class T4710jm7b { int i = T4710jm7a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-method-7 FAILED


==== 4.7.10-jvms-method-8  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm8a {
	public
	  /** oops - too late
	   * @deprecated */
               static int m() { return 1; }
    }
    delete T4710jm8a.java
    list [compile -classpath . -deprecation [saveas T4710jm8b.java {
class T4710jm8b { int i = T4710jm8a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-method-8 FAILED


==== 4.7.10-jvms-method-9  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm9a {
/** characters besides whitespace or * before @ deactivate tag @deprecated */
        static int m() { return 1; }
    }
    delete T4710jm9a.java
    list [compile -classpath . -deprecation [saveas T4710jm9b.java {
class T4710jm9b { int i = T4710jm9a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-method-9 FAILED


==== 4.7.10-jvms-method-10  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm10a {
	/** @deprecated */
        static int m() { return 1; }
    }
    delete T4710jm10a.java
    list [compile -classpath . -deprecation [saveas T4710jm10b.java {
class T4710jm10b extends T4710jm10a { int j = m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-method-10 FAILED


==== 4.7.10-jvms-method-11  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm11a {
	/** @deprecated */
	/** Only the most recent doc comment applies */
	static int m() { return 1; }
    }
    delete T4710jm11a.java
    list [compile -classpath . -deprecation [saveas T4710jm11b.java {
class T4710jm11b { int i = T4710jm11a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-method-11 FAILED


==== 4.7.10-jvms-method-12  Test that a method can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jm12a {
	/** @deprecated */
	/**/ // degenerate doc comment; only most recent one applies
	static int m() { return 1; }
    }
    delete T4710jm12a.java
    list [compile -classpath . -deprecation [saveas T4710jm12b.java {
class T4710jm12b { int i = T4710jm12a.m(); }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-method-12 FAILED


==== 4.7.10-jvms-constructor-1  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon1a {
	// most compact form, need not start line
	int i;/**@deprecated*/ T4710jcon1a() {}
    }
    delete T4710jcon1a.java
    list [compile -classpath . -deprecation [saveas T4710jcon1b.java {
class T4710jcon1b { { new T4710jcon1a(); } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-constructor-1 FAILED


==== 4.7.10-jvms-constructor-2  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon2a {
	// one-liner form
	/** @deprecated */
	T4710jcon2a() {}
    }
    delete T4710jcon2a.java
    list [compile -classpath . -deprecation [saveas T4710jcon2b.java {
class T4710jcon2b { { new T4710jcon2a(); } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-constructor-2 FAILED


==== 4.7.10-jvms-constructor-3  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon3a {
	/**
          * all leading whitespace and * are ignored
	 	* ** 	 @deprecated
	 **/
	T4710jcon3a() {}
    }
    delete T4710jcon3a.java
    list [compile -classpath . -deprecation [saveas T4710jcon3b.java {
class T4710jcon3b { { new T4710jcon3a(); } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-constructor-3 FAILED


==== 4.7.10-jvms-constructor-4  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon4a {
	/**
	  leading * is optional
	  @deprecated
	 */
	T4710jcon4a() {}
    }
    delete T4710jcon4a.java
    list [compile -classpath . -deprecation [saveas T4710jcon4b.java {
class T4710jcon4b { { new T4710jcon4a(); } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-constructor-4 FAILED


==== 4.7.10-jvms-constructor-5  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon5a {
	/**
	  @deprecated
	 */ /* */ // additional comments don't matter
	T4710jcon5a() {}
    }
    delete T4710jcon5a.java
    list [compile -classpath . -deprecation [saveas T4710jcon5b.java {
class T4710jcon5b { { new T4710jcon5a(); } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-constructor-5 FAILED


==== 4.7.10-jvms-constructor-6  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon6a {
	/**
	  @deprecated
	 */
	; // oops, must be directly before constructor
	T4710jcon6a() {}
    }
    delete T4710jcon6a.java
    list [compile -classpath . -deprecation [saveas T4710jcon6b.java {
class T4710jcon6b { { new T4710jcon6a(); } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-constructor-6 FAILED


==== 4.7.10-jvms-constructor-7  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon7a {
	/**
	  @deprecated
	 */
	int i; // oops, must be directly before constructor
	T4710jcon7a() {}
    }
    delete T4710jcon7a.java
    list [compile -classpath . -deprecation [saveas T4710jcon7b.java {
class T4710jcon7b { { new T4710jcon7a(); } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-constructor-7 FAILED


==== 4.7.10-jvms-constructor-8  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon8a {
	public
	  /** oops - too late
	   * @deprecated */
               T4710jcon8a() {}
    }
    delete T4710jcon8a.java
    list [compile -classpath . -deprecation [saveas T4710jcon8b.java {
class T4710jcon8b { { new T4710jcon8a(); } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-constructor-8 FAILED


==== 4.7.10-jvms-constructor-9  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon9a {
/** characters besides whitespace or * before @ deactivate tag @deprecated */
        T4710jcon9a() {}
    }
    delete T4710jcon9a.java
    list [compile -classpath . -deprecation [saveas T4710jcon9b.java {
class T4710jcon9b { { new T4710jcon9a(); } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-constructor-9 FAILED


==== 4.7.10-jvms-constructor-10  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon10a {
	/** @deprecated */
        T4710jcon10a() {}
    }
    delete T4710jcon10a.java
    list [compile -classpath . -deprecation [saveas T4710jcon10b.java {
class T4710jcon10b extends T4710jcon10a {}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-constructor-10 FAILED


==== 4.7.10-jvms-constructor-11  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon11a {
	/** @deprecated */
        T4710jcon11a() {}
    }
    delete T4710jcon11a.java
    list [compile -classpath . -deprecation [saveas T4710jcon11b.java {
class T4710jcon11b extends T4710jcon11a {
    T4710jcon11b() {
	super();
    }
}
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-constructor-11 FAILED


==== 4.7.10-jvms-constructor-12  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon12a {
	/** @deprecated */
        T4710jcon12a() {}
    }
    delete T4710jcon12a.java
    list [compile -classpath . -deprecation [saveas T4710jcon12b.java {
class T4710jcon12b { { new T4710jcon12a() {}; } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-constructor-12 FAILED


==== 4.7.10-jvms-constructor-13  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon13a {
	/** @deprecated */
	/** Only the most recent doc comment applies */
	T4710jcon13a() {}
    }
    delete T4710jcon13a.java
    list [compile -classpath . -deprecation [saveas T4710jcon13b.java {
class T4710jcon13b { { new T4710jcon13a() {}; } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-constructor-13 FAILED


==== 4.7.10-jvms-constructor-14  Test that a constructor can be
        deprecated  FAILED
==== Contents of test case:

    empty_class T4710jcon14a {
	/** @deprecated */
	/**/ // degenerate doc comment; only most recent one applies
	T4710jcon14a() {}
    }
    delete T4710jcon14a.java
    list [compile -classpath . -deprecation [saveas T4710jcon14b.java {
class T4710jcon14b { { new T4710jcon14a() {}; } }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-constructor-14 FAILED


==== 4.7.10-jvms-field-1  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf1a {
	// most compact form, need not start line
	int j;/**@deprecated*/ static int i;
    }
    delete T4710jf1a.java
    list [compile -classpath . -deprecation [saveas T4710jf1b.java {
class T4710jf1b { int i = T4710jf1a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-field-1 FAILED


==== 4.7.10-jvms-field-2  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf2a {
	// one-liner form
	/** @deprecated */
	static int i;
    }
    delete T4710jf2a.java
    list [compile -classpath . -deprecation [saveas T4710jf2b.java {
class T4710jf2b { int i = T4710jf2a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-field-2 FAILED


==== 4.7.10-jvms-field-3  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf3a {
	/**
          * all leading whitespace and * are ignored
	 	* ** 	 @deprecated
	 **/
	static int i;
    }
    delete T4710jf3a.java
    list [compile -classpath . -deprecation [saveas T4710jf3b.java {
class T4710jf3b { int i = T4710jf3a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-field-3 FAILED


==== 4.7.10-jvms-field-4  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf4a {
	/**
	  leading * is optional
	  @deprecated
	 */
	static int i;
    }
    delete T4710jf4a.java
    list [compile -classpath . -deprecation [saveas T4710jf4b.java {
class T4710jf4b { int i = T4710jf4a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-field-4 FAILED


==== 4.7.10-jvms-field-5  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf5a {
	/**
	  @deprecated
	 */ /* */ // additional comments don't matter
	static int i;
    }
    delete T4710jf5a.java
    list [compile -classpath . -deprecation [saveas T4710jf5b.java {
class T4710jf5b { int i = T4710jf5a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-field-5 FAILED


==== 4.7.10-jvms-field-6  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf6a {
	/**
	  @deprecated
	 */
	; // oops, must be directly before field
	static int i;
    }
    delete T4710jf6a.java
    list [compile -classpath . -deprecation [saveas T4710jf6b.java {
class T4710jf6b { int i = T4710jf6a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-field-6 FAILED


==== 4.7.10-jvms-field-7  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf7a {
	/**
	  @deprecated
	 */
	int j; // oops, must be directly before field
	static int i;
    }
    delete T4710jf7a.java
    list [compile -classpath . -deprecation [saveas T4710jf7b.java {
class T4710jf7b { int i = T4710jf7a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-field-7 FAILED


==== 4.7.10-jvms-field-8  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf8a {
	public
	  /** oops - too late
	   * @deprecated */
               static int i;
    }
    delete T4710jf8a.java
    list [compile -classpath . -deprecation [saveas T4710jf8b.java {
class T4710jf8b { int i = T4710jf8a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-field-8 FAILED


==== 4.7.10-jvms-field-9  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf9a {
/** characters besides whitespace or * before @ deactivate tag @deprecated */
        static int i;
    }
    delete T4710jf9a.java
    list [compile -classpath . -deprecation [saveas T4710jf9b.java {
class T4710jf9b { int i = T4710jf9a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-field-9 FAILED


==== 4.7.10-jvms-field-10  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf10a {
	/** @deprecated */
        static int i;
    }
    delete T4710jf10a.java
    list [compile -classpath . -deprecation [saveas T4710jf10b.java {
class T4710jf10b extends T4710jf10a { int j = i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-field-10 FAILED


==== 4.7.10-jvms-field-11  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf11a {
	/**
	 * multiple fields in the same declaration are all deprecated
	 * @deprecated
	 */
        static int j, i;
    }
    delete T4710jf11a.java
    list [compile -classpath . -deprecation [saveas T4710jf11b.java {
class T4710jf11b { int i = T4710jf11a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-field-11 FAILED


==== 4.7.10-jvms-field-12  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf12a {
	/** @deprecated */
	/** Only the most recent doc comment applies */
	static int i;
    }
    delete T4710jf12a.java
    list [compile -classpath . -deprecation [saveas T4710jf12b.java {
class T4710jf12b { int i = T4710jf12a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-field-12 FAILED


==== 4.7.10-jvms-field-13  Test that a field can be deprecated  FAILED
==== Contents of test case:

    empty_class T4710jf13a {
	/** @deprecated */
	/**/ // degenerate doc comment; only most recent one applies
	static int i;
    }
    delete T4710jf13a.java
    list [compile -classpath . -deprecation [saveas T4710jf13b.java {
class T4710jf13b { int i = T4710jf13a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-field-13 FAILED


==== 4.7.10-jvms-lex-1  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl1a {
	/** / before tag disables tag (except starting /**)
	/* @deprecated */
	static int i;
	/**
	/** @deprecated */
	static int j;
    }
    delete T4710j1a.java
    list [compile -classpath . -deprecation [saveas T4710jl1b.java {
class T4710jl1b { int i = T4710jl1a.i + T4710jl1a.j; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-lex-1 FAILED


==== 4.7.10-jvms-lex-2  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl2a {
	/** whitespace excludes < \u0009, > \u000d
	* @deprecated\u0008 */
	static int i;
	/** @deprecated\u000e */
	static int j;
    }
    delete T4710j2a.java
    list [compile -classpath . -deprecation [saveas T4710jl2b.java {
class T4710jl2b { int i = T4710jl2a.i + T4710jl2a.j; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-lex-2 FAILED


==== 4.7.10-jvms-lex-3  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl3a {
	/** whitespace excludes < \u001c, > \u0020
	* @deprecated\u001b */
	static int i;
	/** @deprecated\u0021 */
	static int j;
    }
    delete T4710j3a.java
    list [compile -classpath . -deprecation [saveas T4710jl3b.java {
class T4710jl3b { int i = T4710jl3a.i + T4710jl3a.j; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-lex-3 FAILED


==== 4.7.10-jvms-lex-4  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl4a {
	/** whitespace excludes \u00a0, \u2007, \u202f
	* @deprecated\u00a0 */
	static int i;
	/** @deprecated\u2007 */
	static int j;
	/** @deprecated\u202f */
	static int k;
    }
    delete T4710j4a.java
    list [compile -classpath . -deprecation [saveas T4710jl4b.java {
class T4710jl4b { int i = T4710jl4a.i + T4710jl4a.j + T4710jl4a.k; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-lex-4 FAILED


==== 4.7.10-jvms-lex-5  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl5a {
	/** only Character.isSpace() may appear before @ sign
	* \u000b @deprecated */
	static int i;
	/** \u001e @deprecated */
	static int j;
	/** \u2028 @deprecated */
	static int k;
    }
    delete T4710j5a.java
    list [compile -classpath . -deprecation [saveas T4710jl5b.java {
class T4710jl5b { int i = T4710jl5a.i + T4710jl5a.j + T4710jl5a.k; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
PASS 0
==== 4.7.10-jvms-lex-5 FAILED


==== 4.7.10-jvms-lex-6  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl6a {
	/** whitespace includes \v, even though the rest of the source doesn't
	* @deprecated\u000b */
	static int i;
    }
    delete T4710j6a.java
    list [compile -classpath . -deprecation [saveas T4710jl6b.java {
class T4710jl6b { int i = T4710jl6a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-lex-6 FAILED


==== 4.7.10-jvms-lex-7  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl7a {
	/** whitespace includes the ASCII separators (\u001c - \u001f),
	* even though the rest of the source doesn't
	* @deprecated\u001d */
	static int i;
    }
    delete T4710j7a.java
    list [compile -classpath . -deprecation [saveas T4710jl7b.java {
class T4710jl7b { int i = T4710jl7a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-lex-7 FAILED


==== 4.7.10-jvms-lex-8  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl8a {
	/** whitespace includes Unicode space characters,
	* even though the rest of the source doesn't
	* @deprecated\u2002 */
	static int i;
    }
    delete T4710j8a.java
    list [compile -classpath . -deprecation [saveas T4710jl8b.java {
class T4710jl8b { int i = T4710jl8a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-lex-8 FAILED


==== 4.7.10-jvms-lex-9  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl9a {
	/** whitespace includes Unicode line separator characters,
	* even though the rest of the source doesn't
	* @deprecated\u2028 */
	static int i;
    }
    delete T4710j9a.java
    list [compile -classpath . -deprecation [saveas T4710jl9b.java {
class T4710jl9b { int i = T4710jl9a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-lex-9 FAILED


==== 4.7.10-jvms-lex-10  Test lexing of deprecated  FAILED
==== Contents of test case:

    empty_class T4710jl10a {
	/** whitespace includes Unicode paragraph separator characters,
	* even though the rest of the source doesn't
	* @deprecated\u2029 */
	static int i;
    }
    delete T4710j10a.java
    list [compile -classpath . -deprecation [saveas T4710jl10b.java {
class T4710jl10b { int i = T4710jl10a.i; }
    }]] [match_err_or_warn {*depreca*}]

==== Test generated error:
can't read "JAVAC_DEPRECATION_FLAG": no such variable
---- Result should have been:
WARN 1
==== 4.7.10-jvms-lex-10 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/jvms/class-file-format/limitations
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/argument-expansion

==== non-jls-argument-expansion-2  The @ symbol indicates that
        the compiler should read file names from the given file FAILED
==== Contents of test case:

    saveas list2 "C1.java"
    compile @list2

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-2 FAILED


==== non-jls-argument-expansion-3  EOL chars in @ file
        argument  FAILED
==== Contents of test case:

    saveas list3 "C1.java\nC2.java"
    compile @list3

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-3 FAILED


==== non-jls-argument-expansion-4  EOL chars in @ file
        argument  FAILED
==== Contents of test case:

    saveas list4 "C1.java\r\nC2.java"
    compile @list4

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-4 FAILED


==== non-jls-argument-expansion-5  EOL chars in @ file
        argument  FAILED
==== Contents of test case:

    saveas list5 "C1.java\rC2.java"
    compile @list5

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-5 FAILED


==== non-jls-argument-expansion-6  Empty line in @ file
        argument  FAILED
==== Contents of test case:

    saveas list6 "C1.java\n\rC2.java"
    compile @list6

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-6 FAILED


==== non-jls-argument-expansion-7  Spaces in a @ argument file
        should not cause the compile to fail  FAILED
==== Contents of test case:

    saveas list7 "C1.java \n C2.java "
    compile @list7

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-7 FAILED


==== non-jls-argument-expansion-8  Tabs in a @ argument file
        should not cause the compile to fail  FAILED
==== Contents of test case:

    saveas list8 "\tC1.java\nC2.java\t"
    compile @list8

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-8 FAILED


==== non-jls-argument-expansion-9  Tabs and spaces in a @ argument
        file should not cause the compile to fail  FAILED
==== Contents of test case:

    saveas list9 "\t C1.java \n C2.java \t"
    compile @list9

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-9 FAILED


==== non-jls-argument-expansion-10  Tabs and spaces in empty line
        of a @ argument should be ignored  FAILED
==== Contents of test case:

    saveas list10 "C1.java\n\t \nC2.java"
    compile @list10

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-10 FAILED


==== non-jls-argument-expansion-11  Expand empty @ argument.
        this will terminate without doing anything for JDK 1.3
        compatibility  FAILED
==== Contents of test case:

    saveas list11 ""
    compile @list11

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-11 FAILED


==== non-jls-argument-expansion-12  Expand empty @ argument
     FAILED
==== Contents of test case:

    saveas list12 "\n\n"
    compile @list12

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-12 FAILED


==== non-jls-argument-expansion-13  Expand empty @ argument
     FAILED
==== Contents of test case:

    saveas list13 ""
    compile C1.java @list13

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-13 FAILED


==== non-jls-argument-expansion-tokens-2  A file name
    surrounded by double quotes is valid  FAILED
==== Contents of test case:

    saveas tokens2 "\"C1.java\""
    compile @tokens2

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-tokens-2 FAILED


==== non-jls-argument-expansion-tokens-4  A file name
    the contains a space surrounded by double quotes is valid  FAILED
==== Contents of test case:

    saveas "With Space.java" {class WithSpace {}}
    saveas tokens4 "\"With Space.java\""
    compile @tokens4

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-tokens-4 FAILED


==== non-jls-argument-expansion-tokens-5  A file name
    the contains a space surrounded by double quotes is valid  FAILED
==== Contents of test case:

    saveas "Dir With Space/Space2.java" {class Space2 {}}
    saveas tokens5 "\"Dir With Space/Space2.java\""
    compile @tokens5

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-argument-expansion-tokens-5 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/assert/definite-assignment
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/assert/syntax
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/encoding
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/jsr-201/autoboxing-autounboxing
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/jsr-201/enhanced-for-loops
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/jsr-201/enumerations
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/jsr-201/static-import
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/jsr-201/varargs
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/random-crashers
leonevers/Dropbox/Coding/forest/test/jacks/tests/non-jls/zip

==== non-jls-zip-1 Load .class file from zip without comment FAILED
==== Contents of test case:

    saveas ZipNoComment.java {
class ZipNoComment {
  pkg.Example inst;
}
}
    compile -classpath ZipNoComment.zip ZipNoComment.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-zip-1 FAILED


==== non-jls-zip-2 Load .class file from zip with comment FAILED
==== Contents of test case:

    saveas ZipComment.java {
class ZipComment {
  pkg.Example inst;
}
}
    compile -classpath ZipComment.zip ZipComment.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-zip-2 FAILED


==== non-jls-zip-3 Load .class file from a compressed zip FAILED
==== Contents of test case:

    saveas ZipCompressed.java {
class ZipCompressed {
  pkg.Example inst;
}
}
    compile -classpath ZipCompressed.zip ZipCompressed.java

---- Result was:
FAIL
---- Result should have been:
PASS
==== non-jls-zip-3 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/arrays/array-initializers
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/binary-compatibility/evolution-of-classes/final-fields-and-constants
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/binary-compatibility/form-of-binary
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/break-statement
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/do-statement
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/for-statement
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/if-statement/if-then-else-statement
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/if-statement/if-then-statement
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/local-class-declarations
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/switch-statement
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/synchronized-statement
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/try-statement/try-catch
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/try-statement/try-catch-finally
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/blocks-and-statements/while-statement
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/classes/class-declaration/inner-classes-and-enclosing-instances
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/classes/constructor-declarations/constructor-access
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/classes/constructor-declarations/constructor-body

==== 8.8.5.1-runtime-super-1  A null qualifier must throw
  a NullPointerException early  FAILED
==== Contents of test case:

    compile_and_run [saveas T8851rs1.java {
class T8851rs1 {
  public static int value = 0;
  class Inner {
    Inner(int i) {}
  }
  static class Der extends Inner {
    Der(T8851rs1 outer, int i) {
      outer.super(value = ++i);
    }
  }
  public static void main(String[] args) {
    try {
      new Der(null, 5);
    } catch (NullPointerException npe) {
      if (value == 0)
	System.out.print("OK");
      else
	System.out.print("should throw NullPointerException before argument evaluation");
      return;
    }
    System.out.print("should throw NullPointerException");
  }
}
    }]

---- Result was:
COMPILE FAIL
---- Result should have been:
OK
==== 8.8.5.1-runtime-super-1 FAILED

leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/classes/constructor-declarations/constructor-modifiers
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/classes/constructor-declarations/default-constructor
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/classes/field-declarations
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/classes/method-declarations/inheritance-overriding-and-hiding
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/definite-assignment/anonymous-classes
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/execution/creation-of-new-class-instances
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/execution/initialization-of-classes-and-interfaces/detailed-initialization-procedure
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/execution/initialization-of-classes-and-interfaces/when-initialization-occurs
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/additive-operators/string-conversion
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/array-access-expressions/examples
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/assignment-operators/compound-assignment-operators
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/assignment-operators/simple-assignment-operator
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/class-instance-creation
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/class-instance-creation/run-time-evaluation
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/conditional-and-operator
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/conditional-operator
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/conditional-or-operator
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/constant-expression
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/equality-operators/reference-equality
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/field-access-expressions/accessing-superclass-members-using-super
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/field-access-expressions/using-a-primary
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/method-invocation-expressions/chosen-method-appropriate
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/method-invocation-expressions/determine-class-or-interface
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/method-invocation-expressions/runtime-evaluation/compute-target-reference
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/postfix-expressions
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/primary-expressions/qualified-this
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/relational-operators/type-comparison-operator-instanceof
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/expressions/unary-operators
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/lexical-structure/literals/character-literals
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/lexical-structure/literals/floating-point-literals
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/lexical-structure/literals/integer-literals
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jls/lexical-structure/literals/string-literals
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/jvms/class-file-format/limitations
leonevers/Dropbox/Coding/forest/test/jacks/tests/runtime/non-jls/assert
forest:	Total	5011	Passed	2362	Skipped	422	Failed	2227
Number of tests skipped for each constraint:
	121	assert
	2	assert && runtime
	7	encoding
	1	gcj
	43	jikes
	70	jsr201
	24	jvm
	1	pc
	145	runtime
	8	staticImport
