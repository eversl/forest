
; Syntax definition for java lang spec 1.0

(import "core.patterns.forest")
(import "core.rules.forest")

(import "standard.patterns.forest")
(import "standard.rules.forest")

; start parsing here
(rule start (+ whitespace CompilationUnit endoffile))

(rule endoffile (! anychar))

(rule CompilationUnit (+ (? (> PackageDeclaration)) (* (> LanguageDeclaration)) (* (> ImportDeclaration)) (* (> TypeDeclaration))))

(rule LanguageDeclaration (@$: "language" StringLiteral semicolon$))
(termpattern [language : [string : 'v]] (unexpanded [import : 'v]))

(rule PackageDeclaration (@$: "package" QualifiedIdentifier semicolon$))

(rule ImportDeclaration (@$: "import" (? (@: "static")) 
                             (+ QualifiedIdentifier (? (+ dot (@ "all" (tok "*")))))
                             semicolon$))

(rule TypeDeclaration (// ClassDeclaration InterfaceDeclaration semicolon))


;;;;;;;;;;;;;; Class Declaration

(rule ClassDeclaration (@.$: Modifiers "class" Identifier 
                             (? (@$: "extends" Type))
                             (? (@$: "implements" (list Type)))
                             ClassBody))

(rule ClassBody (body-braces$ (* ClassBodyDeclaration)))

(rule ClassBodyDeclaration (// (@ "initializer" (+ (? (@: "static")) Block))
                               (@ "method" (+ Modifiers MethodDeclarator))
                               (@ "constructor" (+ Modifiers ConstructorDeclarator))
                               (@ "field" (+ Modifiers Type VariableDeclarators semicolon))
                               semicolon))

(rule MethodDeclarator (+ Type Identifier FormalParameters (* Dim) (? ThrowsPart) (/ Block semicolon)))

(rule ConstructorDeclarator (+ Identifier FormalParameters
                               (? ThrowsPart) Block))

(rule ThrowsPart (@$: "throws" (list Type)))


;;;;;;;;;;;;;; Interface Declaration

(rule InterfaceDeclaration (@.$: Modifiers "interface" Identifier (? (@$: "extends" (list Type))) (body-braces$ (* InterfaceBodyDeclaration))))

(rule InterfaceBodyDeclaration (// (@ "constant" (+ Modifiers Type (list ConstantDeclarator) semicolon$))
                                   (@ "method" (+ Modifiers InterfaceMethodDeclarator))
                                   semicolon))

(rule InterfaceMethodDeclarator (+ Type Identifier FormalParameters (* Dim) (? ThrowsPart) semicolon$))

(rule ConstantDeclarator (+ Identifier (* Dim) (tok "=") VariableInitializer))

;;;;;;;;;;;;;; Variable Declaration

(rule LocalVariableDeclarationStatement (@ "local-var" (+ VariableModifiers Type VariableDeclarators semicolon)))

(rule VariableDeclarators (list VariableDeclarator))

(rule VariableDeclarator (@ "var-declarator" (+ Identifier (* Dim) 
                                                (? (@ "var-init" (+ (tok "=") VariableInitializer))))))

(rule VariableInitializer (/ ArrayInitializer Expression))

(rule ArrayInitializer (@ "array-init" (braces$ (? (tr-list VariableInitializer)))))


;;;;;;;;;;;;;; Formal Parameter

(rule FormalParameters (@ "formal-params" (parens$ (? (/ (+ (list FormalParameter) (? (+ comma VarArityParameter)))
                                                         VarArityParameter)))))

(rule FormalParameter (@ "param" (+ VariableModifiers Type VariableDeclaratorId)))

(rule VarArityParameter (@ "var-param" (+ VariableModifiers Type (tok "...") VariableDeclaratorId)))

(rule VariableModifiers (* (@: "final")))

(rule VariableDeclaratorId (@ "name" (+ Identifier (* Dim))))


;;;;;;;;;;;;;; Statements

(rule Block (@ "block" (braces$ (* BlockStatement))))

(rule BlockStatement  (// LocalVariableDeclarationStatement
                          Statement))

(rule Statement (// Block
                    (@$: "if" ParExpression Statement (? (@$: "else" Statement)))
                    (@: "for" (parens (+ (? ForInit) semicolon (? Expression) semicolon (? Expressions))) Statement)
                    (@$: "do" Statement (@$: "while" ParExpression semicolon$))
                    (@$: "while" ParExpression Statement)
                    (@$: "switch" ParExpression (braces$ (* SwitchBlockStatementGroup)))
                    (@$: "synchronized" ParExpression Block)
                    (@$: "return" (? Expression) semicolon$)
                    (@$: "throw" Expression semicolon$)
                    (@$: "break" (? Identifier) semicolon$)
                    (@$: "continue" (? Identifier) semicolon$)
                    (@ "label" (+ Identifier colon Statement))
                    (@$: "try" Block (/ (+ (+ CatchClause (* CatchClause)) (? Finally)) Finally))
                    (@ "statement-expr" (+ Expression semicolon))
                    semicolon))


(rule ForInit (/ (+ VariableModifiers Type VariableDeclarators) 
                 Expressions))

(rule CatchClause (@$: "catch" (parens$ FormalParameter) Block))

(rule Finally (@$: "finally" Block))

(rule SwitchBlockStatementGroup (+ SwitchLabel colon (* BlockStatement)))

(rule SwitchLabel (/ (@$: "case" Expression)
                     (@: "default")))

;;;;;;;;;;;;;; Expressions

(rule Expressions (list Expression))

(rule Expression (/ (@ "add-assign-expr" (+ Expression1 (oper "+=") Expression))
                    (@ "sub-assign-expr" (+ Expression1 (oper "-=") Expression))
                    (@ "mul-assign-expr" (+ Expression1 (oper "*=") Expression))
                    (@ "div-assign-expr" (+ Expression1 (oper "/=") Expression))
                    (@ "and-assign-expr" (+ Expression1 (oper "&=") Expression))
                    (@ "ior-assign-expr" (+ Expression1 (oper "|=") Expression))
                    (@ "xor-assign-expr" (+ Expression1 (oper "^=") Expression))
                    (@ "mod-assign-expr" (+ Expression1 (oper "%=") Expression))
                    (@ "lsh-assign-expr" (+ Expression1 (oper "<<=") Expression))
                    (@ "rsh-assign-expr" (+ Expression1 (oper ">>=") Expression))
                    (@ "rot-assign-expr" (+ Expression1 (oper ">>>=") Expression))
                    (@ "assign-expr" (+ Expression1 (oper "=") Expression))
                    Expression1))

(rule Expression1 (/ (@ "cond-expr" (+ Expression2 (oper "?") Expression (oper ":") Expression1))
                     Expression2))

(rule Expression2 (/ (@ "cond-or-expr" (+ Expression2 (oper "||") Expression3))
                     Expression3))

(rule Expression3 (/ (@ "cond-and-expr" (+ Expression3 (oper "&&") Expression4))
                     Expression4))

(rule Expression4 (/ (@ "ior-expr" (+ Expression4 (oper "|") Expression5))
                     Expression5))

(rule Expression5 (/ (@ "xor-expr" (+ Expression5 (oper "^") Expression6))
                     Expression6))

(rule Expression6 (/ (@ "and-expr" (+ Expression6 (oper "&") Expression7))
                     Expression7))

(rule Expression7 (/ (@ "eq-expr" (+ Expression7 (oper "==") Expression8))
                     (@ "neq-expr" (+ Expression7 (oper "!=") Expression8))
                     Expression8))

(rule Expression8 (/ (@.$: Expression8 "instanceof" Type)
                     (@ "less-eq-expr" (+ Expression9 (oper "<=") Expression9))
                     (@ "less-expr" (+ Expression9 (oper "<") Expression9))
                     (@ "greater-eq-expr" (+ Expression9 (oper ">=") Expression9))
                     (@ "greater-expr" (+ Expression9 (oper ">") Expression9))
                     Expression9))

(rule Expression9 (/ (@ "rrot-expr" (+ Expression9 (oper ">>>") Expression10))
                     (@ "rsh-expr" (+ Expression9 (oper ">>") Expression10))
                     (@ "lsh-expr" (+ Expression9 (oper "<<") Expression10))
                     Expression10))

(rule Expression10 (/ (@ "add-expr" (+ Expression10 (oper "+") Expression11))
                      (@ "sub-expr" (+ Expression10 (oper "-") Expression11))
                      Expression11))

(rule Expression11 (/ (@ "mul-expr" (+ Expression11 (oper "*") UnaryExpression))
                      (@ "div-expr" (+ Expression11 (oper "/") UnaryExpression))
                      (@ "mod-expr" (+ Expression11 (oper "%") UnaryExpression))
                      UnaryExpression))

;(def-pattern right-assoc-expr (self next (opname op) ...)
;    (rule self (/ (@ opname (+ next op self)) ...
;                            next))

(rule UnaryExpression (+ SelectorExpression (* PostfixOp)))

(rule SelectorExpression (+ PrefixExpression (* (/ DimExpr
                                                   (+ dot Selector)))))

(rule Selector (// (+ (kw "this"))
                   (+ SuperInvocation)
                   InnerCreator
                   (+ Identifier (? Arguments))))

(rule PrefixExpression (+ (* PrefixOp) CastExpression))

(rule CastExpression (/ (@ "cast" (+ (parens Type) UnaryExpression)) Primary))

(rule Primary (// Literal
                  ParExpression
                  (@$: "this")
                  SuperInvocation                  
                  Creator
                  (+ QualifiedIdentifier (? (/ (brackets Expression)
                                               Arguments
                                               (+ (* Dim) dot (kw "class")) 
                                               (+ dot (/ (kw "this") 
                                                         (+ (kw "super") Arguments) 
                                                         InnerCreator)))))))

(rule PrefixOp (/ (@ "inc" (oper "++"))
                  (@ "dec" (oper "--"))
                  (@ "not" (oper "!"))
                  (@ "inv" (oper "~"))
                  (@ "pos" (oper "+"))
                  (@ "neg" (oper "-"))))

(rule PostfixOp (/ (@ "inc" (oper "++"))
                   (@ "dec" (oper "--"))))


(rule ParExpression (@ "par-expr" (parens$ Expression)))  

(rule Arguments (@ "arguments" (parens$ (? Expressions))))

(rule SuperInvocation (@$: "super" (/ Arguments (+ dot Identifier (? Arguments)))))

(rule Creator (@$: "new" (/ BasicType CreatedName) (/ ArrayCreatorRest
                                                      ClassCreatorRest)))

(rule ArrayCreatorRest (/ (+ Dim (* Dim) ArrayInitializer)
                          (+ DimExpr (* DimExpr) (* Dim))))

(rule InnerCreator (+ (kw "new") Identifier ClassCreatorRest))

(rule ClassCreatorRest (+ Arguments (? ClassBody)))

(rule Dim (@ "dim" (brackets ())))

(rule DimExpr (@ "dim-expr" (brackets Expression)))

;;;;;;;;;;;;;; Types and Modifiers

(rule Type (@ "type" (+ (/ BasicType CreatedName) 
                        (* Dim))))

(rule CreatedName (seq (+ Identifier ) dot))

(rule BasicType (// (@: "void")
                    (@: "byte")
                    (@: "short")
                    (@: "char")
                    (@: "int")
                    (@: "long")
                    (@: "float")
                    (@: "double")
                    (@: "boolean")))

(rule Modifier (// (@: "public")
                   (@: "protected")
                   (@: "private")
                   (@: "static")
                   (@: "abstract")
                   (@: "final")
                   (@: "native")
                   (@: "synchronized")
                   (@: "transient")
                   (@: "volatile")
                   (@: "strictfp")))

(rule Modifiers (@ "modifiers" (* Modifier)))


;;;;;;;;;;;;;; whitespace and Comments

(rule whitespace (/ (+ (/ whitespacechar LineComment BlockComment) whitespace) ()))

(rule LineComment (+ "//" (* (+ (! newline) anychar)) newline))

(rule BlockComment (/ (+ "/*" ($ (+ (* (+ (! "*/") anychar)) "*/") "unclosed comment"))))

(rule newline (/ (+ returnchar linefeedchar) returnchar linefeedchar))

;;;;;;;;;;;;;; Identifiers and Terminals

; TODO: exclude the keywords from identifiers
(rule Identifier (tok (< (+ (! keyword) (/ letterchar "_" "$") (* letterordigit)))))

(rule QualifiedIdentifier (+ Identifier (* (+ dot Identifier))))

(rule letterordigit (/ letterchar digitchar "_" "$"))

(rule OperatorChar (/ "!" "%" "^" "&" "*" "-" "+" "=" "|" "?" "<" ">" ":" "/"))

(rule dot (tok "."))

(rule semicolon (tok ";"))

(rule semicolon$ ($ semicolon "';' expected"))

(rule comma (tok ","))

(rule colon (tok ":"))

(rule endoffile (! anychar))

;;;;;;;;;;;;;; Literals

(rule Literal (/ FloatingPointLiteral
                 IntegerLiteral
                 CharacterLiteral
                 StringLiteral
                 BooleanLiteral
                 NullLiteral))

(rule FloatingPointLiteral (@ "floating-point" (tok (< (/ HexadecimalFloatingPointLiteral DecimalFloatingPointLiteral)))))

(rule HexadecimalFloatingPointLiteral (+ HexSignificand BinaryExponent (? FloatTypeSuffix)))

(rule HexSignificand (+ HexNumeral (? ".") (? HexDigits)))

(rule BinaryExponent (+ (/ "p" "P") SignedInteger))

(rule FloatTypeSuffix (/ "f" "F" "d" "D"))

(rule DecimalFloatingPointLiteral (/ (+ "." Digits (? ExponentPart) (? FloatTypeSuffix))
                                     (+ Digits "." (? Digits) (? ExponentPart) (? FloatTypeSuffix))
                                     (+ Digits (? ExponentPart) FloatTypeSuffix)
                                     (+ Digits ExponentPart (? FloatTypeSuffix))))

(rule ExponentPart (+ (/ "e" "E") SignedInteger))

(rule SignedInteger (+ (? (/ "+" "-")) Digits))

(rule IntegerLiteral (@ "integer" (tok (< (/ (+ HexNumeral (? IntegerTypeSuffix))
                                             (+ OctalNumeral (? IntegerTypeSuffix))
                                             (+ DecimalNumeral (? IntegerTypeSuffix)))))))

(rule HexNumeral (+ (/ "0x" "0X") HexDigits))

(rule OctalNumeral (+ "0" (* OctalDigit)))

(rule DecimalNumeral Digits)

(rule IntegerTypeSuffix (/ "l" "L"))

(rule OctalDigit (/ "0" "1" "2" "3" "4" "5" "6" "7"))

(rule HexDigits (+ hexdigitchar (* hexdigitchar)))

(rule Digits (+ digitchar (* digitchar)))

(rule CharacterLiteral (@ "char" (tok (+ singlequotechar (! singlequotechar) (< Character) singlequotechar))))

(rule Character (/ (+ backslashchar (/ "b" "t" "n" "f" "r" doublequotechar singlequotechar backslashchar)) 
                   (+ backslashchar "u" ($ (+ hexdigitchar hexdigitchar hexdigitchar hexdigitchar) "Illegal unicode escape"))
                   (+ backslashchar ($ (/ (+ (/ "0" "1" "2" "3") OctalDigit OctalDigit) (+ OctalDigit OctalDigit) OctalDigit) "Illegal octal escape")) 
                   (+ (! returnchar) (! linefeedchar) asciichar)))

(rule StringLiteral (@ "string" (tok (+ doublequotechar (< (* (+ (! doublequotechar) Character))) doublequotechar))))

(rule BooleanLiteral (/ (@: "true") (@: "false")))

(rule NullLiteral (@: "null"))

