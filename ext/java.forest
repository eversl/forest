
; Syntax definition for java lang spec 1.0

(import "core.patterns.forest")
(import "core.rules.forest")

(import "standard.patterns.forest")
(import "standard.rules.forest")

(import "functional.patterns.forest")
(import "functional.rules.forest")
;(import "functional.forest")

; start parsing here
(rule start (+ whitespace CompilationUnit endoffile))

(rule endoffile (! anychar))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 3.4 Line Terminators
(rule newline (/ (+ returnchar linefeedchar) returnchar linefeedchar))

;; 3.5 Input Elements and Tokens

;; 3.6 White Space
; (rule whitespacechar (/ spacechar tabchar formfeedchar newline))

(rule whitespace (/ (+ (/ whitespacechar Comment) whitespace) ()))

;; 3.7 Comments
(rule Comment (// TraditionalComment EndOfLineComment DocumentationComment))

(rule TraditionalComment (+ "/*" (/ (& "*/") (! "*")) CommentTail))

(rule DocumentationComment (+ "/**" CommentTail))

(rule CommentTail ($ (+ (* (+ (! "*/") anychar)) "*/") "unclosed comment"))

(rule EndOfLineComment (+ "//" (* (+ (! newline) anychar)) newline))

;; 3.8 Identifiers
(rule Identifier (tok (< (+ (! keyword) (/ letterchar "_" "$") (* letterordigit)))))

(rule letterordigit (/ letterchar digitchar "_" "$"))

;; 3.9 Keywords

;; 3.10 Literals
(rule Literal (/ FloatingPointLiteral
                 IntegerLiteral
                 CharacterLiteral
                 StringLiteral
                 BooleanLiteral
                 NullLiteral))

;;; 3.10.1 Integer Literals
(rule IntegerLiteral (@ "integer" (tok (< (/ (+ HexNumeral (? IntegerTypeSuffix))
                                             (+ OctalNumeral (? IntegerTypeSuffix))
                                             (+ DecimalNumeral (? IntegerTypeSuffix)))))))


(rule IntegerTypeSuffix (/ "l" "L"))

(rule DecimalNumeral (+ (! "0") Digits))

(rule Digits (*1 digitchar))

(rule HexNumeral (+ (/ "0x" "0X") (*1 hexdigitchar)))

(rule OctalNumeral (+ "0" (* OctalDigit)))

(rule OctalDigit (/ "0" "1" "2" "3" "4" "5" "6" "7"))


;;; 3.10.2 Floating-Point Literals
(rule FloatingPointLiteral (@ "floating-point" (tok (< (/ (+ "." Digits (? ExponentPart) (? FloatTypeSuffix))
                                                          (+ Digits "." (? Digits) (? ExponentPart) (? FloatTypeSuffix))
                                                          (+ Digits (? ExponentPart) FloatTypeSuffix)
                                                          (+ Digits ExponentPart (? FloatTypeSuffix)))))))

(rule ExponentPart (+ (/ "e" "E") SignedInteger))

(rule SignedInteger (+ (? (/ "+" "-")) Digits))

(rule FloatTypeSuffix (/ "f" "F" "d" "D"))

;;; 3.10.3 Boolean Literals
(rule BooleanLiteral (/ (@: "true") (@: "false")))

;;; 3.10.4 Character Literals
(rule CharacterLiteral (@ "char" (tok (+ singlequotechar (! singlequotechar) (< Character) singlequotechar))))

(rule Character (/ (+ backslashchar (/ "b" "t" "n" "f" "r" doublequotechar singlequotechar backslashchar)) 
                   (+ backslashchar "u" ($ (+ hexdigitchar hexdigitchar hexdigitchar hexdigitchar) "Illegal unicode escape"))
                   (+ backslashchar ($ (/ (+ (/ "0" "1" "2" "3") OctalDigit OctalDigit) (+ OctalDigit OctalDigit) OctalDigit) "Illegal octal escape")) 
                   (+ (! backslashchar) (! returnchar) (! linefeedchar) asciichar)))

;;; 3.10.5 String Literals
(rule StringLiteral (@ "string" (tok (+ doublequotechar (< (* (+ (! doublequotechar) Character))) doublequotechar))))

;;; 3.10.6 Escape Sequences for Character and String Literals

;;; 3.10.7 The Null Literal
(rule NullLiteral (@: "null"))

;;; 3.11 Separators
(rule dot (tok "."))

(rule semicolon (tok ";"))

(rule semicolon$ ($ semicolon "';' expected"))

(rule comma (tok ","))

(rule colon (tok ":"))

;;; 3.12 Operators
(rule operatorchar (/ "=" ">" "<" "!" "~" "?" ":" "#" "%" "^" "&" "*" "+" "-" "|" "/"))

(rule HexadecimalFloatingPointLiteral (+ HexSignificand BinaryExponent (? FloatTypeSuffix)))

(rule HexSignificand (+ HexNumeral (? ".") (* hexdigitchar)))

(rule BinaryExponent (+ (/ "p" "P") SignedInteger))

;; 4.1 The Kinds of Types and Values
(rule Type (/ ReferenceType PrimitiveType))

;; 4.2 Primitive Types and Values
(rule PrimitiveType (// NumericType (@: "boolean")))

(rule NumericType (// IntegralType FloatingPointType))

(rule IntegralType (// (@: "byte") (@: "short") (@: "int") (@: "long") (@: "char")))

(rule FloatingPointType (// (@: "float") (@: "double")))

;; 4.3 Reference Types and Values
(rule ReferenceType (/ (@ "array-type" (+ Type (brackets ()))) ClassOrInterfaceType))

(rule ClassOrInterfaceType (// ClassType InterfaceType))

(rule ClassType TypeName)

(rule InterfaceType TypeName)

;; 6.5 Determining the Meaning of a Name
(rule PackageName (@ "package-name" (seq Identifier dot)))

(rule PackagePrefix (@ "package-name" (+ Identifier (* (+ dot Identifier (& (+ dot Identifier)))))))

(rule TypeName (@ "type-name" (/ (+ PackagePrefix dot Identifier) Identifier)))

(rule ExpressionName (@ "expression-name" (/ (+ AmbiguousName dot Identifier) Identifier)))

(rule MethodName (/ (+ AmbiguousName dot Identifier) 
                    (+ (@ "this" ()) Identifier)))

;(rule AmbiguousName (@ "ambiguous-name" (+ Identifier (* (+ dot Identifier (& (+ dot Identifier)))))))
(rule AmbiguousName (@ "ambiguous-name" (+ (/ (+ AmbiguousName dot Identifier)
                                            Identifier) (& (+ dot Identifier)))))


;; 7.3 Compilation Units
(rule CompilationUnit (+ (> PackageDeclaration) (* (> LanguageDeclaration)) (* (> ImportDeclaration)) (* (> TypeDeclaration))))

(rule LanguageDeclaration (@$: "language" StringLiteral semicolon$))
(termpattern [language : [string : 'v]] (unexpanded [import : 'v]))


(rule PackageDeclaration (/ (@$: "package" PackageName semicolon$) (@ "package" ())))

;; 7.5 Import Declarations
(rule ImportDeclaration (+ (@ "import_" (+ (kw "import") (// (+ PackageName dot (@ "all" (tok "*")))
                                                             (+ TypeName)) semicolon$))))

;;; 7.6 Type Declarations
(rule TypeDeclaration (// ClassDeclaration InterfaceDeclaration semicolon))

;; 8.1 Class Declaration
(rule ClassDeclaration (@.$: (@ "modifiers" (* ClassModifier)) "class" Identifier Super (? Interfaces) ClassBody))

;;; 8.1.2 Class Modifiers
(rule ClassModifier (// (@: "public") (@: "abstract") (@: "final")))

;;; 8.1.3 Superclasses and Subclasses
(rule Super (/ (@$: "extends" ClassType) (@ "extends" ())))

;;; 8.1.4 Superinterfaces
(rule Interfaces (@$: "implements" (list InterfaceType)))

;;; 8.1.5 Class Body and Member Declarations
(rule ClassBody (body-braces$ (* ClassBodyDeclaration)))

(rule ClassBodyDeclaration (// FieldDeclaration MethodDeclaration StaticInitializer ConstructorDeclaration))

;; 8.3 Field Declarations
(rule FieldDeclaration (@ "field" (+ (@ "modifiers" (* FieldModifier)) Type VariableDeclarators semicolon)))

(rule VariableDeclarators (list VariableDeclarator))

(rule VariableDeclarator (@ "var-declarator" (+ VariableDeclaratorId (?+ (tok "=") VariableInitializer))))

(rule VariableDeclaratorId (+ Identifier (* Dim)))

(rule VariableInitializer (// Expression ArrayInitializer))

;;; 8.3.1 Field Modifiers
(rule FieldModifier (// 
                     (@: "public") (@: "protected") (@: "private") (@: "final") (@: "static") (@: "transient") (@: "volatile")))

;; 8.4 Method Declarations
(rule MethodDeclaration (@ "method" (+  MethodHeader MethodBody)))

(rule MethodHeader (+ (@ "modifiers" (* MethodModifier)) ResultType MethodDeclarator (? Throws)))

(rule ResultType (// Type (@: "void")))

(rule MethodDeclarator (+ Identifier FormalParameters))

;;; 8.4.1 Formal Parameters

(rule FormalParameters (@ "formal-params" (parens (? (list FormalParameter)))))

(rule FormalParameter (+ Type VariableDeclaratorId))

;;; 8.4.3 Method Modifiers
(rule MethodModifier (// (@: "public") (@: "protected") (@: "private") (@: "abstract") (@: "static") (@: "final") (@: "synchronized") (@: "native")))

;;; 8.4.4 Method Throws
(rule Throws (@: "throws" (list ClassType)))

;;; 8.4.5 Method Body
(rule MethodBody (// Block semicolon))

;; 8.5 Static Initializers
(rule StaticInitializer (+ (@: "static" Block)))

;; 8.6 Constructor Declarations
(rule ConstructorDeclaration (@ "constructor" (+ (@ "modifiers" (* ConstructorModifier)) ConstructorDeclarator (? Throws) ConstructorBody)))

(rule ConstructorDeclarator (+ SimpleTypeName FormalParameters))

(rule SimpleTypeName Identifier)

;;; 8.6.3 Constructor Modifiers
(rule ConstructorModifier (// (@: "public") (@: "protected") (@: "private")))

;;; 8.6.5 Constructor Body
(rule ConstructorBody (braces (+ (? ExplicitConstructorInvocation) (* BlockStatement))))

(rule ExplicitConstructorInvocation (// (+ (@: "this") Arguments semicolon)
                                        (+ (@: "super") Arguments semicolon)))

;; 9.1 Interface Declarations
(rule InterfaceDeclaration (@.: (@ "modifiers" (* InterfaceModifier)) "interface" Identifier (? ExtendsInterfaces) InterfaceBody))

;;; 9.1.2 Interface Modifiers
(rule InterfaceModifier (// (@: "public") (@: "abstract")))

;;; 9.1.3 Superinterfaces
(rule ExtendsInterfaces (@: "extends" (list InterfaceType)))

;;; 9.1.4 Interface Body and Member Declarations
(rule InterfaceBody (braces (* InterfaceMemberDeclaration)))

(rule InterfaceMemberDeclaration (// ConstantDeclaration AbstractMethodDeclaration))

;; 9.3 Field (Constant) Declarations
(rule ConstantDeclaration (+ (@ "modifiers" (* ConstantModifier)) Type VariableDeclarator semicolon))

(rule ConstantModifier (// (@: "public") (@: "static") (@: "final")))

;; 9.4 Abstract Method Declarations
(rule AbstractMethodDeclaration (+ (@ "modifiers" (* AbstractMethodModifier)) ResultType MethodDeclarator (? Throws) semicolon))

(rule AbstractMethodModifier (// (@: "public") (@: "abstract")))

;; 10.6 Arrays Initializers
(rule ArrayInitializer (braces (? (tr-list VariableInitializer))))

;; 14.2 Blocks
(rule Block (@ "block" (braces (* BlockStatement))))

(rule BlockStatement (// LocalVariableDeclarationStatement Statement))

;; 14.3 Local Variable Declaration Statements
(rule LocalVariableDeclarationStatement (@ "local-var" (+ LocalVariableDeclaration semicolon)))

(rule LocalVariableDeclaration (+ Type VariableDeclarators))

;; 14.4 Statements
(rule Statement (// StatementWithoutTrailingSubstatement
                    LabeledStatement
                    (/ IfThenElseStatement
                       IfThenStatement)
                    WhileStatement
                    ForStatement))

(rule StatementNoShortIf (// StatementWithoutTrailingSubstatement
                             LabeledStatementNoShortIf
                             IfThenElseStatementNoShortIf
                             WhileStatementNoShortIf
                             ForStatementNoShortIf))

(rule StatementWithoutTrailingSubstatement (// Block
                                               EmptyStatement
                                               ExpressionStatement
                                               SwitchStatement
                                               DoStatement
                                               BreakStatement
                                               ContinueStatement
                                               ReturnStatement
                                               SynchronizedStatement
                                               ThrowStatement
                                               TryStatement))

;; 14.5 The Empty Statement
(rule EmptyStatement semicolon)

;; 14.6 Labeled Statements
(rule LabeledStatement (@ "label" (+ Identifier colon Statement)))

(rule LabeledStatementNoShortIf (@ "label" (+ Identifier colon StatementNoShortIf)))

;; 14.7 Expression Statements
(rule ExpressionStatement (+ Expression semicolon))


;; 14.8 The if Statement
(rule IfThenStatement (@: "if" (parens Expression) Statement))

(rule IfThenElseStatement (@: "if" (parens Expression) StatementNoShortIf (@: "else" Statement)))

(rule IfThenElseStatementNoShortIf (@: "if" (parens Expression) StatementNoShortIf (@: "else" StatementNoShortIf)))

;; 14.9 The switch Statement
(rule SwitchStatement (@: "switch" (parens Expression) SwitchBlock))

(rule SwitchBlock (braces (+ (* SwitchBlockStatementGroup) (* SwitchLabel))))

(rule SwitchBlockStatementGroup (+ (*1 SwitchLabel) (*1 BlockStatement)))

(rule SwitchLabel (// (@: "case" ConstantExpression colon) (@: "default" colon)))

;; 14.10 The while Statement
(rule WhileStatement (@: "while" (parens Expression) Statement))

(rule WhileStatementNoShortIf (@: "while" (parens Expression) StatementNoShortIf))

;; 14.11 The do Statement
(rule DoStatement (@: "do" Statement (@: "while" (parens Expression)) semicolon))

;; 14.12 The for Statement
(rule ForStatement (@: "for" (parens (+ (? ForInit) semicolon (? Expression) semicolon (? ForUpdate))) Statement))

(rule ForStatementNoShortIf (@: "for" (parens (+ (? ForInit) semicolon (? Expression) semicolon (? ForUpdate))) StatementNoShortIf))

(rule ForInit (/ LocalVariableDeclaration (list Expression)))

(rule ForUpdate (list Expression))

;; 14.13 The break Statement
(rule BreakStatement (@: "break" (? Identifier) semicolon))

;; 14.14 The continue Statement
(rule ContinueStatement (@: "continue" (? Identifier) semicolon))

;; 14.15 The return Statement
(rule ReturnStatement (@: "return" (? Expression) semicolon))

;; 14.16 The throw Statement
(rule ThrowStatement (@: "throw" Expression semicolon))

;; 14.17 The synchronized Statement
(rule SynchronizedStatement (@: "synchronized" (parens Expression) Block))

;; 14.18 The try statement
(rule TryStatement (@: "try" Block (// (*1 CatchClause) (+ (* CatchClause) Finally))))

(rule CatchClause (@: "catch" (parens FormalParameter) Block))

(rule Finally (@: "finally" Block))

;; 15.7 Primary Expressions
(rule Primary (/ ArrayAccess
                 FieldAccess
                 MethodInvocation
                 Literal
                 (@: "this")
                 (@: "super")
                 (+ (parens Expression) (! UnaryExpressionNotPlusMinus))
                 ClassInstanceCreationExpression
                 ArrayCreationExpression
                 ExpressionName))
						  
;; 15.8 Class Instance Creation Expressions
(rule ClassInstanceCreationExpression (@: "new" ClassType Arguments))

(rule Arguments (@ "arguments" (parens (? Expressions))))

;; 15.9 Array Creation Expressions
(rule ArrayCreationExpression (// (@: "new" (+ PrimitiveType (*1 DimExpr) (* Dim))) 
                                  (@: "new" (+ TypeName (*1 DimExpr) (* Dim)))))

(rule DimExpr (@ "dim-expr" (brackets Expression)))

(rule Dim (@ "dim" (brackets ())))

;; 15.10 Field Access Expressions
(rule FieldAccess (@ "field-access" (+ Primary dot Identifier (! Arguments))))

;; 15.11 Method Invocation Expressions
(rule MethodInvocation (@ "method-invocation" 
                          (+ (/ (+ Primary dot Identifier) MethodName) Arguments)))

;; 15.12 Array Access Expressions
(rule ArrayAccess (@ "array-access" (+ Primary DimExpr)))

;; 15.13 Postfix Expressions
(rule PostfixExpression (/ PostIncrementExpression PostDecrementExpression Primary))

;;; 15.13.2 Postfix Increment Operator ++
(rule PostIncrementExpression (@ "postfix-inc" (+ PostfixExpression (oper "++"))))

;;; 15.13.3 Postfix Decrement Operator --
(rule PostDecrementExpression (@ "postfix-dec" (+ PostfixExpression (oper "--"))))

;; 15.14 Unary Operators
(rule UnaryExpression (// PreIncrementExpression
                          PreDecrementExpression
                          (@ "pos-expr" (+ (oper "+") UnaryExpression))
                          (@ "neg-expr" (+ (oper "-") UnaryExpression))
                          UnaryExpressionNotPlusMinus))

(rule PreIncrementExpression (@ "prefix-inc" (+ (oper "++") UnaryExpression)))

(rule PreDecrementExpression (@ "prefix-dec" (+ (oper "--") UnaryExpression)))

(rule UnaryExpressionNotPlusMinus (// PostfixExpression
                                      (@ "inv-expr" (+ (oper "~") UnaryExpression))
                                      (@ "not-expr" (+ (oper "!") UnaryExpression))
                                      CastExpression))

;; 15.15 Cast Expressions
(rule CastExpression (@ "cast" (// (+ (parens (+ PrimitiveType (* Dim))) UnaryExpression)
                                   (+ (parens ReferenceType) UnaryExpressionNotPlusMinus))))

;; 15.16 Multiplicative Operators
(rule MultiplicativeExpression (/ (@ "mul-expr" (+ MultiplicativeExpression (oper "*") UnaryExpression))  
                                  (@ "div-expr" (+ MultiplicativeExpression (oper "/") UnaryExpression))
                                  (@ "mod-expr" (+ MultiplicativeExpression (oper "%") UnaryExpression))
                                  UnaryExpression))  

;; 15.17 Additive Operators
(rule AdditiveExpression (/ (@ "add-expr" (+ AdditiveExpression (oper "+") MultiplicativeExpression))
                            (@ "sub-expr" (+ AdditiveExpression (oper "-") MultiplicativeExpression))
                            MultiplicativeExpression))

;; 15.18 Shift Operators
(rule ShiftExpression (/ (@ "rrot-expr" (+ ShiftExpression (oper ">>>") AdditiveExpression))
                         (@ "rsh-expr" (+ ShiftExpression (oper ">>") AdditiveExpression))
                         (@ "lsh-expr" (+ ShiftExpression (oper "<<") AdditiveExpression))
                         AdditiveExpression))

;; 15.19 Relational Operators
(rule RelationalExpression (/ (@ "lt-expr" (+ RelationalExpression (oper "<") ShiftExpression))
                              (@ "gt-expr" (+ RelationalExpression (oper ">") ShiftExpression))
                              (@ "lte-expr" (+ RelationalExpression (oper "<=") ShiftExpression))
                              (@ "gte-expr" (+ RelationalExpression (oper ">=") ShiftExpression))
                              (@ "instanceof-expr" (+ RelationalExpression (tok "instanceof") ReferenceType))
                              ShiftExpression))

;; 15.20 Equality Operators
(rule EqualityExpression (/ (@ "eq-expr" (+ EqualityExpression (oper "==") RelationalExpression))
                            (@ "neq-expr" (+ EqualityExpression (oper "!=") RelationalExpression))
                            RelationalExpression))

;; 15.21 Bitwise and Logical Operators

(rule AndExpression (/ (@ "and-expr" (+ AndExpression (oper "&") EqualityExpression))
                       EqualityExpression))

(rule ExclusiveOrExpression (/ (@ "xor-expr" (+ ExclusiveOrExpression (oper "^") AndExpression))
                               AndExpression))

(rule InclusiveOrExpression (/ (@ "ior-expr" (+ InclusiveOrExpression (oper "|") ExclusiveOrExpression))
                               ExclusiveOrExpression))

; 15.22 Conditional-And Operator &&
(rule ConditionalAndExpression (/ (@ "cond-and-expr" (+ ConditionalAndExpression (oper "&&") InclusiveOrExpression))
                                  InclusiveOrExpression))

;; 15.23 Conditional-Or Operator ||
(rule ConditionalOrExpression (/ (@ "cond-or-expr" (+ ConditionalOrExpression (oper "||") ConditionalAndExpression))
                                 ConditionalAndExpression))

;; 15.24 Conditional Operator ? :
(rule ConditionalExpression (/ (@ "cond-expr" (+ ConditionalOrExpression (oper "?") Expression (oper ":") ConditionalExpression))
                               ConditionalOrExpression))


;; 15.25 Assignment Operators

(rule AssignmentExpression (/ Assignment ConditionalExpression))

(rule Assignment (// (@ "add-assign-expr" (+ LeftHandSide (oper "+=") AssignmentExpression))
                     (@ "sub-assign-expr" (+ LeftHandSide (oper "-=") AssignmentExpression))
                     (@ "mul-assign-expr" (+ LeftHandSide (oper "*=") AssignmentExpression))
                     (@ "div-assign-expr" (+ LeftHandSide (oper "/=") AssignmentExpression))
                     (@ "and-assign-expr" (+ LeftHandSide (oper "&=") AssignmentExpression))
                     (@ "ior-assign-expr" (+ LeftHandSide (oper "|=") AssignmentExpression))
                     (@ "xor-assign-expr" (+ LeftHandSide (oper "^=") AssignmentExpression))
                     (@ "mod-assign-expr" (+ LeftHandSide (oper "%=") AssignmentExpression))
                     (@ "lsh-assign-expr" (+ LeftHandSide (oper "<<=") AssignmentExpression))
                     (@ "rsh-assign-expr" (+ LeftHandSide (oper ">>=") AssignmentExpression))
                     (@ "rot-assign-expr" (+ LeftHandSide (oper ">>>=") AssignmentExpression))
                     (@ "assign-expr" (+ LeftHandSide (oper "=") AssignmentExpression))))

(rule LeftHandSide Primary)


;; 15.26 Expression
(rule Expression AssignmentExpression)

(rule Expressions (list Expression))

;; 15.27 Constant Expression
(rule ConstantExpression Expression)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    Functional transformation rules for java

(termpattern [cons : 'hd [lst : '''tl]]
             [lst : 'hd '''tl])

{{ functional   

function map (fn, lst(hd, tl...)) = cons( `fn`(hd), map(fn, lst(tl...)))
           | (fn, lst(    tl...)) = lst(tl...)


function class (modifiers, clsname, extends, body) = typecheck(classdef(modifiers, clsname, extends, body))

function typecheck (classdef(modifiers, clsname, extends, body(elems...))) = map("typecheck", lst(elems...))
                 | (method (modifiers, type, name, params, block(elems...))) = map("typecheck", lst(elems...))
                 | (method-invocation (ambiguous-name(names...), name, arguments)) = typecheck(method-invocation (disambiguate(ambiguous-name(names...)), name, arguments))
                 | (method-invocation (access_expr, name, arguments(elems...))) = lookup(Method(typecheck(access_expr), name, map("typecheck", lst(elems...))))
                 | (field-access (type_expr, field)) = lookup(Field(type_expr, field))
                 | (type-name (package, name)) = lookup(Type(package, name))

                 | (field (modifiers, type, var-declarator(varname, initializer))) = and(type<=(type, typecheck(initializer)), type)

                 | (string(s)) = Class_info("java", "lang", "String")
                 | (integer(i)) = int()
                 | (null()) = void()


function disambiguate (ambiguous-name(ambiguous-name("System"), "out")) = field-access(Class_info("java", "lang", "System"), "out")

function lookup (Type(package-name (package-name( "java"), "lang"), "System")) = Class_info("java", "lang", "System")
              | (Field(Class_info ("java", "lang", "System"), "out")) = Class_info("java", "io", "PrintStream")
              | (Method(Class_info("java", "io", "PrintStream"), "println", lst(Class_info("java", "lang", "String")))) = void()


function type<= (t, t) = true()
              | (type-name("String"), void()) = true()


function and (val) = val
           | (true(), rest...) = and(rest...)
           | (rest...) = false()

}}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;[class : [modifiers : [public]] #"HelloWorld" [extends : [type-name : #"Object"]] 
;  [body : [method : [modifiers : [public] [static]] [void] #"main" [formal-params : [array-type : [type-name : #"String"]] #"args"] 
;    [block : [method-invocation : [ambiguous-name : [ambiguous-name : #"System"] #"out"] #"println" [arguments : [string : #"Hello, World"]]]]]]]
;
; -->
;
; [ClassFile : [Class_info : #"HelloWorld"] [Class_info : #"java" #"lang" #"Object"] [access_flags : [public]] [interfaces] 
;     [fields]
;     [methods : [method_info : [access_flags : [public]] #"<init>" [MethodDescriptor : [void]] 
;         [attributes : [Code_attribute : 
;             [return : [invokespecial : [Methodref_info : [Class_info : #"java" #"lang" #"Object"] #"<init>" [MethodDescriptor : [void]] [this]]]] 
;     ]]]
;		[method_info : [access_flags : [public] [static]] #"main" [MethodDescriptor : [void] [Array : [Class_info : #"java" #"lang" #"String"]]] 
;         [attributes : [Code_attribute : 
;             [invokevirtual : [Methodref_info : [Class_info : #"java" #"io" #"PrintStream"] "println" [MethodDescriptor : [void] [Class_info : #"java" #"lang" #"String"]]]
;                 [getstatic : [Fieldref : [Class_info : #"java" #"lang" #"System"] #"out" [Class_info : #"java" #"io" #"PrintStream"]]] 
;                 [string : #"Hello, World"]] 
;     ]]]]
;     [attributes]]
;
;
;
; Compiled from "HelloWorld.java"
; public class HelloWorld extends java.lang.Object{
; public HelloWorld();
;   Code:
;    0: aload_0
;    1: invokespecial #1; //Method java/lang/Object."<init>":()V
;    4: return
; 
; public static void main(java.lang.String[]);
;   Code:
;    0: getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;
;    3: ldc #3; //String Hello, World
;    5: invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
;    8: return
; 
; }
