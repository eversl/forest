
; Syntax definition for java lang spec 1.0

(extend "core.forest")

(extend "standard.patterns.forest")
(extend "standard.rules.forest")

(extend "functional.patterns.forest")
(extend "functional.rules.forest")
(include "functional.forest")

; start parsing here
(rule start (+ whitespace CompilationUnit endoffile))

(rule endoffile (! anychar))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; 3.4 Line Terminators
(rule newline (/ (+ returnchar linefeedchar) returnchar linefeedchar))

;; 3.5 Input Elements and Tokens

;; 3.6 White Space
; (rule whitespacechar (/ spacechar tabchar formfeedchar newline))

(rule whitespace (/ (+ (/ whitespacechar Comment) whitespace) ()))

;; 3.7 Comments
(rule Comment (// TraditionalComment EndOfLineComment DocumentationComment))

(rule TraditionalComment (+ "/*" (/ (& "*/") (! "*")) CommentTail))

(rule DocumentationComment (+ "/**" CommentTail))

(rule CommentTail ($ (+ (* (+ (! "*/") anychar)) "*/") "unclosed comment"))

(rule EndOfLineComment (+ "//" (* (+ (! newline) anychar)) newline))

;; 3.8 Identifiers
(rule Identifier (tok (< (+ (! keyword) (/ letterchar "_" "$") (* letterordigit)))))

(rule letterordigit (/ letterchar digitchar "_" "$"))

;; 3.9 Keywords

;; 3.10 Literals
(rule Literal (/ FloatingPointLiteral
                 IntegerLiteral
                 CharacterLiteral
                 StringLiteral
                 BooleanLiteral
                 NullLiteral))

;;; 3.10.1 Integer Literals
(rule IntegerLiteral (@ "integer" (tok (< (/ (+ HexNumeral (? IntegerTypeSuffix))
                                             (+ OctalNumeral (? IntegerTypeSuffix))
                                             (+ DecimalNumeral (? IntegerTypeSuffix)))))))


(rule IntegerTypeSuffix (/ "l" "L"))

(rule DecimalNumeral (+ (! "0") Digits))

(rule Digits (*1 digitchar))

(rule HexNumeral (+ (/ "0x" "0X") (*1 hexdigitchar)))

(rule OctalNumeral (+ "0" (* OctalDigit)))

(rule OctalDigit (/ "0" "1" "2" "3" "4" "5" "6" "7"))


;;; 3.10.2 Floating-Point Literals
(rule FloatingPointLiteral (@ "floating-point" (tok (< (/ (+ "." Digits (? ExponentPart) (? FloatTypeSuffix))
                                                          (+ Digits "." (? Digits) (? ExponentPart) (? FloatTypeSuffix))
                                                          (+ Digits (? ExponentPart) FloatTypeSuffix)
                                                          (+ Digits ExponentPart (? FloatTypeSuffix)))))))

(rule ExponentPart (+ (/ "e" "E") SignedInteger))

(rule SignedInteger (+ (? (/ "+" "-")) Digits))

(rule FloatTypeSuffix (/ "f" "F" "d" "D"))

;;; 3.10.3 Boolean Literals
(rule BooleanLiteral (/ (@: "true") (@: "false")))

;;; 3.10.4 Character Literals
(rule CharacterLiteral (@ "char" (tok (+ singlequotechar (! singlequotechar) (< Character) singlequotechar))))

(rule Character (/ (+ backslashchar (/ "b" "t" "n" "f" "r" doublequotechar singlequotechar backslashchar)) 
                   (+ backslashchar "u" ($ (+ hexdigitchar hexdigitchar hexdigitchar hexdigitchar) "Illegal unicode escape"))
                   (+ backslashchar ($ (/ (+ (/ "0" "1" "2" "3") OctalDigit OctalDigit) (+ OctalDigit OctalDigit) OctalDigit) "Illegal octal escape")) 
                   (+ (! backslashchar) (! returnchar) (! linefeedchar) asciichar)))

;;; 3.10.5 String Literals
(rule StringLiteral (@ "string" (tok (+ doublequotechar (< (* (+ (! doublequotechar) Character))) doublequotechar))))

;;; 3.10.6 Escape Sequences for Character and String Literals

;;; 3.10.7 The Null Literal
(rule NullLiteral (@: "null"))

;;; 3.11 Separators
(rule dot (tok "."))

(rule semicolon (tok ";"))

(rule semicolon$ ($ semicolon "';' expected"))

(rule comma (tok ","))

(rule colon (tok ":"))

;;; 3.12 Operators
(rule operatorchar (/ "=" ">" "<" "!" "~" "?" ":" "#" "%" "^" "&" "*" "+" "-" "|" "/"))

(rule HexadecimalFloatingPointLiteral (+ HexSignificand BinaryExponent (? FloatTypeSuffix)))

(rule HexSignificand (+ HexNumeral (? ".") (* hexdigitchar)))

(rule BinaryExponent (+ (/ "p" "P") SignedInteger))

;; 4.1 The Kinds of Types and Values
(rule Type (/ ReferenceType PrimitiveType))

;; 4.2 Primitive Types and Values
(rule PrimitiveType (// NumericType (@: "boolean")))

(rule NumericType (// IntegralType FloatingPointType))

(rule IntegralType (// (@: "byte") (@: "short") (@: "int") (@: "long") (@: "char")))

(rule FloatingPointType (// (@: "float") (@: "double")))

;; 4.3 Reference Types and Values
(rule ReferenceType (/ (@ "array-type" (+ Type (brackets ()))) ClassOrInterfaceType))

(rule ClassOrInterfaceType (// ClassType InterfaceType))

(rule ClassType TypeName)

(rule InterfaceType TypeName)

;; 6.5 Determining the Meaning of a Name
(rule PackageName (@ "package-name" (seq Identifier dot)))

(rule PackagePrefix (@ "package-name" (+ Identifier (* (+ dot Identifier (& (+ dot Identifier)))))))

(rule TypeName (@ "type-name" (/ (+ PackagePrefix dot Identifier) Identifier)))

(rule ExpressionName (@ "expression-name" (/ (+ AmbiguousName dot Identifier) Identifier)))

(rule MethodName (/ (+ AmbiguousName dot Identifier) 
                    (+ (@ "this" ()) Identifier)))

;(rule AmbiguousName (@ "ambiguous-name" (+ Identifier (* (+ dot Identifier (& (+ dot Identifier)))))))
(rule AmbiguousName (@ "ambiguous-name" (+ (/ (+ AmbiguousName dot Identifier)
                                            Identifier) (& (+ dot Identifier)))))


;; 7.3 Compilation Units
(rule CompilationUnit (+ (> PackageDeclaration) (* (> LanguageDeclaration)) (* (> extendDeclaration)) (* (> TypeDeclaration))))

(rule LanguageDeclaration (@$: "language" StringLiteral semicolon$))
(termpattern [language : [string : 'v]] (unexpanded [extend : 'v]))


(rule PackageDeclaration (/ (@$: "package" PackageName semicolon$) (@ "package" ())))

;; 7.5 extend Declarations
(rule extendDeclaration (+ (@$: "import" (// (+ PackageName dot (@ "all" (tok "*")))
                                             (+ TypeName)) semicolon$)))

;;; 7.6 Type Declarations
(rule TypeDeclaration (// ClassDeclaration InterfaceDeclaration semicolon))

;; 8.1 Class Declaration
(rule ClassDeclaration (@.$: (@ "modifiers" (* ClassModifier)) "class" Identifier Super (? Interfaces) ClassBody))

;;; 8.1.2 Class Modifiers
(rule ClassModifier (// (@: "public") (@: "abstract") (@: "final")))

;;; 8.1.3 Superclasses and Subclasses
(rule Super (/ (@$: "extends" ClassType) (@ "extends" ())))

;;; 8.1.4 Superinterfaces
(rule Interfaces (@$: "implements" (list InterfaceType)))

;;; 8.1.5 Class Body and Member Declarations
(rule ClassBody (body-braces$ (* ClassBodyDeclaration)))

(rule ClassBodyDeclaration (// FieldDeclaration MethodDeclaration StaticInitializer ConstructorDeclaration))

;; 8.3 Field Declarations
(rule FieldDeclaration (@ "field" (+ (@ "modifiers" (* FieldModifier)) Type VariableDeclarators semicolon)))

(rule VariableDeclarators (list VariableDeclarator))

(rule VariableDeclarator (@ "var-declarator" (+ VariableDeclaratorId (?+ (tok "=") VariableInitializer))))

(rule VariableDeclaratorId (+ Identifier (* Dim)))

(rule VariableInitializer (// Expression ArrayInitializer))

;;; 8.3.1 Field Modifiers
(rule FieldModifier (// 
                     (@: "public") (@: "protected") (@: "private") (@: "final") (@: "static") (@: "transient") (@: "volatile")))

;; 8.4 Method Declarations
(rule MethodDeclaration (@ "method" (+  MethodHeader MethodBody)))

(rule MethodHeader (+ (@ "modifiers" (* MethodModifier)) ResultType MethodDeclarator (? Throws)))

(rule ResultType (// Type (@: "void")))

(rule MethodDeclarator (+ Identifier FormalParameters))

;;; 8.4.1 Formal Parameters

(rule FormalParameters (@ "formal-params" (parens (? (list FormalParameter)))))

(rule FormalParameter (@ "param" (+ Type VariableDeclaratorId)))

;;; 8.4.3 Method Modifiers
(rule MethodModifier (// (@: "public") (@: "protected") (@: "private") (@: "abstract") (@: "static") (@: "final") (@: "synchronized") (@: "native")))

;;; 8.4.4 Method Throws
(rule Throws (@: "throws" (list ClassType)))

;;; 8.4.5 Method Body
(rule MethodBody (// Block semicolon))

;; 8.5 Static Initializers
(rule StaticInitializer (+ (@: "static" Block)))

;; 8.6 Constructor Declarations
(rule ConstructorDeclaration (@ "constructor" (+ (@ "modifiers" (* ConstructorModifier)) ConstructorDeclarator (? Throws) ConstructorBody)))

(rule ConstructorDeclarator (+ SimpleTypeName FormalParameters))

(rule SimpleTypeName Identifier)

;;; 8.6.3 Constructor Modifiers
(rule ConstructorModifier (// (@: "public") (@: "protected") (@: "private")))

;;; 8.6.5 Constructor Body
(rule ConstructorBody (@ "block" (braces (+ (? ExplicitConstructorInvocation) (* BlockStatement)))))

(rule ExplicitConstructorInvocation (// (+ (@: "this") Arguments semicolon)
                                        (+ (@: "super") Arguments semicolon)))

;; 9.1 Interface Declarations
(rule InterfaceDeclaration (@.: (@ "modifiers" (* InterfaceModifier)) "interface" Identifier (? ExtendsInterfaces) InterfaceBody))

;;; 9.1.2 Interface Modifiers
(rule InterfaceModifier (// (@: "public") (@: "abstract")))

;;; 9.1.3 Superinterfaces
(rule ExtendsInterfaces (@: "extends" (list InterfaceType)))

;;; 9.1.4 Interface Body and Member Declarations
(rule InterfaceBody (braces (* InterfaceMemberDeclaration)))

(rule InterfaceMemberDeclaration (// ConstantDeclaration AbstractMethodDeclaration))

;; 9.3 Field (Constant) Declarations
(rule ConstantDeclaration (+ (@ "modifiers" (* ConstantModifier)) Type VariableDeclarator semicolon))

(rule ConstantModifier (// (@: "public") (@: "static") (@: "final")))

;; 9.4 Abstract Method Declarations
(rule AbstractMethodDeclaration (+ (@ "modifiers" (* AbstractMethodModifier)) ResultType MethodDeclarator (? Throws) semicolon))

(rule AbstractMethodModifier (// (@: "public") (@: "abstract")))

;; 10.6 Arrays Initializers
(rule ArrayInitializer (@ "array-init" (braces (+ (? (list VariableInitializer)) (? comma)))))

;; 14.2 Blocks
(rule Block (@ "block" (braces (* BlockStatement))))

(rule BlockStatement (// LocalVariableDeclarationStatement Statement))

;; 14.3 Local Variable Declaration Statements
(rule LocalVariableDeclarationStatement (+ LocalVariableDeclaration semicolon))

(rule LocalVariableDeclaration (@ "local-var" (+ Type VariableDeclarators)))

;; 14.4 Statements
(rule Statement (// StatementWithoutTrailingSubstatement
                    LabeledStatement
                    (/ IfThenElseStatement
                       IfThenStatement)
                    WhileStatement
                    ForStatement))

(rule StatementNoShortIf (// StatementWithoutTrailingSubstatement
                             LabeledStatementNoShortIf
                             IfThenElseStatementNoShortIf
                             WhileStatementNoShortIf
                             ForStatementNoShortIf))

(rule StatementWithoutTrailingSubstatement (// Block
                                               EmptyStatement
                                               ExpressionStatement
                                               SwitchStatement
                                               DoStatement
                                               BreakStatement
                                               ContinueStatement
                                               ReturnStatement
                                               SynchronizedStatement
                                               ThrowStatement
                                               TryStatement))

;; 14.5 The Empty Statement
(rule EmptyStatement (@ "empty-stmt" semicolon))

;; 14.6 Labeled Statements
(rule LabeledStatement (@ "label" (+ Identifier colon Statement)))

(rule LabeledStatementNoShortIf (@ "label" (+ Identifier colon StatementNoShortIf)))

;; 14.7 Expression Statements
(rule ExpressionStatement (+ Expression semicolon))


;; 14.8 The if Statement
(rule IfThenStatement (@: "if" (parens Expression) Statement))

(rule IfThenElseStatement (@: "if" (parens Expression) StatementNoShortIf (@: "else" Statement)))

(rule IfThenElseStatementNoShortIf (@: "if" (parens Expression) StatementNoShortIf (@: "else" StatementNoShortIf)))

;; 14.9 The switch Statement
(rule SwitchStatement (@: "switch" (parens Expression) SwitchBlock))

(rule SwitchBlock (braces (+ (* SwitchBlockStatementGroup) (? (@ "switch-group" (+ (*1 SwitchLabel) (@ "block" ())))))))

(rule SwitchBlockStatementGroup (@ "switch-group" (+ (*1 SwitchLabel) (@ "block" (*1 BlockStatement)))))

(rule SwitchLabel (// (@: "case" ConstantExpression colon) (@: "default" colon)))

;; 14.10 The while Statement
(rule WhileStatement (@: "while" (parens Expression) Statement))

(rule WhileStatementNoShortIf (@: "while" (parens Expression) StatementNoShortIf))

;; 14.11 The do Statement
(rule DoStatement (@: "do" Statement (@: "while" (parens Expression)) semicolon))

;; 14.12 The for Statement
(rule ForStatement (@: "for" (parens (+ (@ "for-init" (? ForInit)) semicolon (@ "for-expr" (? Expression)) semicolon (@ "for-update" (? ForUpdate)))) Statement))

(rule ForStatementNoShortIf (@: "for" (parens (+ (? ForInit) semicolon (? Expression) semicolon (? ForUpdate))) StatementNoShortIf))

(rule ForInit (/ LocalVariableDeclaration (list Expression)))

(rule ForUpdate (list Expression))

;; 14.13 The break Statement
(rule BreakStatement (@: "break" (? Identifier) semicolon))

;; 14.14 The continue Statement
(rule ContinueStatement (@: "continue" (? Identifier) semicolon))

;; 14.15 The return Statement
(rule ReturnStatement (@: "return" (? Expression) semicolon))

;; 14.16 The throw Statement
(rule ThrowStatement (@: "throw" Expression semicolon))

;; 14.17 The synchronized Statement
(rule SynchronizedStatement (@: "synchronized" (parens Expression) Block))

;; 14.18 The try statement
(rule TryStatement (@: "try" Block (// (*1 CatchClause) (+ (* CatchClause) Finally))))

(rule CatchClause (@: "catch" (parens FormalParameter) Block))

(rule Finally (@: "finally" Block))

;; 15.7 Primary Expressions
(rule Primary (/ ArrayAccess
                 FieldAccess
                 MethodInvocation
                 Literal
                 (@: "this")
                 (@: "super")
                 (+ (parens Expression) (! UnaryExpressionNotPlusMinus))
                 ClassInstanceCreationExpression
                 ArrayCreationExpression
                 ExpressionName))
						  
;; 15.8 Class Instance Creation Expressions
(rule ClassInstanceCreationExpression (@: "new" ClassType Arguments))

(rule Arguments (@ "arguments" (parens (? Expressions))))

;; 15.9 Array Creation Expressions
(rule ArrayCreationExpression (// (@: "new" (+ PrimitiveType (*1 DimExpr) (* Dim))) 
                                  (@: "new" (+ TypeName (*1 DimExpr) (* Dim)))))

(rule DimExpr (@ "dim-expr" (brackets Expression)))

(rule Dim (@ "dim" (brackets ())))

;; 15.10 Field Access Expressions
(rule FieldAccess (@ "field-access" (+ Primary dot Identifier (! Arguments))))

;; 15.11 Method Invocation Expressions
(rule MethodInvocation (@ "method-invocation" 
                          (+ (/ (+ Primary dot Identifier) MethodName) Arguments)))

;; 15.12 Array Access Expressions
(rule ArrayAccess (@ "array-access" (+ Primary DimExpr)))

;; 15.13 Postfix Expressions
(rule PostfixExpression (/ PostIncrementExpression PostDecrementExpression Primary))

;;; 15.13.2 Postfix Increment Operator ++
(rule PostIncrementExpression (@ "postfix-inc" (+ PostfixExpression (oper "++"))))

;;; 15.13.3 Postfix Decrement Operator --
(rule PostDecrementExpression (@ "postfix-dec" (+ PostfixExpression (oper "--"))))

;; 15.14 Unary Operators
(rule UnaryExpression (// PreIncrementExpression
                          PreDecrementExpression
                          (@ "pos-expr" (+ (oper "+") UnaryExpression))
                          (@ "neg-expr" (+ (oper "-") UnaryExpression))
                          UnaryExpressionNotPlusMinus))

(rule PreIncrementExpression (@ "prefix-inc" (+ (oper "++") UnaryExpression)))

(rule PreDecrementExpression (@ "prefix-dec" (+ (oper "--") UnaryExpression)))

(rule UnaryExpressionNotPlusMinus (// PostfixExpression
                                      (@ "inv-expr" (+ (oper "~") UnaryExpression))
                                      (@ "not-expr" (+ (oper "!") UnaryExpression))
                                      CastExpression))

;; 15.15 Cast Expressions
(rule CastExpression (@ "cast" (// (+ (parens (+ PrimitiveType (* Dim))) UnaryExpression)
                                   (+ (parens ReferenceType) UnaryExpressionNotPlusMinus))))

;; 15.16 Multiplicative Operators
(rule MultiplicativeExpression (/ (@ "mul-expr" (+ MultiplicativeExpression (oper "*") UnaryExpression))  
                                  (@ "div-expr" (+ MultiplicativeExpression (oper "/") UnaryExpression))
                                  (@ "mod-expr" (+ MultiplicativeExpression (oper "%") UnaryExpression))
                                  UnaryExpression))  

;; 15.17 Additive Operators
(rule AdditiveExpression (/ (@ "add-expr" (+ AdditiveExpression (oper "+") MultiplicativeExpression))
                            (@ "sub-expr" (+ AdditiveExpression (oper "-") MultiplicativeExpression))
                            MultiplicativeExpression))

;; 15.18 Shift Operators
(rule ShiftExpression (/ (@ "rrot-expr" (+ ShiftExpression (oper ">>>") AdditiveExpression))
                         (@ "rsh-expr" (+ ShiftExpression (oper ">>") AdditiveExpression))
                         (@ "lsh-expr" (+ ShiftExpression (oper "<<") AdditiveExpression))
                         AdditiveExpression))

;; 15.19 Relational Operators
(rule RelationalExpression (/ (@ "lt-expr" (+ RelationalExpression (oper "<") ShiftExpression))
                              (@ "gt-expr" (+ RelationalExpression (oper ">") ShiftExpression))
                              (@ "lte-expr" (+ RelationalExpression (oper "<=") ShiftExpression))
                              (@ "gte-expr" (+ RelationalExpression (oper ">=") ShiftExpression))
                              (@ "instanceof-expr" (+ RelationalExpression (tok "instanceof") ReferenceType))
                              ShiftExpression))

;; 15.20 Equality Operators
(rule EqualityExpression (/ (@ "eq-expr" (+ EqualityExpression (oper "==") RelationalExpression))
                            (@ "neq-expr" (+ EqualityExpression (oper "!=") RelationalExpression))
                            RelationalExpression))

;; 15.21 Bitwise and Logical Operators

(rule AndExpression (/ (@ "and-expr" (+ AndExpression (oper "&") EqualityExpression))
                       EqualityExpression))

(rule ExclusiveOrExpression (/ (@ "xor-expr" (+ ExclusiveOrExpression (oper "^") AndExpression))
                               AndExpression))

(rule InclusiveOrExpression (/ (@ "ior-expr" (+ InclusiveOrExpression (oper "|") ExclusiveOrExpression))
                               ExclusiveOrExpression))

; 15.22 Conditional-And Operator &&
(rule ConditionalAndExpression (/ (@ "cond-and-expr" (+ ConditionalAndExpression (oper "&&") InclusiveOrExpression))
                                  InclusiveOrExpression))

;; 15.23 Conditional-Or Operator ||
(rule ConditionalOrExpression (/ (@ "cond-or-expr" (+ ConditionalOrExpression (oper "||") ConditionalAndExpression))
                                 ConditionalAndExpression))

;; 15.24 Conditional Operator ? :
(rule ConditionalExpression (/ (@ "cond-expr" (+ ConditionalOrExpression (oper "?") Expression (oper ":") ConditionalExpression))
                               ConditionalOrExpression))


;; 15.25 Assignment Operators

(rule AssignmentExpression (/ Assignment ConditionalExpression))

(rule Assignment (// (@ "add-assign-expr" (+ LeftHandSide (oper "+=") AssignmentExpression))
                     (@ "sub-assign-expr" (+ LeftHandSide (oper "-=") AssignmentExpression))
                     (@ "mul-assign-expr" (+ LeftHandSide (oper "*=") AssignmentExpression))
                     (@ "div-assign-expr" (+ LeftHandSide (oper "/=") AssignmentExpression))
                     (@ "and-assign-expr" (+ LeftHandSide (oper "&=") AssignmentExpression))
                     (@ "ior-assign-expr" (+ LeftHandSide (oper "|=") AssignmentExpression))
                     (@ "xor-assign-expr" (+ LeftHandSide (oper "^=") AssignmentExpression))
                     (@ "mod-assign-expr" (+ LeftHandSide (oper "%=") AssignmentExpression))
                     (@ "lsh-assign-expr" (+ LeftHandSide (oper "<<=") AssignmentExpression))
                     (@ "rsh-assign-expr" (+ LeftHandSide (oper ">>=") AssignmentExpression))
                     (@ "rot-assign-expr" (+ LeftHandSide (oper ">>>=") AssignmentExpression))
                     (@ "assign-expr" (+ LeftHandSide (oper "=") AssignmentExpression))))

(rule LeftHandSide Primary)


;; 15.26 Expression
(rule Expression AssignmentExpression)

(rule Expressions (list Expression))

;; 15.27 Constant Expression
(rule ConstantExpression Expression)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    Functional transformation rules for java

{{ functional   

function class (modifiers, clsname, extends, body) = typecheck(Scope(This(), Class_info(clsname), BottomScope()), classdef(modifiers, clsname, extends, body))

function typecheck (e, classdef(modifiers, clsname, extends, body(elems...))) = map(function (el) = typecheck(e, el), lst(elems...))
                 | (e, field (modifiers, type, decls...)) = and(map(function (var-declarator(varname, initializer)) = and(put-symbol(Field(typecheck (e, expression-name(This())), varname), type), type<=(typecheck(e, initializer), type))
                                                                           | (var-declarator(varname)) = put-symbol(Field(typecheck (e, expression-name(This())), varname), type), lst(decls...)), type)

                 | (e, method (modifiers, mtype, mname, formal-params(elems...))) = typecheck (e, method (modifiers, mtype, mname, formal-params(elems...), throws(), block()))
                 | (e, method (modifiers, mtype, mname, formal-params(elems...), block)) = typecheck (e, method (modifiers, mtype, mname, formal-params(elems...), throws(), block))
                 | (e, method (modifiers, mtype, mname, formal-params(elems...), throws(excs...), block)) = and(typecheck(foldl(function (env, param(ptype, pname)) = 
                                                                                                                                         Scope(pname, ptype, env), 
                                                                                                                                Scope(Method(), mtype, e), 
                                                                                                                                lst(elems...)), block), 
                                                                                                                map(function (exc) = type<=(typecheck(e, exc), Class_info("java", "lang", "Throwable")), lst(excs...)), 
                                                                                                                mtype)
                 | (e, constructor (modifiers, name, params, block(elems...))) = and(map(function (el) = typecheck(e, el), lst(elems...)), void())

                 | (e, block(local-var(type, var-declarator(name, init)), rest...)) = and(warn-type<=(typecheck(e, init), type), typecheck(Scope(name, type, e), block(rest...)))
                 | (e, block(local-var(type, var-declarator(name)), rest...)) = typecheck(Scope(name, type, e), block(rest...))
                 | (e, block(stmt, rest...)) = and(typecheck(e, stmt), typecheck(e, block(rest...)))
                 | (e, block(rest...)) = void()

                 | (e, method-invocation (class, name, arguments(elems...))) = 
                         lookup(Method(typecheck(e, class), name, map(function (el) = typecheck(e, el), lst(elems...))))
                 | (e, field-access (type_expr, field)) = lookup(Field(type_expr, field))
                 | (e, type-name (package, name)) = lookup(Type(package, name))
                 | (e, type-name (name)) = lookup(Type(name))

                 | (e, eq-expr (expr1, expr2)) = and(type-union(typecheck(e, expr1), typecheck(e, expr2)), bool())
                 | (e, lt-expr(expr1, expr2)) = and(type<=(type-union(typecheck(e, expr1), typecheck(e, expr2)), float()), bool())
                 | (e, gt-expr(expr1, expr2)) = and(type<=(type-union(typecheck(e, expr1), typecheck(e, expr2)), float()), bool())
                 | (e, lte-expr(expr1, expr2)) = and(type<=(type-union(typecheck(e, expr1), typecheck(e, expr2)), float()), bool())
                 | (e, gte-expr(expr1, expr2)) = and(type<=(type-union(typecheck(e, expr1), typecheck(e, expr2)), float()), bool())
                 | (e, instanceof-expr(expr1, expr2)) = and(type<=(typecheck(e, expr1), typecheck(e, expr2)), bool())

                 | (e, add-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, sub-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, mul-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, div-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, and-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, ior-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, xor-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, mod-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, lsh-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, rsh-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, rot-assign-expr(left, right)) = type-union(typecheck(e, left), typecheck(e, right))
                 | (e, assign-expr (left, right)) = and(warn-type<=(typecheck(e, left), typecheck(e, right)), typecheck(e, left))

                 | (e, prefix-inc(expression-name(name))) = and(type<=(typecheck(e, expression-name(name)), int()), typecheck(e, expression-name(name)))  ; TODO: let

                 | (e, cast (type, expr))= and(type==(type, typecheck(e, expr)), typecheck(e, expr))
                 | (e, new (type-name, arguments(elems...))) = and(map(function (el) = typecheck(e, el), lst(elems...)), typecheck(e, type-name))
                 | (e, return (val)) = and(type<=(typecheck(e, val), typecheck(e, expression-name (Method()))), typecheck(e, val))   ; TODO: let
                 | (e, return()) = and(type<=(void(), typecheck(e, expression-name (Method()))), void())
                 | (e, label (name, block)) = typecheck(Scope(Label(name), void(), e), block)
                 | (e, break (lbl)) = typecheck(e, expression-name(Label(lbl)))
                 | (e, break ()) = void()
                 | (e, continue (lbl)) = typecheck(e, expression-name(Label(lbl)))
                 | (e, continue ()) = void()
                 | (e, throw (expr)) = and(type<=(typecheck(e, expr), Class_info("java", "lang", "Throwable")), void())

                 | (e, for (for-init(local-var(type, var-declarator(name, val))), for-expr(expr), for-update, stmt)) = 
                         and(type<=(typecheck(Scope(name, type, e), expr), bool()), typecheck(Scope(name, type, e), stmt))  ; TODO: let
                 | (e, while (cond, stmt)) = and(type<=(typecheck(e, cond), bool()), typecheck(e, stmt))
                 | (e, do (stmt, while(cond))) = and(type<=(typecheck(e, cond), bool()), typecheck(e, stmt))
                 | (e, switch (expr, switch-group (case (tag), block))) = and(type<=(typecheck(e, tag), typecheck(e, expr)), typecheck(e, block))
                 | (e, if-kw (pred, stmt)) = and(type<=(typecheck(e, pred), bool()), typecheck(e, stmt), void())
                 | (e, try (try-block, catch(param (type, name), catch-block))) = and(typecheck(e, try-block), typecheck(Scope(name, type, e), catch-block), void())
                 | (e, try (try-block, finally (finally-block))) = and(typecheck(e, try-block), typecheck(e, finally-block), void())
                 | (e, try (try-block, catches...)) = and(map(function (catch(param (type, name), catch-block)) = typecheck(e, try-block), typecheck(Scope(name, type, e), catch-block), lst(catches...)), void())
                 | (e, synchronized(expr, block)) = and(typecheck(e, expr), typecheck(e, block))

                 | (Scope(name, type, e), expression-name (name)) = type
                 | (Scope(This(), type, BottomScope()), expression-name(name)) = get-symbol(Field (type, name))
                 | (Scope(name1, type, e), expression-name (name2)) = typecheck(e, expression-name (name2))

                 | (e, ambiguous-name(name)) = or(lookup(Type(name)), typecheck(e, expression-name(name)))
                 | (e, expression-name(class, name)) = lookup(Field(lookup(class), name))

                 | (e, array-type(inner)) = array-type(inner)

                 | (e, string(s)) = Class_info("java", "lang", "String")
                 | (e, integer(i)) = byte()
                 | (e, floating-point(f)) = float()
                 | (e, char(c)) = char()
                 | (e, int()) = int()
                 | (e, array-init(vals...)) = array-type(foldl(function (t, val) = type-union(t, typecheck(e, val)), void(), lst(vals...)))

                 | (e, true()) = bool()
                 | (e, false()) = bool()

                 | (e, null()) = void()
                 | (e, empty-stmt()) = void()
				 
				 | (e, ambiguous-name(class, name)) = lookup(Field(lookup(class), name))
				 
;function disambiguate (ambiguous-name(ambiguous-name("System"), "out")) = field-access(Class_info("java", "lang", "System"), "out")

function lookup (Type("System")) = Class_info("java", "lang", "System")
              | (Type("String")) = Class_info("java", "lang", "String")
              | (Type("Object")) = Class_info("java", "lang", "Object")
              | (Type("Exception")) = Class_info("java", "lang", "Exception")
              | (Type("RuntimeException")) = Class_info("java", "lang", "RuntimeException")
              | (Type("ClassNotFoundException")) = Class_info("java", "lang", "ClassNotFoundException")
              | (Type("Throwable")) = Class_info("java", "lang", "Throwable")
              | (Type("Error")) = Class_info("java", "lang", "Error")
              | (Type(package-name("java", "io"), "IOException")) = Class_info("java", "io", "IOException")
              | (Type(package-name("java", "io"), "Serializable")) = Class_info("java", "io", "Serializable")
              | (Type(tname)) = Class_info(tname)  ; TODO:  add package name

              | (Field (Class_info("java", "lang", "System"), "out")) = Class_info("java", "io", "PrintStream")
              | (Method(Class_info("java", "io", "PrintStream"), "println", lst(Class_info("java", "lang", "String")))) = void()
              | (Method(Class_info("java", "io", "PrintStream"), "println", lst())) = void()
              | (Field(array-type (type-name("String")), "length")) = int()
              | (Field(type-name(t), "System")) = false()
              | (Field(type, Label(lab))) = false()

              | (Type("args")) = false()
              | (Field("val")) = int()
              | (Field("str")) = Class_info("java", "lang", "String")
              | (Field("i")) = Class_info("java", "lang", "Object")
;              | (Field(type-name("T842is2"), "x")) = int()
;              | (Field(type-name("T842is2"), "y")) = int()

function warn-type<= (t1, t2) = if_ (type<= (t1, t2), true(), seq(message(t1, "error: incompatible types"), false()))

; type<= (t1, t2) : an expression of type t1 can be assigned to a variable of type t2
function type<= (t, t) = true()
              | (array-type(t1), array-type(t2)) = type<=(t1, t2)
              | (t, array-type(a)) = false()
              | (array-type(a), t) = false()
              | (void(), t) = false()
              | (double(), Class_info(names...)) = false()
              | (Class_info("java", "lang", "Object"), t) = false()
              | (t1, t2) = type<=(type-parent(t1), t2)
              | (byte(), type-name("Object")) = false()
              | (t, bool()) = false()
              | (bool(), t) = false()

; type-parent (tc) = tp : tp is the parent of type tc
function type-parent (float()) = double()
                   | (long()) = float()
                   | (int()) = long()
                   | (char()) = int()
                   | (short()) = int()
                   | (byte()) = short()
                   | (void()) = void()
                   | (Class_info("java", "lang", "RuntimeException")) = Class_info("java", "lang", "Exception")
                   | (Class_info("java", "lang", "Exception")) = Class_info("java", "lang", "Throwable")
                   | (Class_info("java", "lang", "Error")) = Class_info("java", "lang", "Throwable")
                   | (Class_info("java", "lang", "Throwable")) = Class_info("java", "lang", "Object")
                   | (Class_info("java", "io", "IOException")) = Class_info("java", "lang", "Exception")
                   | (Class_info("java", "lang", "String")) = Class_info("java", "lang", "Object")

function type-union (t, t) = t
                  | (void(), t) = t
                  | (t, void()) = t
                  | (short(), char()) = short()
                  | (int(), byte()) = int()

function put-symbol (sym, val) = symtable-put(sym, val)
function get-symbol (sym) = symtable-get(sym)
function message(loc, strs...) = message_(loc, strs...)
}}


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
;[class : [modifiers : [public]] #"HelloWorld" [extends : [type-name : #"Object"]] 
;  [body : [method : [modifiers : [public] [static]] [void] #"main" [formal-params : [array-type : [type-name : #"String"]] #"args"] 
;    [block : [method-invocation : [ambiguous-name : [ambiguous-name : #"System"] #"out"] #"println" [arguments : [string : #"Hello, World"]]]]]]]
;
; -->
;
; [ClassFile : [Class_info : #"HelloWorld"] [Class_info : #"java" #"lang" #"Object"] [access_flags : [public]] [interfaces] 
;     [fields]
;     [methods : [method_info : [access_flags : [public]] #"<init>" [MethodDescriptor : [void]] 
;         [attributes : [Code_attribute : 
;             [return : [invokespecial : [Methodref_info : [Class_info : #"java" #"lang" #"Object"] #"<init>" [MethodDescriptor : [void]] [this]]]] 
;     ]]]
;		[method_info : [access_flags : [public] [static]] #"main" [MethodDescriptor : [void] [Array : [Class_info : #"java" #"lang" #"String"]]] 
;         [attributes : [Code_attribute : 
;             [invokevirtual : [Methodref_info : [Class_info : #"java" #"io" #"PrintStream"] "println" [MethodDescriptor : [void] [Class_info : #"java" #"lang" #"String"]]]
;                 [getstatic : [Fieldref : [Class_info : #"java" #"lang" #"System"] #"out" [Class_info : #"java" #"io" #"PrintStream"]]] 
;                 [string : #"Hello, World"]] 
;     ]]]]
;     [attributes]]
;
;
;
; Compiled from "HelloWorld.java"
; public class HelloWorld extends java.lang.Object{
; public HelloWorld();
;   Code:
;    0: aload_0
;    1: invokespecial #1; //Method java/lang/Object."<init>":()V
;    4: return
; 
; public static void main(java.lang.String[]);
;   Code:
;    0: getstatic #2; //Field java/lang/System.out:Ljava/io/PrintStream;
;    3: ldc #3; //String Hello, World
;    5: invokevirtual #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V
;    8: return
; 
; }
