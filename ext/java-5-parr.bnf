compilationUnit:
        annotations ((packageDeclaration importDeclaration* typeDeclaration*) | (classOrInterfaceDeclaration typeDeclaration*))
        packageDeclaration? importDeclaration* typeDeclaration*
annotations:
        annotation+
annotation:
        "@" annotationName ("(" (elementValuePairs | elementValue)? ")")?
annotationName:
        Identifier ("." Identifier)*
Identifier:
        Letter (Letter | JavaIDDigit)*
Letter:
        "a"
        "b"
        "c"
        "d"
        "e"
        "f"
        "g"
        "h"
        "i"
        "j"
        "k"
        "l"
        "m"
        "n"
        "o"
        "p"
        "q"
        "r"
        "s"
        "t"
        "u"
        "v"
        "w"
        "x"
        "y"
        "z"
        "A"
        "B"
        "C"
        "D"
        "E"
        "F"
        "G"
        "H"
        "I"
        "J"
        "K"
        "L"
        "M"
        "N"
        "O"
        "P"
        "Q"
        "R"
        "S"
        "T"
        "U"
        "V"
        "W"
        "X"
        "Y"
        "Z"
JavaIDDigit:
        "0"
        "1"
        "2"
        "3"
        "4"
        "5"
        "6"
        "7"
        "8"
        "9"
        "a"
        "b"
        "c"
        "d"
        "e"
        "f"
        "g"
        "h"
        "i"
        "j"
        "k"
        "l"
        "m"
        "n"
        "o"
        "p"
        "q"
        "r"
        "s"
        "t"
        "u"
        "v"
        "w"
        "x"
        "y"
        "z"
        "A"
        "B"
        "C"
        "D"
        "E"
        "F"
        "G"
        "H"
        "I"
        "J"
        "K"
        "L"
        "M"
        "N"
        "O"
        "P"
        "Q"
        "R"
        "S"
        "T"
        "U"
        "V"
        "W"
        "X"
        "Y"
        "Z"
elementValuePairs:
        elementValuePair ("," elementValuePair)*
elementValuePair:
        Identifier "=" elementValue
elementValue:
        conditionalExpression
        annotation
        elementValueArrayInitializer
conditionalExpression:
        conditionalOrExpression ("?" expression ":" expression)?
conditionalOrExpression:
        conditionalAndExpression ("||" conditionalAndExpression)*
conditionalAndExpression:
        inclusiveOrExpression ("&&" inclusiveOrExpression)*
inclusiveOrExpression:
        exclusiveOrExpression ("|" exclusiveOrExpression)*
exclusiveOrExpression:
        andExpression ("^" andExpression)*
andExpression:
        equalityExpression ("&" equalityExpression)*
equalityExpression:
        instanceOfExpression (("==" | "!=") instanceOfExpression)*
instanceOfExpression:
        relationalExpression ("instanceof" type)?
relationalExpression:
        shiftExpression (relationalOp shiftExpression)*
shiftExpression:
        additiveExpression (shiftOp additiveExpression)*
additiveExpression:
        multiplicativeExpression (("+" | "-") multiplicativeExpression)*
multiplicativeExpression:
        unaryExpression (("*" | "/" | "%") unaryExpression)*
unaryExpression:
        "+" unaryExpression
        "-" unaryExpression
        "++" unaryExpression
        "--" unaryExpression
        unaryExpressionNotPlusMinus
unaryExpressionNotPlusMinus:
        "~" unaryExpression
        "!" unaryExpression
        castExpression
        primary selector* ("++" | "--")?
castExpression:
        "(" primitiveType ")" unaryExpression
        "(" (type | expression) ")" unaryExpressionNotPlusMinus
primitiveType:
        "boolean"
        "char"
        "byte"
        "short"
        "int"
        "long"
        "float"
        "double"
type:
        classOrInterfaceType ("[" "]")*
        primitiveType ("[" "]")*
classOrInterfaceType:
        Identifier typeArguments? ("." Identifier typeArguments?)*
typeArguments:
        "<" typeArgument ("," typeArgument)* ">"
typeArgument:
        type
        "?" (("extends" | "super") type)?
expression:
        conditionalExpression (assignmentOperator expression)?
assignmentOperator:
        "="
        "+="
        "-="
        "*="
        "/="
        "&="
        "|="
        "^="
        "%="
        t1::"<" t2::"<" t3::"="
        t1::">" t2::">" t3::">" t4::("="?)
        t1::">" t2::">" t3::"="
primary:
        parExpression
        "this" ("." Identifier)* identifierSuffix?
        "super" superSuffix
        literal
        "new" creator
        Identifier ("." Identifier)* identifierSuffix?
        primitiveType ("[" "]")* "." "class"
        "void" "." "class"
parExpression:
        "(" expression ")"
identifierSuffix:
        ("[" "]")+ "." "class"
        ("[" expression "]")+
        arguments
        "." "class"
        "." explicitGenericInvocation
        "." "this"
        "." "super" arguments
        "." "new" innerCreator
arguments:
        "(" expressionList? ")"
expressionList:
        expression ("," expression)*
explicitGenericInvocation:
        nonWildcardTypeArguments Identifier arguments
nonWildcardTypeArguments:
        "<" typeList ">"
typeList:
        type ("," type)*
innerCreator:
        nonWildcardTypeArguments? Identifier classCreatorRest
classCreatorRest:
        arguments classBody?
classBody:
        "{" classBodyDeclaration* "}"
classBodyDeclaration:
        ";"
        "static"? block
        modifiers memberDecl
block:
        "{" blockStatement* "}"
blockStatement:
        localVariableDeclarationStatement
        classOrInterfaceDeclaration
        statement
localVariableDeclarationStatement:
        localVariableDeclaration ";"
localVariableDeclaration:
        variableModifiers type variableDeclarators
variableModifiers:
        variableModifier*
variableModifier:
        "final"
        annotation
variableDeclarators:
        variableDeclarator ("," variableDeclarator)*
variableDeclarator:
        variableDeclaratorId ("=" variableInitializer)?
variableDeclaratorId:
        Identifier ("[" "]")*
variableInitializer:
        arrayInitializer
        expression
arrayInitializer:
        "{" (variableInitializer ("," variableInitializer)* ","?)? "}"
classOrInterfaceDeclaration:
        classOrInterfaceModifiers (classDeclaration | interfaceDeclaration)
classOrInterfaceModifiers:
        classOrInterfaceModifier*
classOrInterfaceModifier:
        annotation
        "public"
        "protected"
        "private"
        "abstract"
        "static"
        "final"
        "strictfp"
classDeclaration:
        normalClassDeclaration
        enumDeclaration
normalClassDeclaration:
        "class" Identifier typeParameters? ("extends" type)? ("implements" typeList)? classBody
typeParameters:
        "<" typeParameter ("," typeParameter)* ">"
typeParameter:
        Identifier ("extends" typeBound)?
typeBound:
        type ("&" type)*
enumDeclaration:
        ENUM Identifier ("implements" typeList)? enumBody
ENUM:
        "enum"
enumBody:
        "{" enumConstants? ","? enumBodyDeclarations? "}"
enumConstants:
        enumConstant ("," enumConstant)*
enumConstant:
        annotations? Identifier arguments? classBody?
enumBodyDeclarations:
        ";" classBodyDeclaration*
interfaceDeclaration:
        normalInterfaceDeclaration
        annotationTypeDeclaration
normalInterfaceDeclaration:
        "interface" Identifier typeParameters? ("extends" typeList)? interfaceBody
interfaceBody:
        "{" interfaceBodyDeclaration* "}"
interfaceBodyDeclaration:
        modifiers interfaceMemberDecl
        ";"
modifiers:
        modifier*
modifier:
        annotation
        "public"
        "protected"
        "private"
        "static"
        "abstract"
        "final"
        "native"
        "synchronized"
        "transient"
        "volatile"
        "strictfp"
interfaceMemberDecl:
        interfaceMethodOrFieldDecl
        interfaceGenericMethodDecl
        "void" Identifier voidInterfaceMethodDeclaratorRest
        interfaceDeclaration
        classDeclaration
interfaceMethodOrFieldDecl:
        type Identifier interfaceMethodOrFieldRest
interfaceMethodOrFieldRest:
        constantDeclaratorsRest ";"
        interfaceMethodDeclaratorRest
constantDeclaratorsRest:
        constantDeclaratorRest ("," constantDeclarator)*
constantDeclaratorRest:
        ("[" "]")* "=" variableInitializer
constantDeclarator:
        Identifier constantDeclaratorRest
interfaceMethodDeclaratorRest:
        formalParameters ("[" "]")* ("throws" qualifiedNameList)? ";"
formalParameters:
        "(" formalParameterDecls? ")"
formalParameterDecls:
        variableModifiers type formalParameterDeclsRest
formalParameterDeclsRest:
        variableDeclaratorId ("," formalParameterDecls)?
        "..." variableDeclaratorId
qualifiedNameList:
        qualifiedName ("," qualifiedName)*
qualifiedName:
        Identifier ("." Identifier)*
interfaceGenericMethodDecl:
        typeParameters (type | "void") Identifier interfaceMethodDeclaratorRest
voidInterfaceMethodDeclaratorRest:
        formalParameters ("throws" qualifiedNameList)? ";"
annotationTypeDeclaration:
        "@" "interface" Identifier annotationTypeBody
annotationTypeBody:
        "{" annotationTypeElementDeclaration* "}"
annotationTypeElementDeclaration:
        modifiers annotationTypeElementRest
annotationTypeElementRest:
        type annotationMethodOrConstantRest ";"
        normalClassDeclaration ";"?
        normalInterfaceDeclaration ";"?
        enumDeclaration ";"?
        annotationTypeDeclaration ";"?
annotationMethodOrConstantRest:
        annotationMethodRest
        annotationConstantRest
annotationMethodRest:
        Identifier "(" ")" defaultValue?
defaultValue:
        "default" elementValue
annotationConstantRest:
        variableDeclarators
statement:
        block
        ASSERT expression (":" expression)? ";"
        "if" parExpression statement ("else" statement)?
        "for" "(" forControl ")" statement
        "while" parExpression statement
        "do" statement "while" parExpression ";"
        "try" block ((catches "finally" block) | catches | ("finally" block))
        "switch" parExpression "{" switchBlockStatementGroups "}"
        "synchronized" parExpression block
        "return" expression? ";"
        "throw" expression ";"
        "break" Identifier? ";"
        "continue" Identifier? ";"
        ";"
        statementExpression ";"
        Identifier ":" statement
ASSERT:
        "assert"
forControl:
        enhancedForControl
        forInit? ";" expression? ";" forUpdate?
enhancedForControl:
        variableModifiers type Identifier ":" expression
forInit:
        localVariableDeclaration
        expressionList
forUpdate:
        expressionList
catches:
        catchClause catchClause*
catchClause:
        "catch" "(" formalParameter ")" block
formalParameter:
        variableModifiers type variableDeclaratorId
switchBlockStatementGroups:
        switchBlockStatementGroup*
switchBlockStatementGroup:
        switchLabel+ blockStatement*
switchLabel:
        "case" constantExpression ":"
        "case" enumConstantName ":"
        "default" ":"
constantExpression:
        expression
enumConstantName:
        Identifier
statementExpression:
        expression
memberDecl:
        genericMethodOrConstructorDecl
        memberDeclaration
        "void" Identifier voidMethodDeclaratorRest
        Identifier constructorDeclaratorRest
        interfaceDeclaration
        classDeclaration
genericMethodOrConstructorDecl:
        typeParameters genericMethodOrConstructorRest
genericMethodOrConstructorRest:
        (type | "void") Identifier methodDeclaratorRest
        Identifier constructorDeclaratorRest
methodDeclaratorRest:
        formalParameters ("[" "]")* ("throws" qualifiedNameList)? (methodBody | ";")
methodBody:
        block
constructorDeclaratorRest:
        formalParameters ("throws" qualifiedNameList)? constructorBody
constructorBody:
        "{" explicitConstructorInvocation? blockStatement* "}"
explicitConstructorInvocation:
        nonWildcardTypeArguments? ("this" | "super") arguments ";"
        primary "." nonWildcardTypeArguments? "super" arguments ";"
memberDeclaration:
        type (methodDeclaration | fieldDeclaration)
methodDeclaration:
        Identifier methodDeclaratorRest
fieldDeclaration:
        variableDeclarators ";"
voidMethodDeclaratorRest:
        formalParameters ("throws" qualifiedNameList)? (methodBody | ";")
superSuffix:
        arguments
        "." Identifier arguments?
literal:
        integerLiteral
        FloatingPointLiteral
        CharacterLiteral
        StringLiteral
        booleanLiteral
        "null"
integerLiteral:
        HexLiteral
        OctalLiteral
        DecimalLiteral
HexLiteral:
        "0" ("x" | "X") HexDigit+ IntegerTypeSuffix?
HexDigit:
        "0"
        "1"
        "2"
        "3"
        "4"
        "5"
        "6"
        "7"
        "8"
        "9"
        "a"
        "b"
        "c"
        "d"
        "e"
        "f"
        "A"
        "B"
        "C"
        "D"
        "E"
        "F"
IntegerTypeSuffix:
        "l"
        "L"
OctalLiteral:
        "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")+ IntegerTypeSuffix?
DecimalLiteral:
        ("0" | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)) IntegerTypeSuffix?
FloatingPointLiteral:
        ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* Exponent? FloatTypeSuffix?
        "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ Exponent? FloatTypeSuffix?
        ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ Exponent FloatTypeSuffix?
        ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ FloatTypeSuffix
Exponent:
        ("e" | "E") ("+" | "-")? ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+
FloatTypeSuffix:
        "f"
        "F"
        "d"
        "D"
CharacterLiteral:
        "\'" (EscapeSequence | STR) "\'"
EscapeSequence:
        "\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\")
        UnicodeEscape
        OctalEscape
UnicodeEscape:
        "\\" "u" HexDigit HexDigit HexDigit HexDigit
OctalEscape:
        "\\" ("0" | "1" | "2" | "3") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")
        "\\" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")
        "\\" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")
StringLiteral:
        """ (EscapeSequence | STR)* """
booleanLiteral:
        "true"
        "false"
creator:
        nonWildcardTypeArguments createdName classCreatorRest
        createdName (arrayCreatorRest | classCreatorRest)
createdName:
        classOrInterfaceType
        primitiveType
arrayCreatorRest:
        "[" (("]" ("[" "]")* arrayInitializer) | (expression "]" ("[" expression "]")* ("[" "]")*))
selector:
        "." Identifier arguments?
        "." "this"
        "." "super" superSuffix
        "." "new" innerCreator
        "[" expression "]"
shiftOp:
        t1::"<" t2::("<"?)
        t1::">" t2::">" t3::">"
        t1::">" t2::(">"?)
relationalOp:
        t1::"<" t2::("="?)
        t1::">" t2::("="?)
        "<"
        ">"
elementValueArrayInitializer:
        "{" (elementValue ("," elementValue)*)? ","? "}"
packageDeclaration:
        "package" qualifiedName ";"
importDeclaration:
        "import" "static"? qualifiedName ("." "*")? ";"
typeDeclaration:
        classOrInterfaceDeclaration
        ";"
