javaSource:
        compilationUnit
compilationUnit:
        annotationList packageDeclaration? importDeclaration* typeDecls*
annotationList:
        annotation*
annotation:
        AT qualifiedIdentifier annotationInit?
AT:
        "@"
qualifiedIdentifier:
        IDENT (DOT ident::IDENT)*
IDENT:
        JAVA_ID_START JAVA_ID_PART*
JAVA_ID_START:
        "a"
        "b"
        "c"
        "d"
        "e"
        "f"
        "g"
        "h"
        "i"
        "j"
        "k"
        "l"
        "m"
        "n"
        "o"
        "p"
        "q"
        "r"
        "s"
        "t"
        "u"
        "v"
        "w"
        "x"
        "y"
        "z"
        "A"
        "B"
        "C"
        "D"
        "E"
        "F"
        "G"
        "H"
        "I"
        "J"
        "K"
        "L"
        "M"
        "N"
        "O"
        "P"
        "Q"
        "R"
        "S"
        "T"
        "U"
        "V"
        "W"
        "X"
        "Y"
        "Z"
JAVA_ID_PART:
        JAVA_ID_START
        "0"
        "1"
        "2"
        "3"
        "4"
        "5"
        "6"
        "7"
        "8"
        "9"
DOT:
        "."
annotationInit:
        LPAREN annotationInitializers RPAREN
LPAREN:
        "("
annotationInitializers:
        annotationInitializer (COMMA annotationInitializer)*
        annotationElementValue
annotationInitializer:
        IDENT ASSIGN annotationElementValue
ASSIGN:
        "="
annotationElementValue:
        annotationElementValueExpression
        annotation
        annotationElementValueArrayInitializer
annotationElementValueExpression:
        conditionalExpression
conditionalExpression:
        logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)?
logicalOrExpression:
        logicalAndExpression (LOGICAL_OR logicalAndExpression)*
logicalAndExpression:
        inclusiveOrExpression (LOGICAL_AND inclusiveOrExpression)*
inclusiveOrExpression:
        exclusiveOrExpression (OR exclusiveOrExpression)*
exclusiveOrExpression:
        andExpression (XOR andExpression)*
andExpression:
        equalityExpression (AND equalityExpression)*
equalityExpression:
        instanceOfExpression ((EQUAL | NOT_EQUAL) instanceOfExpression)*
instanceOfExpression:
        relationalExpression (INSTANCEOF type)?
relationalExpression:
        shiftExpression ((LESS_OR_EQUAL | GREATER_OR_EQUAL | LESS_THAN | GREATER_THAN) shiftExpression)*
shiftExpression:
        additiveExpression ((BIT_SHIFT_RIGHT | SHIFT_RIGHT | SHIFT_LEFT) additiveExpression)*
additiveExpression:
        multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)*
multiplicativeExpression:
        unaryExpression ((STAR | DIV | MOD) unaryExpression)*
unaryExpression:
        PLUS unaryExpression
        MINUS unaryExpression
        INC postfixedExpression
        DEC postfixedExpression
        unaryExpressionNotPlusMinus
PLUS:
        "+"
MINUS:
        "-"
INC:
        "++"
postfixedExpression:
        primaryExpression ((outerDot::DOT ((genericTypeArgumentListSimplified? IDENT arguments?) | THIS | (Super::SUPER arguments) | (SUPER innerDot::DOT IDENT arguments?) | innerNewExpression)) | (LBRACK expression RBRACK))* (INC | DEC)?
primaryExpression:
        parenthesizedExpression
        literal
        newExpression
        qualifiedIdentExpression
        genericTypeArgumentListSimplified ((SUPER (arguments | (DOT IDENT arguments))) | (IDENT arguments) | (THIS arguments))
        THIS arguments?
        SUPER arguments
        SUPER DOT IDENT (arguments | EPSILON)
        primitiveType arrayDeclarator* DOT CLASS
        VOID DOT CLASS
parenthesizedExpression:
        LPAREN expression RPAREN
expression:
        assignmentExpression
assignmentExpression:
        conditionalExpression ((ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | AND_ASSIGN | OR_ASSIGN | XOR_ASSIGN | MOD_ASSIGN | SHIFT_LEFT_ASSIGN | SHIFT_RIGHT_ASSIGN | BIT_SHIFT_RIGHT_ASSIGN) assignmentExpression)?
PLUS_ASSIGN:
        "+="
MINUS_ASSIGN:
        "-="
STAR_ASSIGN:
        "*="
DIV_ASSIGN:
        "/="
AND_ASSIGN:
        "&="
OR_ASSIGN:
        "|="
XOR_ASSIGN:
        "^="
MOD_ASSIGN:
        "%="
SHIFT_LEFT_ASSIGN:
        "<<="
SHIFT_RIGHT_ASSIGN:
        ">>="
BIT_SHIFT_RIGHT_ASSIGN:
        ">>>="
RPAREN:
        ")"
literal:
        HEX_LITERAL
        OCTAL_LITERAL
        DECIMAL_LITERAL
        FLOATING_POINT_LITERAL
        CHARACTER_LITERAL
        STRING_LITERAL
        TRUE
        FALSE
        NULL
HEX_LITERAL:
        "0" ("x" | "X") HEX_DIGIT+ INTEGER_TYPE_SUFFIX?
HEX_DIGIT:
        "0"
        "1"
        "2"
        "3"
        "4"
        "5"
        "6"
        "7"
        "8"
        "9"
        "a"
        "b"
        "c"
        "d"
        "e"
        "f"
        "A"
        "B"
        "C"
        "D"
        "E"
        "F"
INTEGER_TYPE_SUFFIX:
        "l"
        "L"
OCTAL_LITERAL:
        "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")+ INTEGER_TYPE_SUFFIX?
DECIMAL_LITERAL:
        ("0" | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)) INTEGER_TYPE_SUFFIX?
FLOATING_POINT_LITERAL:
        ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ((DOT ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT? FLOAT_TYPE_SUFFIX?) | (EXPONENT FLOAT_TYPE_SUFFIX?) | FLOAT_TYPE_SUFFIX)
        DOT ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? FLOAT_TYPE_SUFFIX?
EXPONENT:
        ("e" | "E") ("+" | "-")? ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+
FLOAT_TYPE_SUFFIX:
        "f"
        "F"
        "d"
        "D"
CHARACTER_LITERAL:
        "\'" (ESCAPE_SEQUENCE | STR) "\'"
ESCAPE_SEQUENCE:
        "\\" ("b" | "t" | "n" | "f" | "r" | "\"" | "\'" | "\\")
        UNICODE_ESCAPE
        OCTAL_ESCAPE
UNICODE_ESCAPE:
        "\\" "u" HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
OCTAL_ESCAPE:
        ("0" | "1" | "2" | "3") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")
        "\\" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")
        "\\" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")
STRING_LITERAL:
        """ (ESCAPE_SEQUENCE | STR)* """
TRUE:
        "true"
FALSE:
        "false"
NULL:
        "null"
newExpression:
        NEW ((primitiveType newArrayConstruction) | (genericTypeArgumentListSimplified? qualifiedTypeIdentSimplified (newArrayConstruction | (arguments classBody?))))
NEW:
        "new"
primitiveType:
        BOOLEAN
        CHAR
        BYTE
        SHORT
        INT
        LONG
        FLOAT
        DOUBLE
BOOLEAN:
        "boolean"
CHAR:
        "char"
BYTE:
        "byte"
SHORT:
        "short"
INT:
        "int"
LONG:
        "long"
FLOAT:
        "float"
DOUBLE:
        "double"
newArrayConstruction:
        arrayDeclaratorList arrayInitializer
        LBRACK expression RBRACK (LBRACK expression RBRACK)* arrayDeclaratorList?
arrayDeclaratorList:
        arrayDeclarator+
arrayDeclarator:
        LBRACK RBRACK
LBRACK:
        "["
RBRACK:
        "]"
arrayInitializer:
        LCURLY (variableInitializer (COMMA variableInitializer)* COMMA?)? RCURLY
LCURLY:
        "{"
variableInitializer:
        arrayInitializer
        expression
COMMA:
        ","
RCURLY:
        "}"
genericTypeArgumentListSimplified:
        LESS_THAN genericTypeArgumentSimplified (COMMA genericTypeArgumentSimplified)* genericTypeListClosing
LESS_THAN:
        "<"
genericTypeArgumentSimplified:
        type
        QUESTION
type:
        simpleType
        objectType
simpleType:
        primitiveType arrayDeclaratorList?
objectType:
        qualifiedTypeIdent arrayDeclaratorList?
qualifiedTypeIdent:
        typeIdent (DOT typeIdent)*
typeIdent:
        IDENT genericTypeArgumentList?
genericTypeArgumentList:
        LESS_THAN genericTypeArgument (COMMA genericTypeArgument)* genericTypeListClosing
genericTypeArgument:
        type
        QUESTION genericWildcardBoundType?
QUESTION:
        "?"
genericWildcardBoundType:
        (EXTENDS | SUPER) type
EXTENDS:
        "extends"
SUPER:
        "super"
genericTypeListClosing:
        GREATER_THAN
        SHIFT_RIGHT
        BIT_SHIFT_RIGHT
        EPSILON
GREATER_THAN:
        ">"
SHIFT_RIGHT:
        ">>"
BIT_SHIFT_RIGHT:
        ">>>"
qualifiedTypeIdentSimplified:
        typeIdentSimplified (DOT typeIdentSimplified)*
typeIdentSimplified:
        IDENT genericTypeArgumentListSimplified?
arguments:
        LPAREN expressionList? RPAREN
expressionList:
        expression (COMMA expression)*
classBody:
        LCURLY classScopeDeclarations* RCURLY
classScopeDeclarations:
        block
        STATIC block
        modifierList ((genericTypeParameterList? ((type IDENT formalParameterList arrayDeclaratorList? throwsClause? (block | SEMI)) | (VOID IDENT formalParameterList throwsClause? (block | SEMI)) | (ident::IDENT formalParameterList throwsClause? block))) | (type classFieldDeclaratorList SEMI))
        typeDeclaration
        SEMI
block:
        LCURLY blockStatement* RCURLY
blockStatement:
        localVariableDeclaration SEMI
        typeDeclaration
        statement
localVariableDeclaration:
        localModifierList type classFieldDeclaratorList
localModifierList:
        localModifier*
localModifier:
        FINAL
        annotation
FINAL:
        "final"
classFieldDeclaratorList:
        classFieldDeclarator (COMMA classFieldDeclarator)*
classFieldDeclarator:
        variableDeclaratorId (ASSIGN variableInitializer)?
variableDeclaratorId:
        IDENT arrayDeclaratorList?
SEMI:
        ";"
typeDeclaration:
        modifierList (classTypeDeclaration | interfaceTypeDeclaration | enumTypeDeclaration | annotationTypeDeclaration)
modifierList:
        modifier*
modifier:
        PUBLIC
        PROTECTED
        PRIVATE
        STATIC
        ABSTRACT
        NATIVE
        SYNCHRONIZED
        TRANSIENT
        VOLATILE
        STRICTFP
        localModifier
PUBLIC:
        "public"
PROTECTED:
        "protected"
PRIVATE:
        "private"
STATIC:
        "static"
ABSTRACT:
        "abstract"
NATIVE:
        "native"
SYNCHRONIZED:
        "synchronized"
TRANSIENT:
        "transient"
VOLATILE:
        "volatile"
STRICTFP:
        "strictfp"
classTypeDeclaration:
        CLASS IDENT genericTypeParameterList? classExtendsClause? implementsClause? classBody
CLASS:
        "class"
genericTypeParameterList:
        LESS_THAN genericTypeParameter (COMMA genericTypeParameter)* genericTypeListClosing
genericTypeParameter:
        IDENT bound?
bound:
        EXTENDS type (AND type)*
AND:
        "&"
classExtendsClause:
        EXTENDS type
implementsClause:
        IMPLEMENTS typeList
IMPLEMENTS:
        "implements"
typeList:
        type (COMMA type)*
interfaceTypeDeclaration:
        INTERFACE IDENT genericTypeParameterList? interfaceExtendsClause? interfaceBody
INTERFACE:
        "interface"
interfaceExtendsClause:
        EXTENDS typeList
interfaceBody:
        LCURLY interfaceScopeDeclarations* RCURLY
interfaceScopeDeclarations:
        modifierList ((genericTypeParameterList? ((type IDENT formalParameterList arrayDeclaratorList? throwsClause? SEMI) | (VOID IDENT formalParameterList throwsClause? SEMI))) | (type interfaceFieldDeclaratorList SEMI))
        typeDeclaration
        SEMI
formalParameterList:
        LPAREN ((formalParameterStandardDecl (COMMA formalParameterStandardDecl)* (COMMA formalParameterVarArgDecl)?) | formalParameterVarArgDecl | EPSILON) RPAREN
formalParameterStandardDecl:
        localModifierList type variableDeclaratorId
formalParameterVarArgDecl:
        localModifierList type ELLIPSIS variableDeclaratorId
ELLIPSIS:
        "..."
throwsClause:
        THROWS qualifiedIdentList
THROWS:
        "throws"
qualifiedIdentList:
        qualifiedIdentifier (COMMA qualifiedIdentifier)*
VOID:
        "void"
interfaceFieldDeclaratorList:
        interfaceFieldDeclarator (COMMA interfaceFieldDeclarator)*
interfaceFieldDeclarator:
        variableDeclaratorId ASSIGN variableInitializer
enumTypeDeclaration:
        ENUM IDENT implementsClause? enumBody
ENUM:
        "enum"
enumBody:
        LCURLY enumScopeDeclarations RCURLY
enumScopeDeclarations:
        enumConstants COMMA? enumClassScopeDeclarations?
enumConstants:
        enumConstant (COMMA enumConstant)*
enumConstant:
        annotationList IDENT arguments? classBody?
enumClassScopeDeclarations:
        SEMI classScopeDeclarations*
annotationTypeDeclaration:
        AT INTERFACE IDENT annotationBody
annotationBody:
        LCURLY annotationScopeDeclarations* RCURLY
annotationScopeDeclarations:
        modifierList type ((IDENT LPAREN RPAREN annotationDefaultValue? SEMI) | (classFieldDeclaratorList SEMI))
        typeDeclaration
annotationDefaultValue:
        DEFAULT annotationElementValue
DEFAULT:
        "default"
statement:
        block
        ASSERT expr1::expression ((COLON expr2::expression SEMI) | SEMI)
        IF parenthesizedExpression ifStat::statement ((ELSE elseStat::statement) | EPSILON)
        FOR LPAREN ((forInit SEMI forCondition SEMI forUpdater RPAREN statement) | (localModifierList type IDENT COLON expression RPAREN statement))
        WHILE parenthesizedExpression statement
        DO statement WHILE parenthesizedExpression SEMI
        TRY block ((catches finallyClause?) | finallyClause)
        SWITCH parenthesizedExpression LCURLY switchBlockLabels RCURLY
        SYNCHRONIZED parenthesizedExpression block
        RETURN expression? SEMI
        THROW expression SEMI
        BREAK IDENT? SEMI
        CONTINUE IDENT? SEMI
        IDENT COLON statement
        expression SEMI
        SEMI
ASSERT:
        "assert"
COLON:
        ":"
IF:
        "if"
ELSE:
        "else"
FOR:
        "for"
forInit:
        localVariableDeclaration
        expressionList
        EPSILON
forCondition:
        expression?
forUpdater:
        expressionList?
WHILE:
        "while"
DO:
        "do"
TRY:
        "try"
catches:
        catchClause+
catchClause:
        CATCH LPAREN formalParameterStandardDecl RPAREN block
CATCH:
        "catch"
finallyClause:
        FINALLY block
FINALLY:
        "finally"
SWITCH:
        "switch"
switchBlockLabels:
        switchCaseLabels switchDefaultLabel? switchCaseLabels
switchCaseLabels:
        switchCaseLabel*
switchCaseLabel:
        CASE expression COLON blockStatement*
CASE:
        "case"
switchDefaultLabel:
        DEFAULT COLON blockStatement*
RETURN:
        "return"
THROW:
        "throw"
BREAK:
        "break"
CONTINUE:
        "continue"
qualifiedIdentExpression:
        qualifiedIdentifier ((arrayDeclarator+ DOT CLASS) | arguments | (outerDot::DOT (CLASS | (genericTypeArgumentListSimplified ((Super::SUPER arguments) | (SUPER innerDot::DOT IDENT arguments) | (IDENT arguments))) | THIS | (Super::SUPER arguments) | innerNewExpression)))?
THIS:
        "this"
innerNewExpression:
        NEW genericTypeArgumentListSimplified? IDENT arguments classBody?
DEC:
        "--"
unaryExpressionNotPlusMinus:
        NOT unaryExpression
        LOGICAL_NOT unaryExpression
        LPAREN type RPAREN unaryExpression
        postfixedExpression
NOT:
        "~"
LOGICAL_NOT:
        "!"
STAR:
        "*"
DIV:
        "/"
MOD:
        "%"
SHIFT_LEFT:
        "<<"
LESS_OR_EQUAL:
        "<="
GREATER_OR_EQUAL:
        ">="
INSTANCEOF:
        "instanceof"
EQUAL:
        "=="
NOT_EQUAL:
        "!="
XOR:
        "^"
OR:
        "|"
LOGICAL_AND:
        "&&"
LOGICAL_OR:
        "||"
annotationElementValueArrayInitializer:
        LCURLY (annotationElementValue (COMMA annotationElementValue)*)? COMMA? RCURLY
packageDeclaration:
        PACKAGE qualifiedIdentifier SEMI
PACKAGE:
        "package"
importDeclaration:
        IMPORT STATIC? qualifiedIdentifier DOTSTAR? SEMI
IMPORT:
        "import"
DOTSTAR:
        ".*"
typeDecls:
        typeDeclaration
        SEMI
